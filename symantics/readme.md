# Правила преобразования значений, присваивания и сравнения в Go

В этой статье будут перечислены все правила сравнения значений, преобразования и сравнения в Go. Обратите внимание, что типы параметров типа (часто используемые в пользовательских дженериках) намеренно игнорируются в описаниях правил преобразования, присваиваемости и сравнения. Другими словами, в этой книге не рассматриваются ситуации, в которых задействованы [пользовательские дженерики .](https://go101.org/generics/101.html)

### Правила преобразования стоимости

В Go, если значение `v` может быть явно преобразовано в тип `T` , преобразование может быть представлено в виде формы `(T)(v)` . Для большинства случаев, в частности `T` это имя типа (идентификатор), форма может быть упрощена до `T(v)` .

Один факт, который мы должны знать, заключается в том, что когда он говорит, что значение `x` может быть неявно преобразовано в тип `T` , это означает, что `x` его также можно явно преобразовать в тип `T` .

#### 1\. очевидное правило преобразования

Если два типа обозначают один и тот же тип, то их значения могут быть **неявно** преобразованы в любой из двух типов.

Например,

*   значения типа `byte` и `uint8` могут быть преобразованы друг в друга.
*   значения типа `rune` и `int32` могут быть преобразованы друг в друга.
*   значения типа `[]byte` и `[]uint8` могут быть преобразованы друг в друга.

Больше нечего объяснять об этом правиле, независимо от того, думаете ли вы, что в этом случае есть преобразования или нет.

#### 2\. правила преобразования, связанные с базовым типом

Учитывая неинтерфейсное значение `x` и неинтерфейсный тип `T` , предположим, что типом `x` является `Tx` ,

*   если `Tx` и `T` имеют один и тот же [базовый тип](https://go101.org/article/type-system-overview.html#underlying-type) (игнорируя теги структуры), то `x` могут быть явно преобразованы в `T` .
*   если какой-либо `Tx` или `T` является [безымянным типом](https://go101.org/article/type-system-overview.html#named-type) и их базовые типы идентичны (с учетом тегов структуры), то `x` их можно **неявно** преобразовать в `T` .
*   если `Tx` и `T` имеют разные базовые типы, но оба `Tx` и `T` являются безымянными типами указателей, а их базовые типы имеют один и тот же базовый тип (игнорируя теги структуры), то `x` их можно явно преобразовать в `T` .

*(Обратите внимание, что два случая **игнорирования тегов структуры вступили** в силу, начиная с версии Go 1.8.)*

Пример:

```go
package main

func main() {
	// []int, IntSlice and MySlice share
	// the same underlying type: []int
	type IntSlice []int
	type MySlice  []int
	type Foo = struct{n int `foo`}
	type Bar = struct{n int `bar`}

	var s  = []int{}
	var is = IntSlice{}
	var ms = MySlice{}
	var x map[Bar]Foo
	var y map[Foo]Bar

	// The two implicit conversions both doesn't work.
	/*
	is = ms // error
	ms = is // error
	*/

	// Must use explicit conversions here.
	is = IntSlice(ms)
	ms = MySlice(is)
	x = map[Bar]Foo(y)
	y = map[Foo]Bar(x)

	// Implicit conversions are okay here.
	s = is
	is = s
	s = ms
	ms = s
}

```

Пример преобразования, связанного с указателем:

```go
package main

func main() {
	type MyInt int
	type IntPtr *int
	type MyIntPtr *MyInt

	var pi = new(int)  // the type of pi is *int
	// ip and pi have the same underlying type,
	// and the type of pi is unnamed, so
	// the implicit conversion works.
	var ip IntPtr = pi

	// var _ *MyInt = pi // can't convert implicitly
	var _ = (*MyInt)(pi) // ok, must explicitly

	// Values of *int can't be converted to MyIntPtr
	// directly, but can indirectly.
	/*
	var _ MyIntPtr = pi  // can't convert implicitly
	var _ = MyIntPtr(pi) // can't convert explicitly
	*/
	var _ MyIntPtr = (*MyInt)(pi)  // ok
	var _ = MyIntPtr((*MyInt)(pi)) // ok

	// Values of IntPtr can't be converted to
	// MyIntPtr directly, but can indirectly.
	/*
	var _ MyIntPtr = ip  // can't convert implicitly
	var _ = MyIntPtr(ip) // can't convert explicitly
	*/
	var _ MyIntPtr = (*MyInt)((*int)(ip))  // ok
	var _ = MyIntPtr((*MyInt)((*int)(ip))) // ok
}

```

#### 3\. Правило конверсии для конкретного канала

Учитывая значение канала `x` , предположим, что его тип `Tx` — двунаправленный тип канала, `T` а также тип канала (двунаправленный или нет). Если `Tx` и `T` имеют идентичный тип элемента, а либо `Tx` или `T` являются безымянным типом, то `x` их можно **неявно** преобразовать в `T` .

Пример:

```go
package main

func main() {
	type C chan string
	type C1 chan<- string
	type C2 <-chan string

	var ca C
	var cb chan string

	cb = ca // ok, same underlying type
	ca = cb // ok, same underlying type

	// The 4 lines compile okay for this 3rd rule.
	var _, _ chan<- string = ca, cb // ok
	var _, _ <-chan string = ca, cb // ok
	var _ C1 = cb                   // ok
	var _ C2 = cb                   // ok

	// Values of C can't be converted
	// to C1 and C2 directly.
	/*
	var _ = C1(ca) // compile error
	var _ = C2(ca) // compile error
	*/

	// Values of C can be converted
	// to C1 and C2 indirectly.
	var _ = C1((chan<- string)(ca)) // ok
	var _ = C2((<-chan string)(ca)) // ok
	var _ C1 = (chan<- string)(ca)  // ok
	var _ C2 = (<-chan string)(ca)  // ok
}

```

#### 4\. правила преобразования, связанные с реализацией интерфейса

При заданном значении `x` и типе интерфейса `I` , если тип (или тип по умолчанию) `x` равен `Tx` и `Tx` реализует `I` , то `x` его можно **неявно** преобразовать в тип `I` . Результатом преобразования является значение интерфейса (типа `I` ), которое

*   копия `x` , если `Tx` это не интерфейсный тип;
*   копия динамического значения `x` , если `Tx` это тип интерфейса.

Пожалуйста, прочитайте [интерфейсы в Go](https://go101.org/article/interface.html) для подробностей и примеров.

#### 5\. правило преобразования нетипизированного значения

Нетипизированное значение может быть **неявно** преобразовано в тип `T` , если нетипизированное значение может быть представлено как значение типа `T` .

Пример:

```go
package main

func main() {
	var _ []int = nil
	var _ map[string]int = nil
	var _ chan string = nil
	var _ func()() = nil
	var _ *bool = nil
	var _ interface{} = nil

	var _ int = 123.0
	var _ float64 = 123
	var _ int32 = 1.23e2
	var _ int8 = 1 + 0i
}

```

#### 6\. правило преобразования констант

*(Это правило частично совпадает с предыдущим.)*

Как правило, преобразование константы по-прежнему дает в результате константу. (За исключением преобразования постоянной строки в байтовый или рунический фрагмент, описанный в следующих 8-х правилах.)

Если задано постоянное значение `x` и тип `T` , если `x` его можно представить как значение типа `T` , то `x` его можно явно преобразовать в `T` . В частности, если `x` это нетипизированное значение, то `x` его можно **неявно** преобразовать в `T` .

Пример:

```go
package main

func main() {
	const I = 123
	const I1, I2 int8 = 0x7F, -0x80
	const I3, I4 int8 = I, 0.0

	const F = 0.123456789
	const F32 float32 = F
	const F32b float32 = I
	const F64 float64 = F
	const F64b = float64(I3) // must be explicitly

	const C1, C2 complex64 = F, I
	const I5 = int(C2) // must be explicitly
}

```

#### 7\. непостоянные правила преобразования чисел

Непостоянные значения с плавающей запятой и целые числа могут быть явно преобразованы в любые типы с плавающей запятой и целые числа.

Непостоянные сложные значения могут быть явно преобразованы в любые сложные типы.

Примечание,

*   Сложные непостоянные значения нельзя преобразовать в типы с плавающей запятой и целые числа.
*   Непостоянные значения с плавающей запятой и целые числа не могут быть преобразованы в сложные типы.
*   Переполнение данных и округление допускаются при преобразовании непостоянных чисел. При преобразовании непостоянного числа с плавающей запятой в целое дробная часть отбрасывается (усечение до нуля).

Пример:

```go
package main

import "fmt"

func main() {
	var a, b = 1.6, -1.6 // both are float64
	fmt.Println(int(a), int(b)) // 1 -1

	var i, j int16 = 0x7FFF, -0x8000
	fmt.Println(int8(i), uint16(j)) // -1 32768

	var c1 complex64 = 1 + 2i
	var _ = complex128(c1)
}

```

#### 8\. правила преобразования строк

Если тип (или тип по умолчанию) значения является целочисленным типом, то значение может быть явно преобразовано в строковые типы.

Строковое значение может быть явно преобразовано в тип среза, базовым типом которого является `[]byte` (также известный как `[]uint8` ), и наоборот.

Строковое значение может быть явно преобразовано в тип среза, базовым типом которого является `[]rune` (также известный как `[]int32` ), и наоборот.

Пожалуйста, прочтите [строки в Go](https://go101.org/article/string.html#conversions) для подробностей и примеров.

#### 9\. Срезы связанных конверсий

Начиная с Go 1.17, слайс может быть преобразован в указатель массива. При таком преобразовании, если длина типа базового массива типа указателя больше длины среза, возникает паника.

Вот [пример](https://go101.org/article/container.html#slice-to-array-pointer) .

#### 10\. Правила преобразования небезопасных указателей

Значение указателя любого типа можно явно преобразовать в тип, базовым типом которого является `unsafe.Pointer` , и наоборот.

Значение uintptr можно явно преобразовать в тип, базовым типом которого является `unsafe.Pointer` , и наоборот.

Подробности и примеры см. [в указателях на небезопасные типы в Go .](https://go101.org/article/unsafe.html)

### Правила присвоения значений

Присваивания можно рассматривать как неявные преобразования. Неявные правила преобразования перечислены среди всех правил преобразования в последнем разделе.

Помимо этих правил, целевые значения в назначениях должны быть адресуемыми значениями, выражениями индекса карты или пустым идентификатором.

В назначении исходное значение копируется в целевое значение. Точнее говоря, [непосредственная часть](https://go101.org/article/value-part.html) исходного значения копируется в целевое значение.

Обратите внимание, что передача параметров и возврат результата на самом деле являются присвоением значений.

### Правила сравнения значений

Спецификация Go [гласит](https://golang.org/ref/spec#Comparison_operators) :

При любом сравнении первый операнд должен иметь возможность присваиваться типу второго операнда или наоборот.

Итак, правило сравнения очень похоже на правило присваивания. Другими словами, два значения сравнимы, если одно из них может быть неявно преобразовано в тип другого. Верно? Почти, потому что есть другое правило, имеющее более высокий приоритет, чем упомянутое выше основное правило сравнения.

Если оба операнда в сравнении типизированы, то их типы должны быть [сопоставимого типа](https://go101.org/article/type-system-overview.html#types-not-support-comparison) .

По приведенному выше правилу, если несравнимый тип (который должен быть не интерфейсным типом) реализует интерфейсный тип, то сравнение значений двух типов является недопустимым, даже если значения первого (не интерфейсного) типа могут быть неявно преобразовал последний (интерфейсный) тип.

Обратите внимание: хотя значения типов слайсов/карт/функций не поддерживают сравнения, их можно сравнивать с нетипизированными нулевыми значениями (также известными как голые `nil` идентификаторы).

Описанные выше базовые правила охватывают не все случаи. Что делать, если оба операнда в сравнении являются нетипизированными (постоянными) значениями? Дополнительные правила просты:

*   нетипизированные логические значения можно сравнивать с нетипизированными логическими значениями.
*   нетипизированные числовые значения можно сравнивать с нетипизированными числовыми значениями.
*   нетипизированные строковые значения можно сравнивать с нетипизированными строковыми значениями.

Результаты сравнения двух нетипизированных числовых значений подчиняются интуиции.

Обратите внимание, что нетипизированное значение nil нельзя сравнивать с другим нетипизированным значением nil.

Любое сравнение приводит к нетипизированному логическому значению.

В следующем примере показаны некоторые сравнения, связанные с несравнимыми типами.

```go
package main

// Some variables of incomparable types.
var s []int
var m map[int]int
var f func()()
var t struct {x []int}
var a [5]map[int]int

func main() {
	// The following lines fail to compile.
	/*
	_ = s == s
	_ = m == m
	_ = f == f
	_ = t == t
	_ = a == a
	_ = nil == nil
	_ = s == interface{}(nil)
	_ = m == interface{}(nil)
	_ = f == interface{}(nil)
	*/

	// The following lines compile okay.
	_ = s == nil
	_ = m == nil
	_ = f == nil
	_ = 123 == interface{}(nil)
	_ = true == interface{}(nil)
	_ = "abc" == interface{}(nil)
}

```

#### Как сравниваются два значения?

Предположим, что два значения сравнимы и имеют одинаковый тип `T` . (Если они имеют разные типы, одно из них должно быть неявно преобразовано в тип другого. Здесь мы не рассматриваем случаи, когда оба значения нетипизированы.)

1.  Если `T` это логический тип, то два значения равны, только если они оба `true` или оба `false` .
2.  Если `T` это целочисленный тип, то два значения равны, только если они имеют одинаковое представление в памяти.
3.  Если `T` это тип с плавающей запятой, то два значения равны, только если выполняется любое из следующих условий:
    *   они оба `+Inf` .
    *   они оба `-Inf` .
    *   каждый из них или `-0.0` или `+0.0` .
    *   они оба не являются `NaN` и имеют одинаковые представления байтов в памяти.
4.  Если `T` это сложный тип, то два значения равны, только если равны их действительные части (как значения с плавающей запятой) и мнимые части (как значения с плавающей запятой).
5.  Если `T` это тип указателя (либо безопасный, либо небезопасный), то два значения равны, только если адреса памяти, хранящиеся в них, равны.
6.  Если `T` это тип канала, два значения канала равны, если они оба ссылаются на одно и то же значение базовой внутренней структуры канала или оба являются нулевыми каналами.
7.  Если `T` это тип структуры, то [будет сравниваться каждая пара соответствующих полей двух значений структуры](https://go101.org/article/struct.html#comparison) .
8.  Если `T` это тип массива, то [будет сравниваться каждая пара соответствующих элементов двух значений массива](https://go101.org/article/container.html#comparison) .
9.  Если `T` это тип интерфейса, прочтите, [как сравниваются два значения интерфейса](https://go101.org/article/interface.html#comparison) .
10.  Если `T` это строковый тип, прочтите, [как сравниваются два строковых значения](https://go101.org/article/string.html#comparison) .

Обратите внимание, что сравнение двух интерфейсов с одним и тем же несопоставимым динамическим типом вызывает панику. Ниже приведен пример, в котором при сравнении возникнут некоторые паники.

```go
package main

func main() {
	type T struct {
		a interface{}
		b int
	}
	var x interface{} = []int{}
	var y = T{a: x}
	var z = [3]T{{a: y}}

	// Each of the following line can produce a panic.
	_ = x == x
	_ = y == y
	_ = z == z
}
```
