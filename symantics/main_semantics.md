# Исключения синтаксиса/семантики в Go

В этой статье будут перечислены все виды синтаксических/семантических исключений в Go. Некоторые из этих исключений являются синтаксическими сахарами для удобства программирования, некоторые вызваны встроенными универсальными привилегиями, некоторые существуют по историческим причинам, а некоторые существуют по другим логическим причинам.

### Вложенные вызовы функций

Основное правило:

Если количество возвращаемых результатов вызова функции не равно нулю, а возвращаемые результаты могут использоваться как целые аргументы другого вызова функции, то прежний вызов функции может быть вложен во второй вызов функции, прежний вложенный вызов может не путать с другими аргументами последнего вложенного вызова.

Сахар:

Если вызов функции возвращает ровно один результат, то вызов функции всегда может использоваться как аргумент с одним значением в других вызовах функций, вызов функции с одним результатом может смешиваться с другими аргументами вызовов вложенных функций.

Пример:

```go
package main

import (
	"fmt"
)

func f0() float64 {return 1}
func f1() (float64, float64) {return 1, 2}
func f2(float64, float64) {}
func f3(float64, float64, float64) {}
func f4()(x, y []int) {return}
func f5()(x map[int]int, y int) {return}

type I interface {m()(float64, float64)}
type T struct{}
func (T) m()(float64, float64) {return 1, 2}

func main() {
	// These lines compile okay.
	f2(f0(), 123)
	f2(f1())
	fmt.Println(f1())
	_ = complex(f1())
	_ = complex(T{}.m())
	f2(I(T{}).m())

	// These lines don't compile.
	/*
	f3(123, f1())
	f3(f1(), 123)
	*/

	// This line compiles okay only since
	// Go Toolchain 1.15.
	println(f1())

	// The following 3 lines compile okay
	// only since Go Toolchain 1.13.
	copy(f4())
	delete(f5())
	_ = complex(I(T{}).m())
}

```

### Выберите поля структуры

Основное правило:

Значения указателя не имеют полей.

Сахар:

Мы можем выбирать поля значения структуры с помощью указателей значения структуры.

Пример:

```go
package main

type T struct {
	x int
}

func main() {
	var t T
	var p = &t

	p.x *= 2
	// The above line is a sugar of the following line.
	(*p).x *= 2
}

```

### Аргументы получателя вызовов методов

Основное правило:

Методы, явно объявленные для типа `*T` , точно не являются методами типа `T` .

Сахар:

Хотя методы, явно объявленные для типа `*T` , не являются методами типа `T` , адресуемые значения типа `T` могут использоваться в качестве аргументов получателя вызовов этих методов.

Пример:

```go
package main

type T struct {
	x int
}

func (pt *T) Double() {
	pt.x *= 2
}

func main() {
	// T{3}.Double() // This line fails to compile.

	var t = T{3}

	t.Double() // t.x == 6 now
	// The above line is a sugar of the following line.
	(&t).Double() // t.x == 12 now
}

```

### Взять адреса составных литеральных значений

Основное правило:

Литеральные значения являются неадресуемыми, а неадресуемые значения не могут принимать адреса.

Сахар:

Хотя составные литеральные значения не являются адресуемыми, их адреса можно использовать явно.

Пожалуйста, прочитайте [структуры](https://go101.org/article/struct.html#take-composite-literal-address) и [контейнеры](https://go101.org/article/container.html#take-composite-literal-address) для деталей.

### Селекторы на именованных одноуровневых указателях

Основное правило:

Как правило, селекторы нельзя использовать для значений [именованных](https://go101.org/article/type-system-overview.html#underlying-type) типов указателей.

Сахар:

Если `x` является значением типа именованного одноуровневого указателя, а selector `(*x).f` является допустимым селектором, то the `x.f` также является допустимым селектором, его можно рассматривать как сокращение от `(*x).f` .

Селекторы никогда нельзя использовать для значений типов **многоуровневых** указателей, независимо от того, именованы ли типы многоуровневых указателей или нет.

Исключение сахара:

Сахар действителен, только если `f` обозначает поле структуры, он недействителен, если `f` обозначает метод.

Пример:

```go
package main

type T struct {
	x int
}

func (T) y() {
}

type P *T
type PP **T // a multi-level pointer type

func main() {
	var t T
	var p P = &t
	var pt = &t   // type of pt is *T
	var ppt = &pt // type of ppt is **T
	var pp PP = ppt
	_ = pp

	_ = (*p).x // legal
	_ = p.x    // also legal (for x is a field)

	_ = (*p).y // legal
	// _ = p.y // illegal (for y is a method)

	// Following ones are all illegal.
	/*
	_ = ppt.x
	_ = ppt.y
	_ = pp.x
	_ = pp.y
	*/
}

```

### Адресуемость контейнера и его элементов

Основное правило:

Если контейнер является адресуемым, то его элементы также являются адресуемыми.

Исключение:

Элементы карты всегда неадресуемые, даже если сама карта адресная.

Сахар:

Элементы слайса всегда адресуемы, даже если сам слайс не адресуемый.

Пример:

```go
package main

func main() {
	var m = map[string]int{"abc": 123}
	_ = &m // okay

	// The exception:
	// p = &m["abc"] // error: map elements are unaddressable

	// The sugar:
	f := func() []int { // return results are unaddressable
		return []int{0, 1, 2}
	}
	// _ = &f() // error: f() is unaddressable
	_ = &f()[2] // okay
}

```

### Изменить неадресуемые значения

Основное правило:

Неадресуемые значения не могут быть изменены. Другими словами, неадресуемые значения не должны появляться в назначениях в качестве целевых значений.

Исключение:

Хотя значения элементов карты не адресуются, они могут быть изменены и отображаться в назначениях как целевые значения. (Но элементы карты нельзя изменить частично, их можно только полностью перезаписать, то есть заменить.)

Пример:

```go
package main

func main() {
	type T struct {
		x int
	}

	var mt = map[string]T{"abc": {123}}
	// Map elements are unaddressable.
	// _ = &mt["abc"] // error
	// Partial modification is not allowed.
	// mt["abc"].x = 456 // error
	// It is ok to replace a map element as a whole.
	mt["abc"] = T{x: 789}
}

```

### Параметры функции

Основное правило:

Каждый параметр является значением некоторого типа.

Исключение:

Первыми параметрами встроенных функций `make` и `new` являются типы.

### Имена функций в одном пакете

Основное правило:

Имена объявленных функций не могут дублироваться в одном пакете.

Исключение:

Может быть несколько функций, объявленных с именами как `init` (и типами как `func()` ).

### Вызовы функций

Основное правило:

Функции, имена которых не являются пустым идентификатором, могут вызываться в пользовательском коде.

Исключение:

`init` функции не могут быть вызваны в пользовательском коде.

### Функции, используемые в качестве значений

Основное правило:

Объявленные функции могут использоваться как значения функций.

Исключение:

`init` функции не могут использоваться в качестве значений функций.

Пример:

```go
package main

import "fmt"
import "unsafe"

func init() {}

func main() {
	// These ones are okay.
	var _ = main
	var _ = fmt.Println

	// This one fails to compile.
	var _ = init
}

```

### Способы передачи аргумента типа

Основное правило:

В списке аргументов типа все аргументы типа заключены в квадратные скобки и разделены запятыми в списке.

Исключение:

Способы передачи списков аргументов типа во встроенные экземпляры универсального типа различаются в разных формах. Каждый аргумент типа ключа экземпляров типов карт отдельно заключен в квадратные скобки. Аргументы других типов не заключаются. Аргумент типа экземпляра встроенной `new` универсальной функции заключен в круглые скобки. Аргумент типа экземпляра встроенной `make` универсальной функции смешивается с аргументами значения, и эти аргументы типа и значения заключаются в круглые скобки.

### Отбросить возвращаемые значения вызовов функций

Основное правило:

Возвращаемые значения вызова функции можно вообще отбросить.

Исключение:

Возвращаемые значения вызовов встроенных функций, которые задокументированы в стандартных пакетах `builtin` и `unsafe` , не могут быть отброшены, если вызываемая функция имеет возвращаемые результаты.

Исключение в исключении:

Все возвращаемые значения вызова встроенных функций `copy` и `recover` функций могут быть отброшены, даже если обе функции возвращают результаты.

### Объявленные переменные

Основное правило:

Объявленные переменные всегда адресуемы.

Исключение:

Предварительно [объявленная `nil`](https://golang.org/pkg/builtin/#pkg-variables) переменная не адресуется.

Итак, `nil` неизменяемая переменная.

### Передача аргумента

Основное правило:

Аргумент может быть передан соответствующему параметру функции, только если аргумент может быть назначен соответствующему типу параметра функции.

Сахар:

Если первый аргумент среза вызова функции `copy` и `append` является байтовым срезом, то второй аргумент может быть строкой, тогда как строковое значение не может быть присвоено второму типу параметра (также байтовому срезу). (Для `append` вызова предположим, что второй аргумент передается в форме `arg...` .)

Пример:

```go
package main

func main() {
	var bs = []byte{1, 2, 3}
	var s = "xyz"

	copy(bs, s)
	// The above line is a sugar (and an optimization)
	// for the following line.
	copy(bs, []byte(s))

	bs = append(bs, s...)
	// The above line is a sugar (and an optimization)
	// for the following line.
	bs = append(bs, []byte(s)...)
}

```

### Сравнения

Основное правило:

Типы карт, срезов и функций не поддерживают сравнение.

Исключение:

Значения карты, среза и функции можно сравнивать с предварительно объявленным нетипизированным `nil` идентификатором.

Пример:

```go
package main

func main() {
	var s1 = []int{1, 2, 3}
	var s2 = []int{7, 8, 9}
	//_ = s1 == s2 // error: slice values can't be compared
	_ = s1 == nil // ok
	_ = s2 == nil // ok

	var m1 = map[string]int{}
	var m2 = m1
	// _ = m1 == m2 // error: map values can't be compared
	_ = m1 == nil
	_ = m2 == nil

	var f1 = func(){}
	var f2 = f1
	// _ = f1 == f2 // error: functions can't be compared
	_ = f1 == nil
	_ = f2 == nil
}

```

### Сравнения 2

Основное правило:

Если значение может быть неявно преобразовано в сопоставимый тип, то это значение можно сравнить со значениями сопоставимого типа.

Исключение:

Значения неинтерфейсного несравнимого типа нельзя сравнивать со значениями интерфейсного типа, даже если неинтерфейсный несравнимый тип реализует интерфейсный тип (поэтому значения неинтерфейсного несравнимого типа могут быть неявно преобразованы в интерфейсный тип). тип).

Пожалуйста, ознакомьтесь с [правилами сравнения](https://go101.org/article/value-conversions-assignments-and-comparisons.html#comparison-rules) для примеров.

### Пустые составные литералы

Основное правило:

Если значения типа `T` могут быть представлены составными литералами, то `T{}` это его нулевое значение.

Исключение:

Для карты или типа фрагмента `T` не `T{}` является нулевым значением. Его нулевое значение представлено с помощью `nil` .

Пример:

```go
package main

import "fmt"

func main() {
	// new(T) returns the address of a zero value of type T.

	type T0 struct {
		x int
	}
	fmt.Println( T0{} == *new(T0) ) // true
	type T1 [5]int
	fmt.Println( T1{} == *new(T1) ) // true

	type T2 []int
	fmt.Println( T2{} == nil ) // false
	type T3 map[int]int
	fmt.Println( T3{} == nil ) // false
}

```

### Итерации элемента контейнера

Основное правило:

Только значения контейнера могут быть ранжированы, итерированные значения являются элементами контейнера. Ключ/индекс элемента также будет возвращен вместе с каждым итерируемым элементом.

Исключение 1:

Повторяющиеся значения являются рунами, если диапазонные контейнеры являются строками, а не байтовыми элементами строк.

Исключение 2:

Индекс элемента (порядок) не будет возвращаться вместе с каждым итерируемым элементом при итерации каналов.

Сахар:

Указатели массива также могут быть ранжированы для повторения элементов массива, хотя указатели не являются контейнерами.

### Методы встроенных типов

Основное правило:

Как правило, встроенные типы не имеют методов.

Исключение:

У встроенного `error` типа есть `Error() string` метод.

### Типы значений

Основное правило:

Каждое значение имеет либо тип, либо тип по умолчанию.

Исключение:

Untyped `nil` не имеет ни типа, ни типа по умолчанию.

### Постоянные значения

Основное правило:

Постоянные значения никогда не меняются. Константы могут быть присвоены переменным.

Исключение:

Predeclared `iota` — это встроенная константа, связанная с `0` , но ее значение непостоянно. Его значение будет начинаться `0` и увеличиваться на одну спецификацию константы на спецификацию константы в объявлении константы, хотя приращения происходят во время компиляции.

Исключение 2:

`iota` может использоваться только в объявлениях констант. Его нельзя присвоить переменным в объявлениях переменных.

### Изменение поведения, вызванное отбрасыванием необязательных результатов вычисления выражений.

Основное правило:

Независимо от того, представлен ли необязательный результат вычисления выражения, это не повлияет на поведение программы.

Исключение:

Отсутствие необязательного значения результата в утверждении типа приведет к панике текущей горутины, если утверждение типа не удастся.

Пример:

```go
package main

func main() {
	var ok bool

	var m = map[int]int{}
	_, ok = m[123] // will not panic
	_ = m[123]     // will not panic

	var c = make(chan int, 2)
	c <- 123
	close(c)
	_, ok = <-c // will not panic
	_ = <-c     // will not panic

	var v interface{} = "abc"
	_, ok = v.(int) // will not panic
	_ = v.(int)     // will panic!
}

```

### `else` ключевое слово, за которым следует блок кода

Основное правило:

За `else` ключевым словом должен следовать явный блок кода `{...}` .

Сахар:

За `else` ключевым словом может следовать `if` блок кода (который является неявным).

Например, в следующем коде функция `foo` компилируется нормально, а функция `bar` нет.

```go
func f() []int {
	return nil
}

func foo() {
	if vs := f(); len(vs) == 0 {
	} else if len(vs) == 1 {
	}

	if vs := f(); len(vs) == 0 {
	} else {
		switch {
		case len(vs) == 1:
		default:
		}
	}

	if vs := f(); len(vs) == 0 {
	} else {
		for _, _ = range vs {
		}
	}
}

func bar() {
	if vs := f(); len(vs) == 0 {
	} else switch { // error
	case len(vs) == 1:
	default:
	}

	if vs := f(); len(vs) == 0 {
	} else for _, _ = range vs { // error
	}
}
```
