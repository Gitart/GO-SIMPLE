# ✨ Стеки в Go

**Стек** — это структура данных, которая похожа на стопку тарелок: когда вам понадобится новая тарелка, вы возьмете верхнюю.
Как и в случае с очередью, основным преимуществом стека является его простота, поскольку, чтобы работать со стеком, нужно реализовать всего две функции:
добавление в стек нового узла и удаление узла из стека.

### ⚒ Реализация стека в Go

Пришло время рассмотреть реализацию стека в Go. Мы покажем это на примере программы stack.go. 
Как и в случае с очередью, для реализации стека будет использоваться связный список. Как вы знаете, нам понадобятся две функции: одна, с именем Push(), 
для вставки в стек, и вторая, с именем Pop(), — для удаления из стека.

Хотя в этом нет необходимости, однако полезно хранить количество элементов в стеке в отдельной переменной, чтобы можно было определить, является ли стек
пустым, без необходимости обращаться к самому связному списку.

Мы рассмотрим исходный код stack.go, разделив его на четыре части. 
Перваячасть выглядит так:

```go
package main
import (
 "fmt"
)

type Node struct {
 Value int
 Next *Node
}
var size = 0
var stack = new(Node)

// Во второй части stack.go содержится реализация функции Push():
func Push(v int) bool {
 if stack == nil {
 stack = &Node{v, nil}
 size = 1
 return true
 }
 temp := &Node{v, nil}
 temp.Next = stack
 stack = temp
 size++
 return true
}

// Если стек не пустой, то функция создает новый узел (temp), который помещается перед текущим стеком. Затем новый узел становится головным узлом стека.
// Данная версия функции Push() всегда возвращает значение true, но если занимаемое стеком пространство ограниченно, то можно изменить код так, чтобы функция
// возвращала false при попытке превысить емкость стека.
// В третьей части содержится реализация функции Pop():

func Pop(t *Node) (int, bool) {
 if size == 0 {
 return 0, false
 }
 if size == 1 {
 size = 0
 stack = nil
 return t.Value, true
 }
 stack = stack.Next
 size--
 return t.Value, true
}

// Четвертый фрагмент кода stack.go выглядит так:

func traverse(t *Node) {
 if size == 0 {
   fmt.Println("Empty Stack!")
    return
 }
 
 for t != nil {
  fmt.Printf("%d -> ", t.Value)
  t = t.Next
 }
 
 fmt.Println()
}

// Поскольку стек реализован с использованием связного списка, для него можно
// реализовать функцию traverse().
// Последняя часть stack.go содержит следующий код Go:

func main() {
 stack = nil
 v, b := Pop(stack)
 if b {
 fmt.Print(v, " ")
 } else {
 fmt.Println("Pop() failed!")
 }
 Push(100)
 traverse(stack)
 Push(200)
 traverse(stack)
 for i := 0; i < 10; i++ {
 Push(i)
 }
 for i := 0; i < 15; i++ {
 v, b := Pop(stack)
 if b {
 fmt.Print(v, " ")
 } else {
 break
 }
 }
 fmt.Println()
 traverse(stack)
}
```

Как видно, исходный код stack.go немного короче, чем код Go для queue.go, —
прежде всего потому, что принцип стека проще, чем у очереди.

Выполнение stack.go приведет к следующим результатам:

```
$ go run stack.go
Pop() failed!
100 ->
200 -> 100 ->
9 8 7 6 5 4 3 2 1 0 200 100
Empty Stack!
```

