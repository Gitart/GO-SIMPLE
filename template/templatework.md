# Использование функций внутри шаблонов Go

В этом уроке мы будем рассмотрим , как использовать [шаблон функции](https://golang.org/pkg/text/template/#hdr-Functions) , как `and` , `eq` и `index` добавить некоторую базовую логику наших шаблонов. Как только у нас будет достаточно хорошее понимание того, как использовать эти функции, мы рассмотрим, как добавить некоторые пользовательские функции в наши шаблоны и использовать их.

Эта статья является частью серии

Это третья часть серии из четырех статей, в которой представлены пакеты `html/template` (и `text/template` ) в Go. Если вы еще этого не сделали, я предлагаю вам ознакомиться с остальной частью серии здесь: [Введение в шаблоны в Go](https://www.calhoun.io/intro-to-templates/) . Они не требуют чтения, но я думаю, они вам понравятся.

*Если вам нравится эта серия, рассмотрите возможность [подписки на мой список рассылки,](#subscribe) чтобы получать уведомления, когда я выпускаю новые статьи, подобные этой. Обещаю, я не спам.*

## `and` функция

По умолчанию `if` действие в шаблонах оценивает, является ли аргумент пустым, но что происходит, когда вы хотите оценить несколько аргументов? Вы могли бы написать вложенные `if/else` блоки, но это было бы ужасно быстро.

Вместо этого `html/template` пакет предоставляет `and` функцию. Его использование аналогично тому, как вы используете `and` функцию в Лиспе (другом языке программирования). Это легче показать, чем объяснить, поэтому давайте просто перейдем к некоторому коду. Откройте `main.go` и добавьте следующее:

```go
package main

import (
  "html/template"
  "net/http"
)

var testTemplate *template.Template

type User struct {
  Admin bool
}

type ViewData struct {
  *User
}

func main() {
  var err error
  testTemplate, err = template.ParseFiles("hello.gohtml")
  if err != nil {
    panic(err)
  }

  http.HandleFunc("/", handler)
  http.ListenAndServe(":3000", nil)
}

func handler(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "text/html")

  vd := ViewData{&User{true}}
  err := testTemplate.Execute(w, vd)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
}

```

Затем откройте `hello.gohtml` и добавьте следующее в ваш шаблон.

```html
{{if and .User .User.Admin}}
  You are an admin user!
{{else}}
  Access denied!
{{end}}

```

Если вы запустите этот код, вы должны увидеть результат `You are an admin user!` . Если вы обновляете `main.go` либо не включать `*User` объект или набор Администрирование к ложным, или даже если вы предоставите `nil` к `testTemplate.Execute()` методу вы вместо того, чтобы видеть `Access denied!` .

`and` Функция принимает два аргумента, позволяет называть их `a` и `b` , а затем запускает логику примерно эквивалентную `if a then b else a` . Самое странное, что `and` это действительно функция, а не то, что вы помещаете между двумя переменными. Просто помните, что это функция, а не логическая операция, и все должно быть в порядке.

Аналогично, пакет шаблона также предоставляет `or` функцию, которая работает почти так же, `and` за исключением того, что она будет иметь короткое замыкание, когда это правда. IE логика для `or a b` примерно эквивалентна, `if a then a else b` поэтому `b` никогда не будет оцениваться, если `a` не пусто.

## Функции сравнения (равно, меньше и т. Д.)

До сих пор мы имели дело с относительно простой логикой, вращающейся вокруг того, является ли что\-то пустым или нет, но что происходит, когда нам нужно сделать некоторые сравнения? Например, что если мы хотим настроить класс на объекте в зависимости от того, приближается ли пользователь к превышению своего предела использования?

`html/template` Пакет предоставляет нам несколько классов для сравнения помогают делать. Эти

*   `eq` \- возвращает логическую правду `arg1 == arg2`
*   `ne` \- возвращает логическую правду `arg1 != arg2`
*   `lt` \- возвращает логическую правду `arg1 < arg2`
*   `le` \- возвращает логическую правду `arg1 <= arg2`
*   `gt` \- возвращает логическую правду `arg1 > arg2`
*   `ge` \- возвращает логическую правду `arg1 >= arg2`

Они используются аналогично тому, как `and` и `or` когда вы сначала вводите функцию, а затем вводите аргументы. Например, вы можете использовать следующий код в своем шаблоне, чтобы определить, какой текст будет отображаться в связи с их использованием API.

```html
{{if (ge .Usage .Limit)}}
  <p class="danger">
    You have reached your API usage limit. Please upgrade or contact support for more help.
  </p>
{{else if (gt .Usage .Warning)}}
  <p class="warning">
    You have used {{.Usage}} of {{.Limit}} API calls and are nearing your limit. Have you considered upgrading?
  </p>
{{else if (eq .Usage 0)}}
  <p>
    You haven't used the API yet! What are you waiting for?
  </p>
{{else}}
  <p>
    You have used {{.Usage}} of {{.Limit}} API calls.
  </p>
{{end}}

```

если ... еще если ... еще

Если вы следили за серией, также стоит отметить, что этот код также демонстрирует, как создать `if...elseif...else` блок, который мы еще не рассмотрели. Они работают так же, как и `if...else` блоки, но позволяют вам иметь несколько различных условных предложений.

## Использование функциональных переменных

До сих пор мы в основном имели дело со структурами данных внутри наших шаблонов, но что произойдет, если мы захотим вызывать наши собственные функции из шаблона? Например, давайте представим, что у нас есть `User` тип, и нам нужно выяснить, есть ли у текущего пользователя разрешение на доступ к нашей корпоративной функции при создании пользовательского интерфейса. Мы могли бы создать структуру клиента для представления и добавить поле для разрешения.

```go
type ViewData struct {
  Permissions map[string]bool
}

// or

type ViewData struct {
  Permissions struct {
    FeatureA bool
    FeatureB bool
  }
}

```

Проблема с этим подходом состоит в том, что нам всегда нужно знать каждую функцию, которая используется в текущем представлении, или, если мы вместо этого использовали a, `map[string]bool` нам нужно было бы заполнить его значением для каждой возможной функции. Было бы намного проще, если бы мы могли просто вызывать функцию, когда хотели узнать, есть ли у пользователя доступ к этой функции. Есть несколько способов сделать это в Go, поэтому я расскажу о нескольких возможных способах сделать это.

### 1\. Создайте метод по `User`типу

Первый \- самый простой \- допустим, у нас есть `User` тип, который мы уже предоставили представлению, мы можем просто добавить `HasPermission()` метод к объекту и затем использовать его. Чтобы увидеть это в действии, добавьте следующее к `hello.gohtml` .

```html
{{if .User.HasPermission "feature-a"}}
  <div class="feature">
    <h3>Feature A</h3>
    <p>Some other stuff here...</p>
  </div>
{{else}}
  <div class="feature disabled">
    <h3>Feature A</h3>
    <p>To enable Feature A please upgrade your plan</p>
  </div>
{{end}}

{{if .User.HasPermission "feature-b"}}
  <div class="feature">
    <h3>Feature B</h3>
    <p>Some other stuff here...</p>
  </div>
{{else}}
  <div class="feature disabled">
    <h3>Feature B</h3>
    <p>To enable Feature B please upgrade your plan</p>
  </div>
{{end}}

<style>
  .feature {
    border: 1px solid #eee;
    padding: 10px;
    margin: 5px;
    width: 45%;
    display: inline-block;
  }
  .disabled {
    color: #ccc;
  }
</style>

```

А затем добавьте следующее `main.go` в тот же каталог.

```go
package main

import (
  "html/template"
  "net/http"
)

var testTemplate *template.Template

type ViewData struct {
  User User
}

type User struct {
  ID    int
  Email string
}

func (u User) HasPermission(feature string) bool {
  if feature == "feature-a" {
    return true
  } else {
    return false
  }
}

func main() {
  var err error
  testTemplate, err = template.ParseFiles("hello.gohtml")
  if err != nil {
    panic(err)
  }

  http.HandleFunc("/", handler)
  http.ListenAndServe(":3000", nil)
}

func handler(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "text/html")

  vd := ViewData{
    User: User{1, "jon@calhoun.io"},
  }
  err := testTemplate.Execute(w, vd)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
}

```

После запуска вашего кода вы должны увидеть что\-то вроде этого в вашем браузере:

![](https://www.calhoun.io/content/images/2016/08/Screenshot-2016-08-29-10-00-51.png)

Мы успешно включаем и отключаем функции на внешнем интерфейсе в зависимости от того, есть ли у пользователя доступ к ним! Когда мы объявляем функции для типов, мы можем вызывать их так же, как мы обращаемся к данным внутри структуры, так что все это должно показаться вам довольно знакомым.

Теперь, когда мы увидели, как вызывать методы, давайте проверим более динамичный способ вызова функций внутри шаблона с использованием `call` функции.

### 2\. Вызов функциональных переменных и полей

Давайте представим, что по какой\-то причине вы не можете использовать описанный выше подход, потому что ваш метод определения логики должен время от времени меняться. В этом случае имеет смысл создать `HasPermission func(string) bool` атрибут для `User` типа, а затем назначить его с помощью функции. Откройте `main.go` и измените свой код, чтобы отразить следующее.

```go
package main

import (
  "html/template"
  "net/http"
)

var testTemplate *template.Template

type ViewData struct {
  User User
}

type User struct {
  ID            int
  Email         string
  HasPermission func(string) bool
}

func main() {
  var err error
  testTemplate, err = template.ParseFiles("hello.gohtml")
  if err != nil {
    panic(err)
  }

  http.HandleFunc("/", handler)
  http.ListenAndServe(":3000", nil)
}

func handler(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "text/html")

  vd := ViewData{
    User: User{
      ID:    1,
      Email: "jon@calhoun.io",
      HasPermission: func(feature string) bool {
        if feature == "feature-b" {
          return true
        }
        return false
      },
    },
  }
  err := testTemplate.Execute(w, vd)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
}

```

Все выглядит хорошо, но если вы запустите [localhost: 3000](http://localhost:3000/) в своем браузере после запуска сервера, вы заметите, что мы получаем ошибку вроде

шаблон :  привет . gohtml : 1 : 10 :  выполнение  «hello.gohtml»  в  <. Пользователь . HasPermission \>:  HasPermission  имеет  аргументы,  но  не может  быть  вызван  как  функция

Когда мы назначаем функции переменным, нам нужно сообщить `html/template` пакету, что мы хотим вызвать функцию. Откройте свой `hello.gohtml` файл и добавьте слово `call` сразу после ваших `if` утверждений, вот так.

```html
{{if (call .User.HasPermission "feature-a")}}

...

{{if (call .User.HasPermission "feature-b")}}

...

```

Скобки можно использовать в шаблонах

Хотя в шаблонах Go обычно не требуется паретизирование, они могут быть невероятно полезны для разъяснения того, какие аргументы необходимо передать в какие функции, и для определения четкого порядка операций. Имейте их в виду, как вы используете шаблоны!

Продолжайте, перезагрузите сервер и снова проверьте localhost. Вы должны увидеть ту же страницу, что и раньше, но на этот раз функция B включена вместо функции A.

`call` это функция, уже предоставленная `html/template` пакетом, который вызывает первый данный ей аргумент ( `.User.HasPermission` в нашем случае это функция), используя остальные аргументы в качестве аргументов вызова функции.

### 3\. Создание пользовательских функций с`template.FuncMap`

Последний способ вызова наших собственных функций, который я собираюсь рассмотреть, \- это создание пользовательских функций с помощью `template.FuncMap` . На мой взгляд, это наиболее полезный и мощный способ определения функций, поскольку он позволяет нам создавать глобальные вспомогательные методы, которые можно использовать в нашем приложении.

Чтобы начать, сначала [перейдите к документации для `template.FuncMap`](https://golang.org/pkg/text/template/#FuncMap) . Первое, на что нужно обратить внимание, это то, что этот тип выглядит просто как a `map[string]interface{}` , но ниже есть примечание, что каждый интерфейс должен быть функцией с одним возвращаемым значением или функцией с двумя возвращаемыми значениями, где первым являются данные, которые вам нужны доступ в шаблоне, а вторая \- ошибка, которая прервет выполнение шаблона, если он не равен нулю.

Поначалу это может сбить с толку, поэтому давайте просто перейдем к примеру. Откройте `main.go` снова и обновите его, чтобы он соответствовал приведенному ниже коду.

```go
package main

import (
  "html/template"
  "net/http"
)

var testTemplate *template.Template

type ViewData struct {
  User User
}

type User struct {
  ID    int
  Email string
}

func main() {
  var err error
  testTemplate, err = template.New("hello.gohtml").Funcs(template.FuncMap{
    "hasPermission": func(user User, feature string) bool {
      if user.ID == 1 && feature == "feature-a" {
        return true
      }
      return false
    },
  }).ParseFiles("hello.gohtml")
  if err != nil {
    panic(err)
  }

  http.HandleFunc("/", handler)
  http.ListenAndServe(":3000", nil)
}

func handler(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "text/html")

  user := User{
    ID:    1,
    Email: "jon@calhoun.io",
  }
  vd := ViewData{user}
  err := testTemplate.Execute(w, vd)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
}

```

И еще раз откройте `hello.gohtml` и обновите каждый оператор if, чтобы использовать новую функцию следующим образом.

```html
{{if hasPermission .User "feature-a"}}

...

{{if hasPermission .User "feature-b"}}

...

```

`hasPermission` Функция должна теперь быть питание вашей логики , которая определяет , если включена функция или нет. В `main.go` мы определили a, `template.FuncMap` который сопоставил имя метода ( `"hasPermission"` ) с функцией, которая принимает два аргумента (a `User` и строку функции), а затем возвращает true или false. Затем мы вызвали `template.New()` функцию для создания нового шаблона, назвали `Funcs()` метод для этого нового шаблона, чтобы определить наши пользовательские функции, и затем, наконец, мы проанализировали наш `hello.gohtml` файл как источник для нашего шаблона.

Определите функции перед разбором шаблонов

В предыдущих примерах мы создавали наш шаблон, вызывая `template.ParseFiles` функцию, предоставляемую `html/template` пакетом. Это функция уровня пакета, которая возвращает шаблон после анализа файлов. Теперь мы вызываем [метод ParseFiles](https://golang.org/pkg/html/template/#Template.ParseFiles) для `template.Template` типа, который имеет те же возвращаемые значения, но применяет изменения к существующему шаблону (а не к новому), а затем возвращает результат.

В этой ситуации нам нужно использовать метод, потому что нам нужно сначала определить любые пользовательские функции, которые мы планируем использовать в наших шаблонах, и как только мы сделаем это с пакетом шаблонов, он вернет a `*template.Template` . После определения этих пользовательских функций мы можем приступить к анализу шаблонов, которые используют функции. Если бы мы сначала проанализировали шаблоны, вы бы увидели ошибку, связанную с неопределенной функцией, вызываемой в вашем шаблоне.

Далее мы рассмотрим, как заставить эту функцию работать без необходимости передавать `User` объект каждый раз, когда мы его вызываем.

## Делая наши функции полезными во всем мире

`hasPermission` Функции мы определили в предыдущем разделе , является большим, но одна проблема с ним в том , что мы можем использовать его только тогда , когда мы имеем доступ к `User` объекту , а также. На первый взгляд, это не так уж плохо, но по мере роста приложения у него будет много шаблонов, и довольно легко забыть передать `User` объект в шаблон или пропустить его во вложенном шаблоне.

Наша функция была бы намного проще, если бы мы могли ее упростить, и нам нужно было только передать имя функции, поэтому давайте продолжим и обновим наш код, чтобы это произошло.

Первое, что нам нужно сделать, это создать функцию, когда нет `User` . Мы установим это в `template.FuncMap` перед разбором нашего шаблона, чтобы у нас не возникало ошибок разбора и чтобы была определенная логика на случай, если пользователь недоступен.

Откройте `main.go` и обновите `main()` функцию в соответствии с кодом ниже.

```go
func main() {
  var err error
  testTemplate, err = template.New("hello.gohtml").Funcs(template.FuncMap{
    "hasPermission": func(feature string) bool {
      return false
    },
  }).ParseFiles("hello.gohtml")
  if err != nil {
    panic(err)
  }

  http.HandleFunc("/", handler)
  http.ListenAndServe(":3000", nil)
}

```

Далее нам нужно определить нашу функцию, которая использует [замыкание](https://en.wikipedia.org/wiki/Closure_(computer_programming)) . Это в основном причудливый способ сказать, что мы собираемся определить динамическую функцию, которая имеет доступ к переменным, которые не обязательно передаются в нее, но доступны, когда мы определяем функцию. В нашем случае эта переменная будет `User` объектом. Обновите `handler()` функцию внутри `main.go` со следующим кодом.

```go
func handler(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "text/html")

  user := User{
    ID:    1,
    Email: "jon@calhoun.io",
  }
  vd := ViewData{user}
  // We need to clone the template before setting a user-specific
  // FuncMap to avoid any potential race conditions.
  err := template.Must(testTemplate.Clone()).Funcs(template.FuncMap{
    "hasPermission": func(feature string) bool {
      if user.ID == 1 && feature == "feature-a" {
        return true
      }
      return false
    },
  }).Execute(w, vd)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
}

```

Потенциальное состояние гонки!

Здесь следует отметить, что если вы не клонируете шаблон **перед** вызовом `Funcs` , вы потенциально можете столкнуться с состоянием гонки, когда все веб\-запросы пытаются установить разные FuncMaps для шаблона. Конечным результатом может быть то, что пользователь получает доступ к тому, к чему у него не должно быть доступа. Это возможно по двум причинам:

1.  По умолчанию веб\-запросы обрабатываются в подпрограммах, поэтому ваш сервер будет автоматически обрабатывать несколько запросов одновременно.
2.  Мы добавляем `FuncMap` с закрытием, которое использует `user` переменную. В предыдущих примерах мы передавали пользователя в функцию, поэтому это условие гонки было невозможно.

Это довольно легко исправить с помощью a `Clone` , но, возможно, стоит отметить, что в вашем коде не удаляется вызов `Clone` .

Хотите увидеть больше примеров закрытия?

Если вам интересно узнать немного больше о замыканиях, включая несколько примеров их в действии, я предлагаю ознакомиться с соответствующей статьей (нажмите кнопку ниже). В этой статье я объясняю, что такое анонимные функции и замыкания, даю примеры, и даже есть статья с последующим распространением использования замыканий в Go.

[

Связанная статья Что такое закрытие?

](https://www.calhoun.io/what-is-a-closure/)

Несмотря на то, что мы определили `hasPermission` функцию в нашей `main()` функции, мы перезаписываем ее внутри нашего обработчика, когда имеем доступ к `User` объекту, но перед тем, как выполнить шаблон. Это действительно мощно, потому что теперь мы можем использовать `hasPermission` функцию в любом шаблоне, не беспокоясь о том, `User` был ли объект передан в шаблон или нет.

## HTML безопасные строки и комментарии HTML

В [«Вступлении к шаблонам в Go \- контекстное кодирование»](https://www.calhoun.io/intro-to-templates-p1-contextual-encoding/) я упоминал, что если вам нужно предотвратить удаление определенных комментариев HTML из шаблонов, это возможно, но в то время мы не рассматривали, как это сделать. В этом разделе мы расскажем не только о том, как это сделать, но и о том, как заставить любую строку пропустить процесс кодирования по умолчанию, который происходит при выполнении `html/template` .

Чтобы освежить вашу память, представьте, что у вас есть HTML\-код в вашем макете, который нуждается в комментариях для совместимости с IE.

```html
<!--[if IE]>
<meta http-equiv="Content-Type" content="text/html; charset=Unicode">
<![endif]-->

```

К сожалению, `html/template` пакет удалит эти комментарии по умолчанию, поэтому нам нужно найти способ сделать комментарии безопасными для HTML. В частности, нам нужно создать функцию, которая предоставляет нам `template.HTML` объект с содержимым, `<!--[if IE]>` а другую \- для содержимого `<![endif]-->` .

Откройте `main.go` и замените его содержимое следующим.

```go
package main

import (
  "html/template"
  "net/http"
)

var testTemplate *template.Template

func main() {
  var err error
  testTemplate, err = template.New("hello.gohtml").Funcs(template.FuncMap{
    "ifIE": func() template.HTML {
      return template.HTML("<!--[if IE]>")
    },
    "endif": func() template.HTML {
      return template.HTML("<![endif]-->")
    },
  }).ParseFiles("hello.gohtml")
  if err != nil {
    panic(err)
  }

  http.HandleFunc("/", handler)
  http.ListenAndServe(":3000", nil)
}

func handler(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "text/html")

  err := testTemplate.Execute(w, nil)
  if err != nil {
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
}

```

В основной функции мы реализуем функции, которые я описал ранее, и называем затем `ifIE` и `endif` . Это позволяет нам обновлять наш шаблон ( `hello.gohtml` ) следующим образом.

```html
{{ifIE}}
<meta http-equiv="Content-Type" content="text/html; charset=Unicode">
{{endif}}

```

И затем, если вы перезапустите сервер, перезагрузите страницу, а затем просмотрите исходный код страницы, вы должны увидеть в нем следующее:

```html
<!--[if IE]>
<meta http-equiv="Content-Type" content="text/html; charset=Unicode">
<![endif]-->

```

Это прекрасно работает, но создание функции для каждого отдельного комментария, который мы можем захотеть использовать в нашем приложении, очень быстро утомляет. Для действительно распространенных комментариев (например, `endif` выше) создание собственной функции имеет смысл, но нам нужен способ передать любой комментарий HTML и убедиться, что он не закодирован. Для этого нам нужно определить функцию, которая принимает строку и преобразует ее в `template.HTML` . Откройте `main.go` снова и обновите, `template.FuncMap` чтобы соответствовать приведенному ниже.

```go
func main() {
  // ...
  testTemplate, err = template.New("hello.gohtml").Funcs(template.FuncMap{
    "ifIE": func() template.HTML {
      return template.HTML("<!--[if IE]>")
    },
    "endif": func() template.HTML {
      return template.HTML("<![endif]-->")
    },
    "htmlSafe": func(html string) template.HTML {
      return template.HTML(html)
    },
  }).ParseFiles("hello.gohtml")
  //...
}

```

С нашей новой `htmlSafe` функцией мы можем добавлять пользовательские комментарии по мере необходимости, например, оператор if для IE6.

```html
{{htmlSafe "<!--[if IE 6]>"}}
<meta http-equiv="Content-Type" content="text/html; charset=Unicode">
{{htmlSafe "<![endif]-->"}}

```

Последняя строка в этом примере также может быть, `{{endif}}` поскольку у нас все еще определена эта функция, но я решил использовать ее `htmlSafe` для согласованности.

Наша `htmlSafe` функция может даже использоваться в сочетании с другими методами (например `{{htmlSafe .User.Widget}}` ), если мы хотим, но, вообще говоря, если вы хотите, чтобы эти методы возвращали безопасные строки HTML, вам, вероятно, следует обновить их тип возврата, `template.HTML` чтобы ваши намерения были прояснены на будущее Разработчики.

## Подводя итоги

После ознакомления со всеми примерами вы должны четко понимать, как использовать функции в шаблонах, а также как определять свои собственные функции и делать их доступными внутри ваших шаблонов.

В заключительной статье этой серии \- [Создание V в MVC](https://www.calhoun.io/intro-to-templates-p4-v-in-mvc/) \- я расскажу, как объединить все, что мы узнали до сих пор в этой серии, для создания многоразового слоя представления для веб\-приложения. Мы даже начнем делать наши страницы красивее с помощью [Bootstrap](http://getbootstrap.com/) , популярной платформы HTML, CSS и JS, чтобы показать, как это никак не влияет на остальную часть сложности нашего кода; вместо этого вся логика представления изолирована от нашего вновь созданного типа представления.
