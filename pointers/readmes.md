# Указатели в Go

Хотя Go поглощает многие функции из всех видов других языков, Go в основном рассматривается как язык семейства C. Одним из доказательств является то, что Go также поддерживает указатели. Указатели Go и указатели C очень похожи во многих аспектах, но между указателями Go и C есть некоторые различия. В этой статье будут перечислены все виды концепций и деталей, связанных с указателями в Go.

### Адреса памяти

Адрес памяти означает определенную ячейку памяти в программировании.

Как правило, адрес памяти хранится в виде собственного (целого) слова без знака. Размер собственного слова составляет 4 (байта) для 32-битных архитектур и 8 (байтов) для 64-битных архитектур. Таким образом, теоретический максимальный размер пространства памяти составляет 2 32 байта, или 4 ГБ (1 ГБ == 2 30 байт), на 32-разрядных архитектурах и 2 64 байта, или 16 EB (1 EB == 1024 ПБ, 1 ПБ == 1024 ТБ, 1 ТБ == 1024 ГБ) на 64-битных архитектурах.

Адреса памяти часто представляются шестнадцатеричными целочисленными литералами, такими как `0x1234CDEF` .

### Адреса значений

Под адресом значения понимается начальный адрес сегмента памяти, занимаемого [прямой частью](https://go101.org/article/value-part.html) значения.

### Что такое указатели?

Указатель — это один из типов в Go. Значение указателя используется для хранения адреса памяти, который обычно является адресом другого значения.

В отличие от языка C, из соображений безопасности для указателей Go наложены некоторые ограничения. Подробности см. в следующих разделах.

### Типы и значения указателя Go

В Go безымянный тип указателя может быть представлен с помощью `*T` , где `T` может быть произвольным типом. Тип `T` называется базовым типом указателя `*T` .

Мы можем объявлять именованные типы указателей, но, как правило, не рекомендуется использовать именованные типы указателей, так как безымянные типы указателей имеют лучшую читабельность.

Если [базовым типом](https://go101.org/article/type-system-overview.html#underlying-type) именованного типа указателя является `*T` , то базовым типом именованного типа указателя является `T` .

Два безымянных типа указателя с одним и тем же базовым типом являются одним и тем же типом.

Пример:

```go
*int  // An unnamed pointer type whose base type is int.
**int // An unnamed pointer type whose base type is *int.

// Ptr is a named pointer type whose base type is int.
type Ptr *int
// PP is a named pointer type whose base type is Ptr.
type PP *Ptr

```

Нулевые значения любых типов указателей представлены предварительно объявленным `nil` . Никакие адреса не сохраняются в нулевых значениях указателя.

Значение типа указателя с базовым типом `T` может хранить только адреса значений типа `T` .

### О слове «справка»

В Go 101 слово «ссылка» указывает на отношение. Например, если значение указателя хранит адрес другого значения, то мы можем сказать, что значение указателя (непосредственно) ссылается на другое значение, а другое значение имеет хотя бы одну ссылку. Использование слова «ссылка» в Go 101 соответствует спецификации Go.

Когда значение указателя ссылается на другое значение, мы также часто говорим, что значение указателя указывает на другое значение.

### Как получить значение указателя и что такое адресуемые значения?

Есть два способа получить ненулевое значение указателя.

1.  Встроенная `new` функция может использоваться для выделения памяти для значения любого типа. `new(T)` выделит память для `T` значения (анонимной переменной) и вернет адрес `T` значения. Выделенное значение является нулевым значением типа `T` . Возвращенный адрес рассматривается как значение указателя типа `*T` .
2.  Мы также можем взять адреса значений, к которым можно обращаться в Go. Для адресуемого значения `t` типа `T` мы можем использовать выражение `&t` для получения адреса `t` , где `&` оператор для получения адресов значений. Тип `&t` рассматривается как `*T` .

Вообще говоря, адресуемое значение означает значение, которое размещено где-то в памяти. В настоящее время нам просто нужно знать, что все переменные являются адресуемыми, тогда как константы, вызовы функций и явные результаты преобразования не адресуются. Когда переменная объявляется, среда выполнения Go выделяет часть памяти для этой переменной. Начальный адрес этого фрагмента памяти является адресом переменной.

Мы узнаем другие адресуемые и неадресуемые значения из других статей позже. Если вы уже знакомы с Go, вы можете прочитать [этот обзор](https://go101.org/article/summaries.html#not-addressable) , чтобы получить списки адресуемых и неадресуемых значений в Go.

В следующем разделе будет показан пример получения значений указателя.

### Разыменование указателя

Учитывая значение `p` указателя типа указателя, базовый тип которого равен `T` , как вы можете получить значение по адресу, хранящемуся в указателе (то есть значение, на которое ссылается указатель)? Просто используйте выражение `*p` , где `*` называется оператором разыменования. `*p` называется разыменованием указателя `p` . Разыменование указателя — это процесс, обратный взятию адреса. Результатом `*p` является значение типа `T` (базовый тип типа `p` ).

Разыменование нулевого указателя вызывает панику во время выполнения.

В следующей программе показаны некоторые примеры получения адреса и разыменования указателя:

```go
package main

import "fmt"

func main() {
	p0 := new(int)   // p0 points to a zero int value.
	fmt.Println(p0)  // (a hex address string)
	fmt.Println(*p0) // 0

	// x is a copy of the value at
	// the address stored in p0.
	x := *p0
	// Both take the address of x.
	// x, *p1 and *p2 represent the same value.
	p1, p2 := &x, &x
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
	p3 := &*p0 // <=> p3 := &(*p0) <=> p3 := p0
	// Now, p3 and p0 store the same address.
	fmt.Println(p0 == p3) // true
	*p0, *p1 = 123, 789
	fmt.Println(*p2, x, *p3) // 789 789 123

	fmt.Printf("%T, %T \n", *p0, x) // int, int
	fmt.Printf("%T, %T \n", p0, p1) // *int, *int
}

```

На следующем рисунке показаны отношения значений, используемых в приведенной выше программе.

![значение указателя](https://go101.org/article/res/pointer.png)

### Зачем нам нужны указатели?

Сначала рассмотрим пример.

```go
package main

import "fmt"

func double(x int) {
	x += x
}

func main() {
	var a = 3
	double(a)
	fmt.Println(a) // 3
}

```

Ожидается `double` , что функция в приведенном выше примере изменит входной аргумент, удвоив его. Однако это не удается. Почему? Потому что все присвоения значений, включая передачу аргументов функции, в Go являются копированием значений. Измененная `double` функция является копией ( `x` ) переменной , `a` но не переменной `a` .

Одно из решений исправить вышеуказанную `double` функцию — позволить ей возвращать результат модификации. Это решение не всегда работает для всех сценариев. В следующем примере показано другое решение с использованием параметра указателя.

```go
package main

import "fmt"

func double(x *int) {
	*x += *x
	x = nil // the line is just for explanation purpose
}

func main() {
	var a = 3
	double(&a)
	fmt.Println(a) // 6
	p := &a
	double(p)
	fmt.Println(a, p == nil) // 12 false
}

```

Мы можем обнаружить, что, изменив параметр на тип указателя, переданный аргумент указателя `&a` и его копия `x` , используемая в теле функции, ссылаются на одно и то же значение, поэтому модификация on `*x` эквивалентна модификации на `*p` , также известной как variable `a` . Другими словами, изменение в `double` теле функции теперь может быть отражено вне функции.

Конечно, модификация самой копии переданного аргумента-указателя все равно не может быть отражена в переданном аргументе-указателе. После второго `double` вызова функции локальный указатель `p` не изменяется на `nil` .

Короче говоря, указатели предоставляют косвенные способы доступа к некоторым значениям. Многие языки не имеют концепции указателей. Однако указатели просто скрыты под другими понятиями в этих языках.

### Возвращать указатели локальных переменных безопасно в Go

В отличие от языка C, Go — это язык, поддерживающий сборку мусора, поэтому возврат адреса локальной переменной в Go абсолютно безопасен.

```go
func newInt() *int {
	a := 3
	return &a
}

```

### Ограничения на указатели в Go

Из соображений безопасности Go накладывает некоторые ограничения на указатели (по сравнению с указателями в языке C). Применяя эти ограничения, Go сохраняет преимущества указателей и в то же время избегает опасности указателей.

#### Значения указателя Go не поддерживают арифметические операции

В Go указатели не могут выполнять арифметические операции. Для указателя `p` и `p++` оба `p-2` являются незаконными.

Если `p` это указатель на числовое значение, компиляторы рассмотрят `*p++` это допустимое утверждение и обработают его как `(*p)++` . Другими словами, приоритет оператора разыменования указателя `*` выше, чем у оператора инкремента `++` и оператора декремента `--` .

Пример:

```go
package main

import "fmt"

func main() {
	a := int64(5)
	p := &a

	// The following two lines don't compile.
	/*
	p++
	p = (&a) + 8
	*/

	*p++
	fmt.Println(*p, a)   // 6 6
	fmt.Println(p == &a) // true

	*&a++
	*&*&a++
	**&p++
	*&*p++
	fmt.Println(*p, a) // 10 10
}

```

#### Значение указателя не может быть преобразовано в произвольный тип указателя

В Go значение указателя типа указателя `T1` может быть напрямую и явно преобразовано в другой тип указателя, `T2` только если выполняется любое из следующих двух условий.

1.  Базовые типы типа `T1` и `T2` идентичны (игнорируя теги структуры), в частности, если один из типов `T1` и `T2` является [безымянным](https://go101.org/article/type-system-overview.html#named-type) типом, а их базовые типы идентичны (с учетом тегов структуры), то преобразование может быть неявным. Типы и значения структур будут объяснены в [следующей статье](https://go101.org/article/struct.html) .
2.  Type `T1` и `T2` являются безымянными типами указателей, и базовые типы их базовых типов идентичны (игнорируя теги структуры).

Например, для показанных ниже типов указателей:

```go
type MyInt int64
type Ta    *int64
type Tb    *MyInt

```

существуют следующие факты:

1.  значения типа `*int64` могут быть неявно преобразованы в тип `Ta` и наоборот, поскольку их базовые типы оба являются `*int64` .
2.  значения типа `*MyInt` могут быть неявно преобразованы в тип `Tb` и наоборот, поскольку их базовые типы оба являются `*MyInt` .
3.  значения типа `*MyInt` могут быть явно преобразованы в тип `*int64` и наоборот, поскольку они оба безымянны, а базовые типы их базовых типов оба являются типами `int64` .
4.  значения type `Ta` не могут быть напрямую преобразованы в type `Tb` , даже если явно. Однако, согласно только что перечисленным первым трем фактам, значение `pa` типа `Ta` может быть косвенно преобразовано в тип `Tb` путем вложения трех явных преобразований, `Tb((*MyInt)((*int64)(pa)))` .

Никакие значения этих типов указателей не могут быть преобразованы в тип `*uint64` любым безопасным способом.

#### Значение указателя нельзя сравнивать со значениями произвольного типа указателя.

В Go указатели можно сравнить с операторами `==` и . `!=` Два значения указателя Go можно сравнивать только в том случае, если выполняется любое из следующих трех условий.

1.  Типы двух указателей Go идентичны.
2.  Одно значение указателя может быть неявно преобразовано в тип указателя другого. Другими словами, базовые типы двух типов должны быть идентичными, и любой из двух типов двух указателей Go является безымянным типом.
3.  Один и только один из двух указателей представлен голым (нетипизированным) `nil` идентификатором.

Пример:

```go
package main

func main() {
	type MyInt int64
	type Ta    *int64
	type Tb    *MyInt

	// 4 nil pointers of different types.
	var pa0 Ta
	var pa1 *int64
	var pb0 Tb
	var pb1 *MyInt

	// The following 6 lines all compile okay.
	// The comparison results are all true.
	_ = pa0 == pa1
	_ = pb0 == pb1
	_ = pa0 == nil
	_ = pa1 == nil
	_ = pb0 == nil
	_ = pb1 == nil

	// None of the following 3 lines compile ok.
	/*
	_ = pa0 == pb0
	_ = pa1 == pb1
	_ = pa0 == Tb(nil)
	*/
}

```

#### Значение указателя не может быть присвоено значениям указателя других типов указателя.

Условия для присвоения значения указателя другому значению указателя аналогичны условиям для сравнения значения указателя с другим значением указателя, которые перечислены выше.

### Можно обойти ограничения Go Pointer

Как упоминалось в начале этой статьи, механизмы (в частности, `unsafe.Pointer` тип), предоставляемые [стандартным `unsafe` пакетом,](https://go101.org/article/unsafe.html) можно использовать для нарушения ограничений, наложенных на указатели в Go. Тип `unsafe.Pointer` как `void*` в C. Вообще небезопасные способы использовать не рекомендуется.
