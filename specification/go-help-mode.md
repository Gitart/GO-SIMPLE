```
go help go.mod

```

Версия модуля определяется деревом исходных файлов с файлом **go.mod** в его корне. Когда команда go выполняется, она просматривает текущий каталог, а затем последующие родительские каталоги, чтобы найти go.mod, отмечающий корень основного (текущего) модуля.

Сам файл go.mod ориентирован на строки, с // комментариями, но без /\* \*/ комментариев. Каждая строка содержит одну директиву, состоящую из глагола, за которым следуют аргументы. Например:

```
module my/thing
go 1.12
require other/thing v1.0.2
require new/thing/v2 v2.3.4
exclude old/thing v1.2.3
replace bad/thing v1.4.5 => good/thing v1.4.5

```

Глаголы:

```
module  чтобы определить путь модуля;
go      чтобы установить ожидаемую версию языка;
require требовать определенный модуль в данной версии
        или новее;
exclude чтобы исключить конкретную версию модуля
        из использования;
replace чтобы заменить версию модуля другой
        версией модуля.

```

exclude и replace применяются только в go.mod основного модуля и игнорируются в зависимостях.

Ведущий глагол может быть выделен из соседних строк для создания блока, как в импорте Go:

```
require (
    new/thing v2.3.4
    old/thing v1.2.3
)

```

Файл go.mod предназначен как для непосредственного редактирования, так и для удобного обновления инструментами. Команда [go mod edit](https://golang-blog.blogspot.com/2019/06/go-commands-go-mod-edit.html) может использоваться для анализа и редактирования файла go.mod из программ и инструментов.

Команда go автоматически обновляет go.mod каждый раз, когда использует граф модуля, чтобы go.mod всегда точно отражал реальность и был правильно отформатирован. Например, рассмотрим этот файл go.mod:

```
module M

require (
        A v1
        B v1.0.0
        C v1.0.0
        D v1.2.3
        E dev
)

exclude D v1.2.3

```

Обновление переписывает неканонические идентификаторы версий в форму semver, поэтому версия v1 для A становится v1.0.0, а dev для E становится псевдо-версией для последнего коммита в ветви dev, возможно, v0.0.0-20180523231146-b3f5c0f6e5f1.

Обновление изменяет требования для соблюдения исключений, поэтому требование исключенной версии D v1.2.3 обновляется для использования следующей доступной версии D, возможно, версии D v1.2.2 или D v1.3.3.

Обновление устраняет избыточные или вводящие в заблуждение требования. Например, если для A v1.0.0 требуется B v1.2.0 и C v1.0.0, то требование go.mod для B v1.0.0 вводит в заблуждение (заменено потребностью A в v1.2.0) и требованием C v1.0.0 является избыточным (подразумевается потребность A в одной и той же версии), поэтому оба будут удалены. Если модуль M содержит пакеты, которые напрямую импортируют пакеты из B или C, то требования будут сохранены, но обновлены до фактических используемых версий.

Наконец, обновление переформатирует go.mod в каноническое форматирование, так что будущие механические изменения приведут к минимальным различиям.

Поскольку граф модуля определяет значение операторов импорта, любые команды, которые загружают пакеты, также используют и, следовательно, обновляют go.mod, включая go build, go get, go install, go list, go test, go mod graph, go mod tidy и go mod why.
