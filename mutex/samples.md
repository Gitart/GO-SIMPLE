# Часть 25: Мьютекс

15 августа 2017

Добро пожаловать в учебник №. 25 в [серии учебных пособий](https://golangbot.com/learn-golang-series/) по [Голангу](https://golangbot.com/learn-golang-series/) .

В этом уроке мы узнаем о мьютексах. Мы также узнаем, как решать условия гонки, используя мьютексы и [каналы](https://golangbot.com/channels/) .

### Критический раздел

Прежде чем перейти к мьютексу, важно понять концепцию [критической секции](https://en.wikipedia.org/wiki/Critical_section) в параллельном программировании. Когда программа запускается одновременно, части кода, которые изменяют общие ресурсы, не должны быть доступны нескольким [подпрограммам](https://golangbot.com/goroutines/) одновременно. Этот раздел кода, который изменяет общие ресурсы, называется критическим разделом. Например, давайте предположим, что у нас есть некоторый фрагмент кода, который увеличивает переменную x на 1.

```
x = x + 1

```

До тех пор, пока к указанному фрагменту кода обращается один Goroutine, проблем не должно быть.

Давайте посмотрим, почему этот код потерпит неудачу, когда одновременно работают несколько Goroutines. Для простоты давайте предположим, что у нас есть 2 Goroutines, выполняющие вышеуказанную строку кода одновременно.

Внутренне вышеуказанная строка кода будет выполняться системой на следующих этапах (есть больше технических деталей, касающихся регистров, как работает сложение и т. Д., Но для этого руководства давайте предположим, что это три этапа),

1.  получить текущее значение х
2.  вычислить х + 1
3.  назначьте вычисленное значение на шаге 2 для x

Когда эти три шага выполняются только одним Goroutine, все хорошо.

Давайте обсудим, что происходит, когда 2 Goroutines запускают этот код одновременно. На рисунке ниже изображен один сценарий того, что может произойти, когда две программы Goroutines `x = x + 1` одновременно получают доступ к строке кода .

![критическое сечение](https://golangbot.com/content/images/2017/08/cs5.png)

Мы предположили, что начальное значение x *равняется* 0\. *Goroutine 1* получает начальное значение x, вычисляет x + 1 и, прежде чем оно сможет присвоить вычисленное значение x, системный контекст переключается на `Goroutine 2` . Теперь `Goroutine 2` получает начальное значение `x` которого все еще `0` вычисляет `x + 1` . После этого системный контекст снова переключается на *Goroutine 1* . Теперь *Goroutine 1* присваивает его вычисленное значение *1* , чтобы *х* и , следовательно , х становится 1. Тогда *Goroutine 2* выполнение начинается снова , а затем присваивает его вычисленное значение, которое еще раз , `1` чтобы `x` и , следовательно , `x` является `1` после того, как Goroutines выполнить.

Теперь давайте посмотрим на другой сценарий того, что может произойти.

![критическое сечение](https://golangbot.com/content/images/2017/08/cs-6.png)

В приведенном выше сценарии `Goroutine 1` запускает выполнение и завершает все три шага, и, следовательно, значение х становится `1` . Затем `Goroutine 2` начинается исполнение. Теперь значение `x` равно 1, а когда `Goroutine 2` заканчивает выполнение, значение `x` равно `2` .

Таким образом, из двух случаев вы можете видеть, что конечное значение x равно `1` или `2` зависит от того, как происходит переключение контекста. Этот тип нежелательной ситуации, когда вывод программы зависит от последовательности выполнения Goroutines, называется **[условием гонки](https://en.wikipedia.org/wiki/Race_condition)** .

В приведенном выше сценарии можно было бы избежать состояния гонки, если бы только одному Goroutine был разрешен доступ к критическому разделу кода в любой момент времени. Это стало возможным благодаря использованию Mutex.

### Mutex

Mutex используется для обеспечения механизма блокировки, гарантирующего, что только один Goroutine в любой момент времени запускает критическую часть кода, чтобы предотвратить возникновение состояния гонки.

Mutex доступен в пакете [синхронизации](https://golang.org/pkg/sync/) . В [Mutex](https://tip.golang.org/pkg/sync/#Mutex) определены два метода, а именно [Lock](https://tip.golang.org/pkg/sync/#Mutex.Lock) и [Unlock](https://tip.golang.org/pkg/sync/#Mutex.Unlock) . Любой код, который присутствует между вызовом `Lock` и `Unlock` будет выполняться только одним Goroutine, таким образом избегая состояния гонки.

```go
mutex.Lock()
x = x + 1
mutex.Unlock()

```

В приведенном выше коде `x = x + 1` будет выполняться только один Goroutine в любой момент времени, тем самым предотвращая состояние гонки.

**Если один Goroutine уже удерживает блокировку и если новый Goroutine пытается захватить блокировку, новый Goroutine будет заблокирован, пока мьютекс не будет разблокирован.**

### Программа с условием гонки

В этом разделе мы напишем программу, которая имеет состояние гонки, а в следующих разделах мы исправим условие гонки.

```go
package main
import (
    "fmt"
    "sync"
    )
var x  = 0
func increment(wg *sync.WaitGroup) {
    x = x + 1
    wg.Done()
}
func main() {
    var w sync.WaitGroup
    for i := 0; i < 1000; i++ {
        w.Add(1)
        go increment(&w)
    }
    w.Wait()
    fmt.Println("final value of x", x)
}

```

В приведенной выше программе `increment` функции в строке нет. 7 увеличивает значение `x` пути , `1` а затем вызывает `Done()` на [WaitGroup](https://golangbot.com/buffered-channels-worker-pools#waitgroup) уведомить его завершение.

Мы порождаем 1000 `increment` Goroutines из линии №. 15 программы выше. Каждая из этих программ запускается одновременно, и при попытке увеличить значение x возникает строка гонки номер строки. 8, так как несколько Goroutines пытаются получить доступ к значению x одновременно.

*Пожалуйста, запустите эту программу в вашем регионе, так как детская площадка является детерминированной, и условия гонки не будут возникать на детской площадке.* Запустите эту программу несколько раз на своем локальном компьютере, и вы увидите, что выход будет разным для каждого случая из\-за состояния гонки. Некоторые из выходов , которые я столкнулся являются `final value of x 941` , `final value of x 928` , `final value of x 922` и так далее.

Получить бесплатную шпаргалку Golang Tools

### Решение условий гонки с использованием мьютекса

В вышеприведенной программе мы породили 1000 Goroutines. Если каждое из них увеличивает значение x на 1, конечное желаемое значение x должно быть 1000. В этом разделе мы исправим условие гонки в приведенной выше программе, используя mutex.

```go
package main
import (
    "fmt"
    "sync"
    )
var x  = 0
func increment(wg *sync.WaitGroup, m *sync.Mutex) {
    m.Lock()
    x = x + 1
    m.Unlock()
    wg.Done()
}
func main() {
    var w sync.WaitGroup
    var m sync.Mutex
    for i := 0; i < 1000; i++ {
        w.Add(1)
        go increment(&w, &m)
    }
    w.Wait()
    fmt.Println("final value of x", x)
}

```

[Бег на детской площадке](https://play.golang.org/p/VX9dwGhR62)

[Мьютекс](https://golang.org/pkg/sync/#Mutex) не тип структуры и мы создаем нулевое значение переменного `m` типа `Mutex` в линии нет. 15\. В приведенной выше программе мы изменили `increment` функцию так, чтобы код, который увеличивает x, `x = x + 1` был между `m.Lock()` и `m.Unlock()` . Теперь этот код не имеет каких\-либо условий гонки, поскольку только один Goroutine может выполнять этот кусок кода в любой момент времени.

Теперь, если эта программа запущена, она выведет

```
final value of x 1000

```

Важно передать адрес мьютекса в строке №. 18\. Если мьютекс передается по значению, а не по адресу, каждый Goroutine будет иметь свою собственную копию мьютекса, и условие гонки все равно будет возникать.

### Решение условий гонки с использованием канала

Мы также можем решить условия гонки, используя каналы. Посмотрим, как это делается.

```go
package main
import (
    "fmt"
    "sync"
    )
var x  = 0
func increment(wg *sync.WaitGroup, ch chan bool) {
    ch <- true
    x = x + 1
    <- ch
    wg.Done()
}
func main() {
    var w sync.WaitGroup
    ch := make(chan bool, 1)
    for i := 0; i < 1000; i++ {
        w.Add(1)
        go increment(&w, ch)
    }
    w.Wait()
    fmt.Println("final value of x", x)
}

```

[Бег на детской площадке](https://play.golang.org/p/M1fPEK9lYz)

В вышеприведенной программе мы создали [буферный канал](https://golangbot.com/buffered-channels-worker-pools/) пропускной способности, `1` и он передается `increment` Goroutine в строке №. 18\. Этот буферизованный канал используется, чтобы гарантировать, что только один Goroutine имеет доступ к критической секции кода, которая увеличивает x. Это делается путем передачи `true` в буферный канал в строке №. 8 перед `x` увеличением. Поскольку буферный канал имеет пропускную способность `1` , все другие подпрограммы, пытающиеся выполнить запись в этот канал, блокируются до тех пор, пока значение не будет считано из этого канала после увеличения x в строке №. 10\. По сути, это позволяет только одному Goroutine получить доступ к критическому разделу.

Эта программа также печатает

```
final value of x 1000

```

### Мьютекс против Каналов

Мы решили проблему состояния гонки, используя как мьютексы, так и каналы. Итак, как мы решаем, что использовать, когда. Ответ заключается в проблеме, которую вы пытаетесь решить. Если проблема, которую вы пытаетесь решить, лучше подходит для мьютексов, тогда используйте мьютекс. Не стесняйтесь использовать mutex, если это необходимо. Если проблема кажется более подходящей для каналов, используйте ее :).

Большинство новичков Go пытаются решить каждую проблему параллелизма, используя канал, поскольку это отличная особенность языка. Это не правильно. Язык дает нам возможность использовать Mutex или Channel, и нет ничего плохого в выборе.

Обычно используют каналы, когда Goroutines должны общаться друг с другом, и мьютексы, когда только один Goroutine должен получить доступ к критическому разделу кода.

В случае проблемы, которую мы решили выше, я бы предпочел использовать мьютекс, так как эта проблема не требует никакой связи между программами. Следовательно, мьютекс будет естественным соответствием.
