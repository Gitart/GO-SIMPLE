## 4.2 Проверка входов

Одним из наиболее важных принципов веб-разработки является то, что вы не можете доверять чему-либо из 
пользовательских форм на стороне клиента. Перед использованием вы должны проверить все входящие данные. 
Эта проблема затрагивает многие веб-сайты, что является простым, но крайне важным.
Существует два способа проверки данных формы, которые широко используются. 
Первая - проверка JavaScript на интерфейсе, а вторая - проверка сервера на внутреннем сервере. 
В этом разделе мы поговорим о проверке на стороне сервера в веб-разработке.

### Обязательные поля

Иногда мы требуем, чтобы пользователи вводили некоторые поля, но они не смогли заполнить поле. Например, в предыдущем разделе, когда мы потребовали имя пользователя. Вы можете использовать эту lenфункцию, чтобы получить длину поля, чтобы убедиться, что пользователи что-то ввели.
```golang
if len(r.Form["username"][0])==0{
        // code for empty field
    }
```
r.FormОбрабатывает различные типы элементов элемента по-разному, когда они пусты. Для пустых текстовых полей, текстовых областей и загрузки файлов возвращается пустая строка; Для переключателей и флажков он даже не создает соответствующие элементы. Вместо этого вы получите ошибки, если попытаетесь получить к нему доступ. Поэтому безопаснее использовать r.Form.Get()для получения значений полей, поскольку он всегда будет пустым, если значение не существует. С другой стороны, r.Form.Get()может получить только одно значение поля за раз, поэтому вам нужно использовать, r.Formчтобы получить карту значений.
чисел

Иногда для значения поля вам нужны номера, а не другой текст. 
Например, предположим, что вам нужен возраст пользователя только в целочисленной форме, то есть 50 или 10, 
вместо «достаточно старый» или «молодой человек». Если нам требуется положительное число, мы можем intсначала 
преобразовать значение в тип, а затем обработать его.

```golang
    getint,err:=strconv.Atoi(r.Form.Get("age"))
    if err!=nil{
        // error occurs when convert to number, it may not a number
    }

    // check range of number
    if getint >100 {
        // too big
    }
 ```
    
Другой способ сделать это - использовать регулярные выражения.
 
 ```golang
    if m, _ := regexp.MatchString("^[0-9]+$", r.Form.Get("age")); !m {
        return false
    }
 ```
    
Для высокопроизводительных целей регулярные выражения неэффективны, однако простые регулярные 
выражения обычно достаточно быстры. Если вы знакомы с регулярными выражениями, это очень удобный 
способ проверки данных. Обратите внимание, что Go использует RE2 , поэтому поддерживаются все символы UTF-8.
Китайский

Иногда нам нужно, чтобы пользователи вводили свои китайские имена, и мы должны убедиться, что все они используют китайские, 
а не случайные символы. Для китайской проверки регулярные выражения - единственный способ.

```golang
if m, _ := regexp.MatchString("^[\\x{4e00}-\\x{9fa5}]+$", r.Form.Get("realname")); !m {
    return false
}
```

### Английские буквы

Иногда нам нужны пользователи для ввода только английских букв. Например, нам требуется чье-то английское имя, 
такое как астакси, а не аста 谢. Мы можем легко использовать регулярные выражения для выполнения нашей проверки.

```golang
if m, _ := regexp.MatchString("^[a-zA-Z]+$", r.Form.Get("engname")); !m {
    return false
}
```

### Адрес электронной почты

Если вы хотите узнать, вошли ли пользователи в действительные адреса электронной почты, вы можете использовать 
следующее регулярное выражение:
```golang
    if m, _ := regexp.MatchString(`^([\w\.\_]{2,10})@(\w{1,}).([a-z]{2,4})$`, r.Form.Get("email")); !m {
        fmt.Println("no")
    }else{
        fmt.Println("yes")
    }
    '''
    
### Выпадающий список

Предположим, нам нужен элемент из раскрывающегося списка, но вместо этого мы получаем стоимость, сфабрированную хакерами. Как мы можем предотвратить это?
Предположим, что мы имеем следующее <select>:

```html
    <select name="fruit">
    <option value="apple">apple</option>
    <option value="pear">pear</option>
    <option value="banana">banana</option>
    </select>
```    
Мы можем использовать следующую стратегию для дезинфекции нашего вклада:
   
   ```golang
   slice:=[]string{"apple","pear","banana"}

    for _, v := range slice {
        if v == r.Form.Get("fruit") {
            return true
        }
    }
    return false
    ```
    
Все функции, которые я показал выше, находятся в моем проекте с открытым исходным кодом для работы на срезах и картах: 
https://github.com/astaxie/beeku

### Радио-кнопки

Если мы хотим знать, является ли пользователь мужским или женским, мы можем использовать радиокнопку, 
возвращая 1 для мужчин и 2 для женщин. Тем не менее, какой-то маленький ребенок, который только что прочитал 
свою первую книгу по HTTP, решает отправить вам 3. Будет ли ваша программа выдавать исключение? Как вы можете видеть, 
нам нужно использовать тот же метод, что и для нашего раскрывающегося списка, чтобы убедиться, что наш радиокнопка возвращает
только ожидаемые значения.

```html
    <input type="radio" name="gender" value="1">Male
    <input type="radio" name="gender" value="2">Female
```

И мы используем следующий код для проверки ввода:

```golang
slice:=[]int{1,2}

    for _, v := range slice {
        if v == r.Form.Get("gender") {
            return true
        }
    }
    return false
```

### Флажки

Предположим, что есть некоторые флажки для интересов пользователя, и что вы также не нуждаетесь в посторонних значениях. Вы можете проверить их следующим образом:
    ```html
    <input type="checkbox" name="interest" value="football">Football
    <input type="checkbox" name="interest" value="basketball">Basketball
    <input type="checkbox" name="interest" value="tennis">Tennis
    ```
    
В этом случае санитария немного отличается от проверки ввода кнопок и флажков, так как здесь мы получаем фрагмент из флажков.

```golang
slice:=[]string{"football","basketball","tennis"}
a:=Slice_diff(r.Form["interest"],slice)
if a == nil{
    return true
}

return false
```

### Дата и время

Предположим, вы хотите, чтобы пользователи вводили допустимые даты или время. Go имеет timeпакет для преобразования года,
месяца и дня в соответствующее время. После этого это легко проверить.

```golang
    t := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
    fmt.Printf("Go launched at %s\n", t.Local())
```

После того, как у вас есть время, вы можете использовать timeпакет для большего количества операций, в зависимости от 
ваших потребностей.
В этом разделе мы обсудили некоторые распространенные методы проверки данных формы на стороне сервера. 
Надеюсь, что теперь вы больше понимаете вопрос о проверке данных в Go, особенно, как использовать регулярные
выражения в ваших интересах.
