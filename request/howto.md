# Как делать HTTP-запросы в Go

![image](https://user-images.githubusercontent.com/3950155/191496926-0d37d501-f324-4082-aa02-88446e1ec21f.png)

## Предпосылки

Чтобы следовать этому руководству, вам понадобятся:

*   Установлена ​​версия Go 1.16 или выше. Чтобы настроить это, следуйте руководству [How To Install Go](https://www.digitalocean.com/community/tutorials/how-to-install-go-on-ubuntu-20-04) для вашей операционной системы.
*   Опыт создания HTTP-сервера в Go, который можно найти в туториале [How To Make an HTTP Server in Go](https://www.digitalocean.com/community/tutorials/how-to-make-an-http-server-in-go) .
*   Знакомство с горутинами и чтением каналов. Для получения дополнительной информации см. руководство [How To Run Multiple Functions Concurrent in Go](https://www.digitalocean.com/community/tutorials/how-to-run-multiple-functions-concurrently-in-go) .
*   Рекомендуется понимать, как составляется и отправляется [HTTP -запрос.](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)

## Выполнение GET-запроса

Пакет Go [`net/http`](https://pkg.go.dev/net/http) имеет несколько различных способов использования в качестве клиента. Вы можете использовать общий глобальный HTTP-клиент с такими функциями, как [`http.Get`](https://pkg.go.dev/net/http#Get) быстрое создание HTTP- `GET` запроса только с URL-адресом и телом, или вы можете создать клиент, [`http.Request`](https://pkg.go.dev/net/http#Request) чтобы приступить к настройке определенных аспектов отдельного запроса. В этом разделе вы создадите первоначальную программу `http.Get` для создания HTTP-запроса, а затем обновите ее для использования `http.Request` с HTTP-клиентом по умолчанию.

### Использование `http.Get` для запроса

В первой итерации вашей программы вы будете использовать эту `http.Get` функцию для отправки запроса к HTTP-серверу, который вы запускаете в своей программе. Функция `http.Get` полезна тем, что вам не нужно никаких дополнительных настроек в вашей программе, чтобы сделать запрос. Если вам нужно сделать один быстрый запрос, `http.Get` может быть лучшим вариантом.

Чтобы приступить к созданию программы, вам понадобится каталог, в котором будет храниться каталог программы. В этом руководстве вы будете использовать каталог с именем `projects` .

Сначала создайте `projects` каталог и перейдите к нему:

```go
mkdir projects
cd projects

```

Затем создайте каталог для своего проекта и перейдите к нему. В этом случае используйте каталог `httpclient` :

```go
mkdir httpclient
cd httpclient
```


Внутри `httpclient` каталога используйте `nano` или ваш любимый редактор, чтобы открыть `main.go` файл:

```
nano main.go

```


В `main.go` файле начните с добавления следующих строк:

```
package main

import (
	"errors"
	"fmt"
	"net/http"
	"os"
	"time"
)

const serverPort = 3333
```


Вы добавляете `package` имя `main` , чтобы ваша программа была скомпилирована как программа, которую вы можете запустить, а затем включаете `import` инструкцию с различными пакетами, которые вы будете использовать в этой программе. После этого вы создаете `const` call `serverPort` со значением `3333` , которое будете использовать в качестве порта, который слушает ваш HTTP-сервер, и порта, к которому будет подключаться ваш HTTP-клиент.

Затем создайте `main` функцию в `main.go` файле и настройте горутину для запуска HTTP-сервера:


```go
...
func main() {
	go func() {
		mux := http.NewServeMux()
		mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
			fmt.Printf("server: %s /\n", r.Method)
		})
		server := http.Server{
			Addr:    fmt.Sprintf(":%d", serverPort),
			Handler: mux,
		}
		if err := server.ListenAndServe(); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				fmt.Printf("error running http server: %s\n", err)
			}
		}
	}()

	time.Sleep(100 * time.Millisecond)

```


Ваш HTTP-сервер настроен на `fmt.Printf` печать информации о входящих запросах всякий раз, когда запрашивается корневой `/` путь. Он также настроен для прослушивания `serverPort` . Наконец, как только вы запустите горутину сервера, ваша программа будет использовать `time.Sleep` ее в течение короткого промежутка времени. Это время ожидания дает HTTP-серверу время, необходимое для запуска и начала обслуживания ответов на следующий запрос.

Теперь также в `main` функции настройте URL-адрес запроса `fmt.Sprintf` , чтобы объединить `http://localhost` имя хоста со `serverPort` значением, которое прослушивает сервер. Затем используйте, `http.Get` чтобы сделать запрос к этому URL-адресу, как показано ниже:


```go
...
	requestURL := fmt.Sprintf("http://localhost:%d", serverPort)
	res, err := http.Get(requestURL)
	if err != nil {
		fmt.Printf("error making http request: %s\n", err)
		os.Exit(1)
	}

	fmt.Printf("client: got response!\n")
	fmt.Printf("client: status code: %d\n", res.StatusCode)
}

```


При `http.Get` вызове функции Go сделает HTTP-запрос, используя HTTP-клиент по умолчанию, на указанный URL-адрес, а затем вернет либо значение, [`http.Response`](https://pkg.go.dev/net/http#Response) либо `error` значение, если запрос не удался. Если запрос не выполнен, он напечатает ошибку, а затем выйдет из вашей программы, используя [`os.Exit`](https://pkg.go.dev/os#Exit) код ошибки `1` . Если запрос выполнен успешно, ваша программа распечатает, что она получила ответ, и полученный код состояния HTTP.

Сохраните и закройте файл, когда закончите.

Чтобы запустить вашу программу, используйте `go run` команду и предоставьте `main.go` ей файл:

```bat
go run main.go

```


Вы увидите следующий вывод:

```
Outputserver: GET /
client: got response!
client: status code: 200

```

В первой строке вывода сервер печатает, что он получил `GET` запрос пути от вашего клиента `/` . Затем в следующих двух строках говорится, что клиент получил ответ от сервера и что код состояния ответа был `200` .

Эта `http.Get` функция полезна для быстрых HTTP-запросов, подобных тому, который вы сделали в этом разделе. Тем не менее, `http.Request` предоставляет более широкий спектр возможностей для настройки вашего запроса.

### Использование `http.Request` для запроса

В отличие от `http.Get` , эта `http.Request` функция предоставляет вам больший контроль над запросом, помимо только метода HTTP и запрашиваемого URL-адреса. Вы пока не будете использовать дополнительные функции, но с помощью `http.Request` сейчас вы сможете добавить эти настройки позже в этом руководстве.

В вашем коде первое обновление заключается в изменении обработчика HTTP-сервера для возврата поддельного ответа данных JSON с использованием `fmt.Fprintf` . Если бы это был полноценный HTTP-сервер, эти данные генерировались бы с помощью [`encoding/json`](https://pkg.go.dev/encoding/json) пакета Go. Если вы хотите узнать больше об использовании JSON в Go, доступно наше руководство [How To Use JSON in Go .](https://www.digitalocean.com/community/tutorials/how-to-use-json-in-go) Кроме того, вам также потребуется включить `io/ioutil` в качестве импорта для использования позже в этом обновлении.

Теперь снова откройте `main.go` файл и обновите свою программу, чтобы начать использовать, `http.Request` как показано ниже:


```go
package main

import (
	...
	"io/ioutil"
	...
)

...

func main() {
	...
	mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Printf("server: %s /\n", r.Method)
		fmt.Fprintf(w, `{"message": "hello!"}`)
	})
	...

```


Теперь обновите код HTTP-запроса, чтобы вместо использования `http.Get` для запроса к серверу вы использовали метод `http.NewRequest` and `http.DefaultClient` : `Do`

main.go

```go
...
	requestURL := fmt.Sprintf("http://localhost:%d", serverPort)
	req, err := http.NewRequest(http.MethodGet, requestURL, nil)
	if err != nil {
		fmt.Printf("client: could not create request: %s\n", err)
		os.Exit(1)
	}

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Printf("client: error making http request: %s\n", err)
		os.Exit(1)
	}

	fmt.Printf("client: got response!\n")
	fmt.Printf("client: status code: %d\n", res.StatusCode)

	resBody, err := ioutil.ReadAll(res.Body)
	if err != nil {
		fmt.Printf("client: could not read response body: %s\n", err)
		os.Exit(1)
	}
	fmt.Printf("client: response body: %s\n", resBody)
}

```


В этом обновлении вы используете `http.NewRequest` функцию для создания `http.Request` значения или обработки ошибки, если значение не может быть создано. Однако, в отличие от `http.Get` функции, `http.NewRequest` функция не сразу отправляет HTTP-запрос на сервер. Поскольку он не отправляет запрос сразу, вы можете внести любые изменения в запрос до его отправки.

После `http.Request` создания и настройки вы используете `Do` метод `http.DefaultClient` для отправки запроса на сервер. Значение `http.DefaultClient` — HTTP-клиент Go по умолчанию, тот же, что вы использовали с `http.Get` . На этот раз, однако, вы используете его напрямую, чтобы сказать ему отправить ваш файл `http.Request` . Метод `Do` клиента HTTP возвращает те же значения, которые вы получили от `http.Get` функции, чтобы вы могли обрабатывать ответ таким же образом.

После того, как вы напечатали результаты запроса, вы используете [`ioutil.ReadAll`](https://pkg.go.dev/io/ioutil#ReadAll) функцию для чтения ответа HTTP `Body` . Это `Body` значение [`io.ReadCloser`](https://pkg.go.dev/io#ReadCloser) , комбинация [`io.Reader`](https://pkg.go.dev/io#Reader) и [`io.Closer`](https://pkg.go.dev/io#Closer) , что означает, что вы можете читать данные тела, используя все, что может читать из [`io.Reader`](https://pkg.go.dev/io#Reader) значения. Эта `ioutil.ReadAll` функция полезна, потому что она будет читать `io.Reader` до тех пор, пока не дойдет до конца данных или не встретит файл `error` . Затем он либо вернет данные в виде `[]byte` значения, которое вы можете распечатать с помощью `fmt.Printf` , либо `error` значение, с которым оно столкнулось.

Чтобы запустить обновленную программу, сохраните изменения и используйте `go run` команду:

```
go run main.go

```


На этот раз ваш вывод должен выглядеть очень похоже на предыдущий, но с одним дополнением:

```
Outputserver: GET /
client: got response!
client: status code: 200
client: response body: {"message": "hello!"}

```

В первой строке вы видите, что сервер все еще получает `GET` запрос на `/` путь. Клиент также получает `200` ответ от сервера, но он также читает и печатает `Body` ответ сервера. В более сложной программе вы можете затем взять `{"message": "hello!"}` значение, которое вы получили в качестве тела с сервера, и обработать его как JSON с помощью [`encoding/json`](https://pkg.go.dev/encoding/json) пакета.

В этом разделе вы создали программу с HTTP-сервером, к которому вы отправляли HTTP-запросы различными способами. Во-первых, вы использовали `http.Get` функцию, чтобы сделать `GET` запрос к серверу, используя только URL-адрес сервера. Затем вы обновили свою программу, чтобы использовать `http.NewRequest` ее для создания `http.Request` значения. После того, как это было создано, вы использовали `Do` метод HTTP-клиента Go по умолчанию, `http.DefaultClient` чтобы сделать запрос и распечатать `http.Response` `Body` его на выходе.

Однако протокол HTTP использует больше, чем просто `GET` запросы для связи между программами. Запрос `GET` полезен, когда вы хотите получить информацию от другой программы, но другой метод HTTP, `POST` метод, можно использовать, когда вы хотите отправить информацию из своей программы на сервер.

## Отправка POST-запроса

В [REST API](https://en.wikipedia.org/wiki/Representational_state_transfer) запрос `GET` используется только для получения информации с сервера, поэтому для полноценного участия вашей программы в REST API ваша программа также должна поддерживать отправку `POST` запросов. Запрос `POST` почти противоположен `GET` запросу, когда клиент отправляет данные на сервер в теле запроса.

В этом разделе вы обновите свою программу, чтобы отправить запрос как `POST` запрос, а не `GET` запрос. Ваш `POST` запрос будет включать тело запроса, и вы обновите свой сервер, чтобы распечатать дополнительную информацию о запросах, которые вы делаете от клиента.

Чтобы начать делать эти обновления, откройте свой `main.go` файл и добавьте в свое заявление несколько новых пакетов, которые вы будете использовать `import` :


```go
...

import (
	"bytes"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"time"
)

...

```


Затем обновите функцию обработчика сервера, чтобы распечатать различную информацию о входящем запросе, такую ​​как значения строки запроса, значения заголовка и тело запроса:


```go
...
  mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
	  fmt.Printf("server: %s /\n", r.Method)
	  fmt.Printf("server: query id: %s\n", r.URL.Query().Get("id"))
	  fmt.Printf("server: content-type: %s\n", r.Header.Get("content-type"))
	  fmt.Printf("server: headers:\n")
	  for headerName, headerValue := range r.Header {
		  fmt.Printf("\t%s = %s\n", headerName, strings.Join(headerValue, ", "))
	  }

	  reqBody, err := ioutil.ReadAll(r.Body)
	  if err != nil {
			 fmt.Printf("server: could not read request body: %s\n", err)
	  }
	  fmt.Printf("server: request body: %s\n", reqBody)

	  fmt.Fprintf(w, `{"message": "hello!"}`)
  })
...

```


В этом обновлении обработчика HTTP-запросов сервера вы добавляете еще несколько полезных `fmt.Printf` инструкций для просмотра информации о входящем запросе. Вы используете `r.URL.Query().Get` для получения значения строки запроса с именем `id` и `r.Header.Get` для получения значения заголовка с именем `content-type` . Вы также используете `for` цикл с `r.Header` для печати имени и значения каждого HTTP-заголовка, полученного сервером. Эта информация может быть полезна для устранения неполадок, если ваш клиент или сервер не работают так, как вы ожидаете. Наконец, вы также использовали `ioutil.ReadAll` функцию для чтения тела HTTP-запроса в формате `r.Body` .

После обновления функции обработчика сервера обновите `main` код запроса функции, чтобы он отправлял `POST` запрос с телом запроса:


```go
...
 time.Sleep(100 * time.Millisecond)

 jsonBody := []byte(`{"client_message": "hello, server!"}`)
 bodyReader := bytes.NewReader(jsonBody)

 requestURL := fmt.Sprintf("http://localhost:%d?id=1234", serverPort)
 req, err := http.NewRequest(http.MethodPost, requestURL, bodyReader)
...

```


В вашем обновлении `main` запроса функции одно из новых значений, которые вы определяете, является `jsonBody` значением. В этом примере значение представлено как `[]byte` вместо стандартного, `string` потому что, если вы используете `encoding/json` пакет для кодирования данных JSON, он даст вам `[]byte` обратно вместо `string` .

Следующее значение, `bodyReader` , представляет собой [`bytes.Reader`](https://pkg.go.dev/bytes#Reader) перенос `jsonBody` данных. Тело `http.Request` требует, чтобы значение было `io.Reader` , а `jsonBody` значение `[]byte` не реализует `io.Reader` , поэтому вы не сможете использовать его как тело запроса самостоятельно. Значение `bytes.Reader` существует для предоставления этого `io.Reader` интерфейса, поэтому вы можете использовать это `jsonBody` значение в качестве тела запроса.

Значение `requestURL` также обновляется, чтобы включить `id=1234` значение строки запроса, прежде всего, чтобы показать, как значение строки запроса также может быть включено в URL-адрес запроса вместе с другими стандартными компонентами URL-адреса.

Наконец, `http.NewRequest` вызов функции обновляется для использования `POST` метода с `http.MethodPost` , а тело запроса включается путем обновления последнего параметра из `nil` тела `bodyReader` на данные JSON `io.Reader` .

После того, как вы сохранили свои изменения, вы можете использовать `go run` для запуска своей программы:

```
go run main.go

```


Вывод будет длиннее, чем раньше, из-за ваших обновлений на сервере для отображения дополнительной информации:

```go
Outputserver: POST /
server: query id: 1234
server: content-type:
server: headers:
        Accept-Encoding = gzip
        User-Agent = Go-http-client/1.1
        Content-Length = 36
server: request body: {"client_message": "hello, server!"}
client: got response!
client: status code: 200
client: response body: {"message": "hello!"}

```

Первая строка с сервера показывает, что ваш запрос теперь проходит как `POST` запрос `/` пути. Во второй строке отображается `1234` значение `id` строки запроса, которое вы добавили к URL-адресу запроса. Третья строка показывает значение `Content-Type` заголовка, отправленного клиентом, который оказался пустым в этом запросе.

Четвертая строка может немного отличаться от вывода, который вы видите выше. В Go порядок `map` значений не гарантируется, когда вы перебираете их с помощью `range` , поэтому ваши заголовки `r.Headers` могут распечатываться в другом порядке. В зависимости от версии Go, которую вы используете, вы также можете увидеть `User-Agent` версию, отличную от указанной выше.

Наконец, последнее изменение в выводе заключается в том, что сервер показывает тело запроса, полученное от клиента. Затем сервер может использовать `encoding/json` пакет для анализа данных JSON, отправленных клиентом, и формирования ответа.

В этом разделе вы обновили свою программу для отправки HTTP `POST` \-запроса вместо `GET` запроса. Вы также обновили свою программу, чтобы отправить тело запроса с `[]byte` данными, считываемыми файлом `bytes.Reader` . Наконец, вы обновили функцию обработчика сервера, чтобы распечатать больше информации о запросе, который делает ваш HTTP-клиент.

Обычно в HTTP-запросе клиент или сервер сообщают другому тип контента, который он отправляет в теле. Однако, как вы видели в последнем выводе, ваш HTTP-запрос не включал `Content-Type` заголовок, сообщающий серверу, как интерпретировать данные тела. В следующем разделе вы сделаете несколько обновлений для настройки вашего HTTP-запроса, в том числе установите `Content-Type` заголовок, чтобы сервер знал тип данных, которые вы отправляете.

## Настройка HTTP-запроса

Со временем HTTP-запросы и ответы стали использоваться для отправки большего количества данных между клиентами и серверами. В какой-то момент HTTP-клиенты могут предположить, что данные, которые они получают от HTTP-сервера, представляют собой HTML и имеют хорошие шансы быть правильными. Однако теперь это может быть HTML, JSON, музыка, видео или любое количество других типов данных. Чтобы предоставить больше информации о данных, отправляемых по HTTP, протокол включает заголовки HTTP, и одним из таких важных заголовков является `Content-Type` заголовок. Этот заголовок сообщает серверу (или клиенту, в зависимости от направления данных), как интерпретировать полученные данные.

В этом разделе вы обновите свою программу, чтобы установить `Content-Type` заголовок в вашем HTTP-запросе, чтобы сервер знал, что он получает данные JSON. Вы также обновите свою программу, чтобы использовать клиент HTTP, отличный от клиента Go по умолчанию `http.DefaultClient` , чтобы вы могли настроить способ отправки запроса.

`main.go` Чтобы внести эти обновления, снова откройте файл и обновите свою `main` функцию следующим образом:


```go
...

  req, err := http.NewRequest(http.MethodPost, requestURL, bodyReader)
  if err != nil {
		 fmt.Printf("client: could not create request: %s\n", err)
		 os.Exit(1)
  }
  req.Header.Set("Content-Type", "application/json")

  client := http.Client{
	 Timeout: 30 * time.Second,
  }

  res, err := client.Do(req)
  if err != nil {
	  fmt.Printf("client: error making http request: %s\n", err)
	  os.Exit(1)
  }

...

```


В этом обновлении вы получаете доступ к `http.Request` заголовкам с помощью `req.Header` , а затем устанавливаете значение `Content-Type` заголовка в запросе на `application/json` . Тип `application/json` мультимедиа определяется в списке [типов мультимедиа](https://www.iana.org/assignments/media-types/media-types.xhtml) как тип мультимедиа для JSON. Таким образом, когда сервер получает ваш запрос, он знает, что нужно интерпретировать тело как JSON, а не, например, как [XML](https://en.wikipedia.org/wiki/XML) .

Следующее обновление заключается в создании собственного `http.Client` экземпляра в `client` переменной. В этом клиенте вы устанавливаете `Timeout` значение 30 секунд. Это важно, потому что это говорит о том, что любые запросы, сделанные с клиентом, сдаются и прекращают попытки получить ответ через 30 секунд. По умолчанию Go `http.DefaultClient` не указывает тайм-аут, поэтому, если вы делаете запрос с помощью этого клиента, он будет ждать, пока не получит ответ, не будет отключен сервером или ваша программа не завершится. Если у вас есть много запросов, ожидающих ответа, как это, вы можете использовать большое количество ресурсов на вашем компьютере. Установка `Timeout` значения ограничивает время ожидания запроса к указанному вами времени.

Наконец, вы обновили свой запрос, чтобы использовать `Do` метод вашей `client` переменной. Вам не нужно вносить здесь какие-либо другие изменения, потому что вы все время вызывали `Do` значение `http.Client` . HTTP-клиент Go по умолчанию `http.DefaultClient` — это просто `http.Client` созданный по умолчанию. Таким образом, когда вы вызывали `http.Get` , функция вызывала `Do` метод для вас, и когда вы обновляли свой запрос для использования `http.DefaultClient` , вы использовали его `http.Client` напрямую. Единственная разница сейчас в том, что вы создали `http.Client` значение, которое используете на этот раз.

Теперь сохраните файл и запустите программу, используя `go run` :

```
go run main.go

```


Ваш вывод должен быть очень похож на предыдущий вывод, но с дополнительной информацией о типе контента:

```
Outputserver: POST /
server: query id: 1234
server: content-type: application/json
server: headers:
        Accept-Encoding = gzip
        User-Agent = Go-http-client/1.1
        Content-Length = 36
        Content-Type = application/json
server: request body: {"client_message": "hello, server!"}
client: got response!
client: status code: 200
client: response body: {"message": "hello!"}

```

Вы увидите значение с сервера для `content-type` , а также `Content-Type` заголовок, отправляемый клиентом. Вот как вы можете иметь один и тот же путь HTTP-запроса, одновременно обслуживающий JSON и XML API. Указав тип содержимого запроса, сервер и клиент могут интерпретировать данные по-разному.

Однако этот пример не запускает настроенный вами тайм-аут клиента. Чтобы увидеть, что происходит, когда запрос занимает слишком много времени и срабатывает тайм-аут, откройте `main.go` файл и добавьте `time.Sleep` вызов функции в функцию обработчика вашего HTTP-сервера. Затем сделайте `time.Sleep` последний дольше указанного вами тайм-аута. В этом случае вы установите его на 35 секунд:


```go
...

func main() {
	go func() {
		mux := http.NewServeMux()
		mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
			...
			fmt.Fprintf(w, `{"message": "hello!"}`)
			time.Sleep(35 * time.Second)
		})
		...
	}()
	...
}

```


Теперь сохраните изменения и запустите программу, используя `go run` :

```
go run main.go

```


Когда вы запустите его на этот раз, для выхода потребуется больше времени, чем раньше, потому что он не завершится, пока не завершится HTTP-запрос. Поскольку вы добавили `time.Sleep(35 * time.Second)` , HTTP-запрос не будет выполнен до тех пор, пока не будет достигнуто 30-секундное время ожидания:

```go
Outputserver: POST /
server: query id: 1234
server: content-type: application/json
server: headers:
        Content-Type = application/json
        Accept-Encoding = gzip
        User-Agent = Go-http-client/1.1
        Content-Length = 36
server: request body: {"client_message": "hello, server!"}
client: error making http request: Post "http://localhost:3333?id=1234": context deadline exceeded (Client.Timeout exceeded while awaiting headers)
exit status 1

```

В этом выводе программы вы видите, что сервер получил запрос и обработал его, но когда он достиг конца функции обработчика HTTP, где находится ваш `time.Sleep` вызов функции, он начал спать в течение 35 секунд. В то же время тайм-аут для вашего HTTP-запроса отсчитывается и достигает предела в 30 секунд до завершения HTTP-запроса. Это приводит к `client.Do` сбою вызова метода с `context deadline exceeded` ошибкой, поскольку 30-секундный крайний срок запроса истек. Затем ваша программа завершается с кодом состояния ошибки `1` использования `os.Exit(1)` .

В этом разделе вы обновили свою программу, чтобы настроить HTTP-запрос, добавив `Content-Type` к нему заголовок. Вы также обновили свою программу, чтобы создать новую `http.Client` с 30-секундным тайм-аутом, а затем использовали этот клиент для выполнения HTTP-запроса. Вы также протестировали 30-секундный тайм-аут, добавив в `time.Sleep` обработчик HTTP-запросов. Наконец, вы также увидели, почему важно использовать ваши собственные `http.Client` значения с установленными тайм-аутами, если вы хотите избежать потенциального бездействия многих запросов.

## Вывод

В этом руководстве вы создали новую программу с HTTP-сервером и использовали `net/http` пакет Go для выполнения HTTP-запросов к этому серверу. Во-первых, вы использовали эту `http.Get` функцию, чтобы сделать `GET` запрос к серверу с HTTP-клиентом Go по умолчанию. Затем вы использовали метод `http.NewRequest` with `http.DefaultClient` , `Do` чтобы сделать `GET` запрос. Затем вы обновили свой запрос, чтобы сделать его `POST` запросом с телом, используя `bytes.NewReader` . Наконец, вы использовали `Set` метод в `http.Request` поле `Header` для установки `Content-Type` заголовка запроса и установили 30-секундный тайм-аут для длительности запроса, создав собственный HTTP-клиент вместо использования клиента Go по умолчанию.

Пакет [`net/http`](https://pkg.go.dev/net/http) включает в себя больше, чем просто функции, которые вы использовали в этом руководстве. Он также включает в себя [`http.Post`](https://pkg.go.dev/net/http#Post) функцию, которая может быть использована для выполнения `POST` запроса, аналогично `http.Get` функции. Пакет также поддерживает сохранение и извлечение [файлов cookie](https://pkg.go.dev/net/http#CookieJar) среди других функций.

Это руководство также является частью серии [DigitalOcean](https://www.digitalocean.com/) [How to Code in Go](https://www.digitalocean.com/community/tutorial_series/how-to-code-in-go) . Серия охватывает ряд тем по Go, от первой установки Go до использования самого языка.
