### Флаги тестирования в Golang

Команда 'go test' принимает флаги, которые применяются к самому 'go test', и флаги, которые применяются к полученному бинарному файлу теста.

Несколько флагов управляют профилированием и записывают профиль выполнения, подходящий для "go tool pprof"; запустите "go tool pprof \-h" для получения дополнительной информации. Параметры \-\-alloc\_space, \-\-alloc\_objects и \-\-show\_bytes в pprof управляют представлением информации.

Следующие флаги распознаются командой 'go test' и контролируют выполнение любого теста:

```
-bench regexp

```

Запускать только те эталонные тесты (benchmarks), которые соответствуют регулярному выражению. По умолчанию эталонные тесты не запускаются. Чтобы запустить все эталонные тесты, используйте '\-bench .' или '\-bench=.'. Регулярное выражение разделяется символами косой чертой без скобок (/) в последовательности регулярных выражений, и каждая часть идентификатора эталонного теста должна соответствовать элементу в последовательности, если есть. Возможные родители соотвествий запускаются с b.N=1, чтобы идентифицировать нижележащие эталонные тесты. Например, учитывая \-bench =X/Y, запускаются эталонные тесты верхнего уровня, соответствующие X с b.N=1, чтобы найти любые нижележащие эталонные тесты, соответствующие Y, которые потом запускаются полностью.

---

```
-benchtime t

```

Запустить достаточно итераций каждого эталонного теста, чтобы взять t, указанный как time.Duration (например, \-benchtime 1h30s). По умолчанию это 1 секунда (1s). Специальный синтаксис Nx означает запуск теста N раз (например, \-benchtime 100x).

---

```
-count n

```

Запустите каждый тест и эталонный тест n раз (по умолчанию 1). Если установлена опция \-cpu, запускать n раз для каждого значения GOMAXPROCS. Примеры всегда запускаются один раз.

---

```
-cover

```

Включить анализ покрытия. Обратите внимание, потому что покрытие работает, аннотируя исходный код перед компиляцией, компиляция и ошибки тестирования с включенным покрытием могут сообщать номера строк, которые не соответствуют оригинальному исходному коду.

---

```
-covermode set,count,atomic

```

Установить режим анализа покрытия для пакета/пакетов, которые тестируются. По умолчанию установлено "set", если не включена опция \-race, в этом случае это "atomic".
Значения:
set: bool: это утверждение выполняется?
count: int: сколько раз выполняется это утверждение?
atomic: int: то же самое что count, но корректный в многопоточных тестах; значительно более затратный.
Включает флаг \-cover.

---

```
-coverpkg pattern1,pattern2,pattern3

```

Применить анализ покрытия в каждом тесте к пакетам, соответствующим шаблонам (patterns). По умолчанию для каждого теста анализируется только тестируемый пакет. Смотрите 'go help packages' для описания шаблонов пакетов.
Включает флаг \-cover.

---

```
-cpu 1,2,4

```

Укажите список значений GOMAXPROCS, для которых тесты или эталонные тесты должны быть выполнены. По умолчанию используется текущее значение GOMAXPROCS.

---

```
-failfast

```

Не запускать новые тесты после первого неудачного теста.

---

```
-list regexp

```

Перечислите тесты, эталонные тесты (benchmarks) или примеры, соответствующие регулярному выражению. Никаких тестов, эталонных тестов или примеров запускаться не будет. Это будет только список тестов верхнего уровня. Никакие субтесты или суб\-эталонные тесты не будут показаны.

---

```
-parallel n

```

Разрешить параллельное выполнение тестовых функций, которые вызывают t.Parallel. Значение этого флага \- максимальное количество тестов для одновременного запуска; по умолчанию для него установлено значение GOMAXPROCS. Обратите внимание, что \-parallel применяется только в одном бинарном тесте. Команда go test может запускать тесты для разных пакетов параллельно, в соответствии с настройкой флага \-p (см. [go help build](https://golang-blog.blogspot.com/2019/06/go-commands-go-build.html)).

---

```
-run regexp

```

Запускайте только те тесты и примеры, которые соответствуют регулярному выражению. Для тестов регулярное выражение разделяется символами косой черты без скобок (/) в последовательности регулярных выражений, и каждая часть идентификатора теста должна совпадать с соответствующим элементом в последовательности, если есть. Обратите внимание, что возможные родители соответствий тоже запускаются, так что \-run =X/Y соответствует, запускает и сообщает результаты всех тестов, соответствующих X, даже без тестов, соответствующих Y, потому что он должен запустить их, чтобы искать эти под\-тесты.

---

```
-short

```

Сообщить длительным тестам, чтобы они сократили свое время выполнения. Флаг выключен по умолчанию, но установлен во время all.bash, чтобы установка дерева Go могла выполнять проверку работоспособности, но не тратить время на прохождение исчерпывающих длительных тестов.

---

```
-timeout d

```

Если тестовый бинарный файл работает дольше, чем продолжительность d, запускать panic. Если d равно 0, тайм\-аут отключен. По умолчанию 10 минут (10m).

---

```
-v

```

Подробный вывод: протоколировать все тесты по мере их запуска. Также распечатать весь текст из вызовов Log и Logf, даже если тест пройден успешно.

---

```
-vet list

```

Сконфигурировать вызов "go vet" во время "go test" чтобы использовать разделенный запятыми список проверок. Если список пуст, "go test" запускает "go vet" с курируемым списком проверок, считаемых всегда заслуживающими внимания. Если list равен "off", "go test" вообще не запускает "go vet".

---

Следующие флаги также распознаются 'go test' и могут использоваться **для профилирования тестов во время выполнения**:

```
-benchmem

```

Распечатать статистику распределения памяти для тестов.

---

```
-blockprofile block.out

```

Записать профиль блокировки goroutine в указанный файл когда все тесты завершены. Записывает тестовый бинарный файл как делает флаг \-c.

---

```
-blockprofilerate n

```

Контролировать детализацию профилей блокировки goroutine посредством вызова runtime.SetBlockProfileRate с n. См. 'go doc runtime.SetBlockProfileRate'. Целью профилировщика является выборка в среднем одного блокирующего события каждые n наносекунд, которые программа тратит на блокировку. По умолчанию, если \-test.blockprofile установлен без этого флага, все события блокировки записаны, эквивалентно \-test.blockprofilerate=1.

---

```
-coverprofile cover.out

```

Записать профиль покрытия в файл после того, как все тесты пройдены.
Включает флаг \-cover.

---

```
-cpuprofile cpu.out

```

Записать профиль CPU в указанный файл перед выходом. Записывает тестовый бинарный файл как делает флаг \-c.

---

```
-memprofile mem.out

```

Записать профиль распределения в файл после того, как все тесты пройдены. Записывает тестовый бинарный файл как флаг \-c.

---

```
-memprofilerate n

```

Включить более точные (и дорогие) профили выделения памяти установкой runtime.MemProfileRate. Смотрите 'go doc runtime.MemProfileRate'. Чтобы профилировать все распределения памяти, используйте \-test.memprofilerate=1.

---

```
-mutexprofile mutex.out

```

Записать конфликтный профиль мьютекса в указанный файл когда все тесты завершены. Записывает тестовый бинарный файл как флаг \-c.

---

```
-mutexprofilefraction n

```

Образец 1 в n стека следов goroutines, содержащих утвержденный мьютекс.

---

```
-outputdir directory

```

Поместить выходные файлы из профилирования в указанный каталог, по умолчанию каталог, в котором запущен "go test".

---

```
-trace trace.out

```

Записать трассировку выполнения в указанный файл перед выходом.

---

Каждый из этих флагов также распознается с помощью необязательного 'test.' префикса, как в \-test.v. Однако при непосредственном вызове сгенерированного тестового бинарного файла (результат 'go test \-c') префикс обязателен.

Команда 'go test' переписывает или удаляет распознанные флаги, в зависимости от ситуации, как до, так и после необязательного списка пакетов, до вызова тестового бинарного файла.

Например, команда

```
go test -v -myflag testdata -cpuprofile=prof.out -x

```

скомпилирует тестовый бинарный файл, а затем запустит его как

```
pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out

```

(Флаг \-x удален, потому что он применяется только к выполнению команды go, а не к самому тесту.)

Флаги теста, которые генерируют профили (кроме покрытия), также оставляют тестовый бинарный файл в pkg.test для использования при анализе профилей.

Когда 'go test' запускает тестовый бинарный файл, он делает это из каталога исходного кода соответствующего пакета. В зависимости от теста может потребоваться сделать то же самое при непосредственном вызове сгенерированного тестового бинарного файла.

Список пакетов командной строки, если он присутствует, должен отображаться перед любым флагом, неизвестным команде go test. Продолжая приведенный выше пример, список пакетов должен отображаться перед \-myflag, но может отображаться с любой стороны от \-v.

Когда 'go test' выполняется в режиме списка пакетов, 'go test' кэширует успешные результаты тестирования пакета, чтобы избежать ненужного повторного запуска тестов. Чтобы отключить тестовое кэширование, используйте любой тестовый флаг или аргумент, кроме кешируемых флагов. **Идиоматический способ явного отключения кэширования тестов** \- использовать \-count=1.

Чтобы аргумент для тестового бинарного файла не интерпретировался как известный флаг или имя пакета, используйте параметр \-args (см. [go help test](https://golang-blog.blogspot.com/2019/06/go-commands-go-test.html)), который передает оставшуюся часть командной строки в тестовый бинарный файл без интерпретации и не измененной.

Например, команда

```
go test -v -args -x -v

```

скомпилирует тестовый бинарный файл, а затем запустит его как

```
pkg.test -test.v -x -v

```

Так же,

```
go test -args math

```

скомпилирует тестовый бинарный файл, а затем запустит его как

```
pkg.test math

```

В первом примере \-x и второй \-v передаются в тестовый бинарный файл без изменений и не влияют на саму команду go. Во втором примере аргумент math передается в тестовый бинарный файл, а не интерпретируется как список пакетов.
