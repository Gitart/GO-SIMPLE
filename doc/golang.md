## Let's Go: Программы командной строки с Golang


Язык Go - это захватывающий новый язык, который пользуется большой популярностью по уважительной причине. 
В этом уроке вы узнаете, как писать программы командной строки с помощью Go. Образец программы называется 
multi-git, и он позволяет одновременно выполнять команды git на нескольких репозиториях.


### Краткое введение в Go
Go - это C-подобный язык с открытым исходным кодом, созданный в Google некоторыми из оригинальных хакеров C и Unix, которые были мотивированы их неприязнью к C ++. Он показывает в дизайне Go, который сделал несколько неортодоксальных выборов, таких как отказ от наследования реализации, шаблонов и исключений. Go просто, надежно и эффективно. Его наиболее отличительной особенностью является его явная поддержка параллельного программирования через так называемые goroutines и каналы.

Перед тем, как начать анализировать образец программы, следуйте официальному руководству, чтобы подготовиться к разработке Go.
Go - невероятно мощный язык программирования, учите все, начиная от написания простых утилит и заканчивая построением масштабируемых, гибких веб-серверов в нашем полном объеме.
Go Lang Go Основы для создания веб-серверов Derek Jense

### Программа Multi-Git
Программа multi-git представляет собой простую, но полезную программу Go. Если вы работаете в команде, где кодовая база разделяется на несколько репозиториев git, вам часто приходится выполнять изменения в нескольких репозиториях. Это проблема, потому что git не имеет понятия о нескольких репозиториях. Все вращается вокруг одного репозитория.
Это становится особенно хлопотным, если вы используете ветви. Если вы работаете над функцией, которая затрагивает три репозитория, вам нужно будет создать ветвь функции в каждом из этих репозиториев, а затем не забудьте проверить, вытащить, нажать и объединить все из них одновременно. Это не тривиально. Multi-git управляет набором репозиториев и позволяет вам работать со всем набором одновременно. Обратите внимание, что текущая версия multi-git требует, чтобы вы создавали ветки отдельно, но я могу добавить эту функцию позже.
Изучив способ реализации multi-git, вы много узнаете о написании программ командной строки в Go.

### Пакеты и импортные программы
Go организованы в пакеты. Программа multi-git состоит из одного файла main.go. В верхней части файла указывается имя пакета «main», а затем список импорта. Импорт - это другие пакеты, которые используются несколькими git.

```
package mai
import (
    "flag"
    "fmt"
    "log"
    "os"
    "strings"
    "os/exec"
)PHPCopy
```

Например, пакет fmt используется для форматированного I O, аналогичного printf и scanf C. Go поддерживает установку пакетов из разных источников с помощью команды go get. Когда вы устанавливаете пакеты, они попадают в пространство имен в переменной $ GOPATH. Вы можете устанавливать пакеты из различных источников, таких как GitHub, Bitbucket, Google, Launchpad и даже службы IBM DevOps через несколько распространенных форматов управления версиями, таких как git, subversion, mercurial и bazaar.

### Аргументы командной строки
Аргументы командной строки являются одной из наиболее распространенных форм предоставления ввода для программ. Они просты в использовании, позволяют запускать и настраивать программу в одной строке и иметь большую поддержку синтаксического разбора на многих языках. Go вызывает их «флаги» командной строки и имеет пакет флага для указания и анализа аргументов командной строки (или флагов).
Как правило, вы разбираете аргументы командной строки в начале вашей программы, а multi-git следует этому соглашению. Точкой входа является функция main (). Первые две строки определяют два флага, называемые «команда» и «ignoreErrors». Каждый флаг имеет имя, тип данных, значение по умолчанию и строку справки. Вызов flag.Parse () будет анализировать фактическую командную строку, переданную программе, и будет заполнять определенные флаги.

```
func main() {
    command := flag.String("command", "", "The git command")
    ignoreErrors := flag.Bool(
        "ignore-errors",
        false,
        "Keep ruing after error if true")
    flag.Parse()PHPCopy
    ```
    
Также возможно получить доступ к неопределенным аргументам с помощью функции flag.Args (). Таким образом, флаги обозначают заранее определенные аргументы, а аргументы «args» - это необработанные аргументы. Необработанные аргументы индексируются на основе 0.

### Переменные среды
Другим распространенным видом конфигурации программы являются переменные среды. Когда вы используете переменные среды, вы можете запускать одну и ту же программу несколько раз в одной и той же среде, и все прогоны будут использовать одни и те же переменные среды.

Multi-git использует две переменные среды: «MG_ROOT» и «MG_REPOS». Multi-git предназначен для управления группой репозиториев git с общим родительским каталогом. Это «MG_ROOT». Имена репозитория указаны в «MG_REPOS» как строка, разделенная запятыми. Чтобы прочитать значение переменной среды, вы можете использовать функцию os.Getenv ().

```
// Get managed repos from environment variables
root := os.Getenv("MG_ROOT")
if root[len(root) - 1] != '/' {
    root += "/"
}
repo_names := strings.Split(os.Getenv("MG_REPOS"), ",")PHPCopy
```

### Проверка списка репозитория
Теперь, когда он нашел корневую директорию и имена всех репозиториев, multi-git проверяет, что каждый репозиторий существует под root и что он действительно репозиторий git. Проверка выполняется так же просто, как поиск подкаталога.git для каждого каталога репозитория.
Сначала определяется массив строк с именем «repos». Затем он выполняет итерацию по всем именам репо и создает путь репозитория путем объединения корневого каталога и имени репо. Если вызов [os.Stat ()] () завершился с ошибкой для подкаталога.git, он регистрирует ошибку и завершает работу. В противном случае путь репозитория добавляется к массиву репозиториев.

```
var repos []string
// Verify all repos exist and are actually git repos (have .git sub-dir)
for _, r := range repo_names {
    path := root + r
    _, err := os.Stat(path + "/.git")
    if err != nil {
        log.Fatal(err)
    }
    repos = append(repos, path)
}PHPCopy
```

Go имеет уникальную систему обработки ошибок, где функции часто возвращают как возвращаемое значение, так и объект ошибки. Посмотрите, как os.Stat () возвращает два значения. В этом случае местозаполнитель «_» используется для хранения фактического результата, потому что вы только заботитесь об ошибке. Go очень строгий и требует использования именных переменных. Если вы не планируете использовать значение, вы должны назначить его «_», чтобы избежать ошибки компиляции.

### Выполнение команд оболочки
На этом этапе у вас есть список путей репозитория, где мы хотим выполнить команду git. Как вы помните, мы получили командную строку git как один аргумент командной строки (флаг), называемый «команда». Это необходимо разбить на массив компонентов (команда git, подкоманда и параметры). Вся команда в виде строки также сохраняется для отображения.

```
// Break the git command into components (needed to execute)
var git_components []string
for _, component := range strings.Split(*command, " ") {
    git_components = append(git_components, component)
}
command_string := "git " + *commandPHPCopy
```

Теперь вы настроены на итерацию по каждому репозиторию и выполните команду git в каждом из них. Консольная конструкция «для... диапазона» используется снова. Во-первых, multi-git меняет рабочий каталог на текущую целевую репо «r» и печатает команду git. Затем он выполняет команду с помощью функции exec.Command () и печатает комбинированный вывод (как стандартный вывод, так и стандартную ошибку).
Наконец, он проверяет, была ли ошибка во время выполнения. Если произошла ошибка, а флаг ignoreErrors был ложным, тогда вызывается многозадачность. Причина необязательного игнорирования ошибок заключается в том, что иногда это нормально, если команды не работают на некоторых репозиториях. Например, если вы хотите проверить ветвь с названием «классная функция» во всех репозиториях, имеющих эту ветку, вам все равно, если проверка завершится неудачно в репозиториях, у которых нет этой ветви.

```
for _, r := range repos {
    // Go to the repo's directory
    os.Chdir(r);
    // Print the command
    fmt.Printf("[%s] %sn", r, command_string)
    // Execute the command
    out, err := exec.Command("git", git_components...).CombinedOutput()
    // Print the result
    fmt.Println(string(out))
    // Bail out if there was an error and NOT ignoring errors
    if err != nil &&!*ignoreErrors {
        os.Exit(1)
    }
}
fmt.Println("Done.")PHPCopy
```

### Вывод
Go - простой, но мощный язык. Он разработан для крупномасштабного системного программирования, но отлично подходит для небольших программ командной строки. Минимальный дизайн Go находится в резком контрасте с другими современными языками, такими как Scale и Rust, 
которые очень мощные и хорошо продуманные, но имеют очень крутую кривую обучения. 
Я рекомендую попробовать попробовать и экспериментировать. Это очень весело.
