# go mod

## go mod init [module]
init инициализирует и записывает новый go.mod в текущий каталог, фактически создавая новый модуль с корнем в текущем каталоге. Файл go.mod не должен уже существовать. Если возможно, init будет угадывать путь к модулю из комментариев к импорту (см. go help importpath) или из конфигурации управления версиями. Чтобы переопределить это предположение, укажите путь к модулю в качестве аргумента.

## go mod tidy
добавить отсутствующие и удалить неиспользуемые модули

Использование:
```
go mod tidy [-v]
```

tidy удостоверяется, что go.mod соответствует исходному коду в модуле. Он добавляет все недостающие модули, необходимые для построения пакетов и зависимостей текущего модуля, и удаляет неиспользуемые модули, которые не предоставляют никаких соответствующих пакетов. Он также добавляет все недостающие записи в go.sum и удаляет ненужные.
Флаг -v заставляет tidy печатать информацию об удаленных модулях в стандартный вывод ошибки (std err).

## go mod download
загрузка модулей в локальный кеш
Использование:
```
go mod download [-json] [modules]
```

download загружает названные модули, которые могут быть шаблонами модулей, выбирающими зависимости основного модуля, или запросами модулей вида path@version. Без аргументов download применяется ко всем зависимостям основного модуля.

Команда go автоматически загружает модули по мере необходимости во время обычного выполнения. Команда "go mod download" полезна в основном для предварительного заполнения локального кэша или для вычисления ответов от прокси Go модуля.

По умолчанию download сообщает об ошибках в вывод стандартной ошибки (std err), но в остальном молчит. Флаг -json заставляет download печатать последовательность объектов JSON в стандартный вывод, описывая каждый загруженный модуль (или сбой), соответствующий этой Go структуре:

```
type Module struct {
    Path     string // путь к модулю
    Version  string // версия модуля
    Error    string // ошибка загрузки модуля
    Info     string // абсолютный путь к кешированному файлу .info
    GoMod    string // абсолютный путь к кешированному файлу .mod
    Zip      string // абсолютный путь к кешированному .zip файлу
    Dir      string // абсолютный путь к кешированному корневому каталогу источника
    Sum      string // контрольная сумма для пути, версии (как в go.sum)
    GoModSum string // контрольная сумма для go.mod (как в go.sum)
}
```

Смотрите 'go help modules' для получения дополнительной информации о запросах модулей.


## go mod edit
редактирование go.mod из инструментов или скриптов

Использование:
```
go mod edit [editing flags] [go.mod]
```

Edit предоставляет интерфейс командной строки для редактирования go.mod, для использования в основном инструментами или скриптами. Он читает только go.mod; он не ищет информацию о задействованных модулях. По умолчанию edit читает и записывает файл go.mod основного модуля, но после флагов редактирования можно указать другой целевой файл.

Флаги редактирования определяют последовательность операций редактирования.

Флаг -fmt переформатирует файл go.mod без внесения других изменений. Это переформатирование также подразумевается любыми другими модификациями, которые используют или переписывают файл go.mod. Единственный раз, когда нужен этот флаг, это если другие флаги не указаны, как в 'go mod edit -fmt'.

Флаг -module изменяет путь к модулю (строка модуля файла go.mod).

Флаги -require=path@version и -droprequire=path добавляют и отбрасывают требование к указанному пути и версии модуля. Обратите внимание, что -require отменяет любые существующие требования к пути. Эти флаги в основном предназначены для инструментов, которые понимают граф модуля. Пользователи должны предпочесть 'go get path@version' или 'go get path@none', которые при необходимости выполняют другие корректировки go.mod для удовлетворения ограничений, накладываемых другими модулями.

Флаги -exclude=path@version и -dropexclude=path@version добавляют и удаляют исключение для заданного пути и версии модуля. Обратите внимание, что -exclude=path@version не допускается, если это исключение уже существует.

Флаги -replace=old[@v]=new[@v] и -dropreplace=old[@v] добавляют и удаляют замену указанного пути к модулю и пары версий. Если @v в old@v опущено, замена применяется ко всем версиям со старым путем к модулю. Если @v в new@v опущен, новый путь должен быть корневым каталогом локального модуля, а не путем к модулю. Обратите внимание, что -replace заменяет любые существующие замены для old[@v].

Флаги редактирования -require, -droprequire, -exclude, -dropexclude, -replace и -dropreplace могут быть повторены, и изменения применяются в указанном порядке.

Флаг -go=version устанавливает ожидаемую версию языка Go.

Флаг -print печатает окончательный вариант go.mod в текстовом формате, а не записывает его обратно в go.mod.

Флаг -json печатает конечный файл go.mod в формате JSON, а не записывает его обратно в go.mod. Вывод JSON соответствует этим типам Go:


```
type Module struct {
    Path string
    Version string
}

type GoMod struct {
    Module  Module
    Go      string
    Require []Require
    Exclude []Module
    Replace []Replace
}

type Require struct {
    Path string
    Version string
    Indirect bool
}

type Replace struct {
    Old Module
    New Module
}
```

Обратите внимание, что это описывает только сам файл go.mod, а не другие модули, на которые ссылаются косвенно. Для полного набора модулей, доступных для сборки, используйте 'go list -m -json all'.

Например, инструмент может получить go.mod как структуру данных, проанализировав выходные данные 'go mod edit -json', а затем может внести изменения, вызвав 'go mod edit' с -require, -exclude и так далее.



## go mod 
обеспечивает доступ к операциям над модулями.

Обратите внимание, что поддержка модулей встроена во все команды go, а не только в 'go mod'. Например, ежедневное добавление, удаление, обновление и понижение зависимостей должны выполняться с помощью 'go get'. См. 'go help modules' для обзора функциональности модуля.

Использование:
```
go mod <command> [arguments]
```

#### Команды (command):

```
download    скачать модули в локальный кеш
edit        редактировать go.mod из инструментов или скриптов
graph       напечатать граф требований модуля
init        инициализировать новый модуль в текущем каталоге
tidy        добавить отсутствующие и удалить неиспользуемые модули
vendor      делает вендорную копию зависимостей
verify      проверить зависимости ожидаемого содержания
why         объяснять, зачем нужны пакеты или модули
Используйте "go help mod <command>" для получения дополнительной информации о команде.
```

## go mod graph
распечатать граф требований модуля

Использование:
```
go mod graph
```

graph печатает граф требований модуля (с примененными заменами) в текстовом виде. Каждая строка в выходных данных имеет два поля, разделенных пробелами: модуль и одно из его требований. Каждый модуль идентифицируется как строка в форме path@version, за исключением основного модуля, у которого нет суффикса @version.


## go mod vendor
сделать вендорную копию зависимостей

Использование:
```
go mod vendor [-v]
```

vendor сбрасывает каталог поставщика (vendor directory) основного модуля, чтобы включить все пакеты, необходимые для сборки и тестирования всех пакетов основного модуля. Он не включает тестовый код для вендорных пакетов.

Флаг -v заставляет vendor печатать имена вендорных модулей и пакетов в вывод стандартной ошибки.


## go mod verify
проверка достоверности зависимостей

Использование:
```
go mod verify
```

verify проверяет, что зависимости текущего модуля, которые хранятся в локальном загруженном исходном кеше, не были изменены с момента загрузки. Если все модули не изменены, verify печает "all modules verified". В противном случае он сообщает, какие модули были изменены, и вызывает 'go mod' для выхода с ненулевым статусом.


## go mod why
объяснение необходимости пакета или модуля

Использование:
```
go mod why [-m] [-vendor] packages...
```
why показывает кратчайший путь на графе импорта из основного модуля к каждому из перечисленных пакетов. Если указан флаг -m, why обрабатывает аргументы как список модулей и находит путь к любому пакету в каждом из модулей.

По умолчанию, why запрашивает граф пакетов, сопоставленных с "go list all", который включает в себя тесты для достижимых пакетов. Флаг -vendor вызывает необходимость исключать проверки зависимостей.

Выходные данные представляют собой последовательность разделов, по одному для каждого имени пакета или модуля в командной строке, разделенных пустыми строками. Каждый раздел начинается со строки комментария "# package" или "# module", в которой указан целевой пакет или модуль. Последующие строки дают путь через граф импорта, один пакет на строку. Если на пакет или модуль не ссылаются из основного модуля, раздел отображает одну заключенную в скобки заметку с указанием этого факта.

Например:
```
$ go mod why golang.org/x/text/language golang.org/x/text/encoding
# golang.org/x/text/language
rsc.io/quote
rsc.io/sampler
golang.org/x/text/language

# golang.org/x/text/encoding
(main module does not need package golang.org/x/text/encoding)
$
```

