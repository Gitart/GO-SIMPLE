Добро пожаловать в первое руководство из этой новой серии по созданию инструментов безопасности в Go! 
В этом руководстве мы собираемся создать очень крутой сканер портов, который вы сможете указать на сервер и исследовать любые потенциальные уязвимости.

Это даст нам хорошее представление о том, что такое сканирование портов и почему мы должны знать, какие порты мы оставляем открытыми на любой из машин, на которых мы запускаем наши приложения.

## Видеоурок

Если хотите, это руководство также доступно в видеоформате на моем канале YouTube:

## Что такое сканирование портов?

Сканирование портов является актом итерация в каждом порту на компьютере и проверять, какие из них `Open` , `Closed` или `Filtered` .

В общей сложности на типичной машине имеется чуть более **130 000 портов** , **65 535 из `TCP`** **которых являются `UDP` портами,** а **остальные 65 535 -** **портами** . Каждый из этих портов может эффективно стать входом в вашу систему, если оставить его открытым, а сканирование портов позволит инженерам по безопасности увидеть, есть ли какие-либо потенциальные способы получить доступ к вашей системе из незащищенного программного обеспечения.

Вопрос

## Какие порты используют HTTP и HTTPS?

А 22 и 443 B 21 и 22 C 80 и 443

### Почему мы должны заботиться?

Это один из самых серьезных нарушителей, когда дело доходит до определения того, как произошло нарушение безопасности. Эти нарушения безопасности могут быть вызваны сочетанием того, что порты остаются открытыми, и недостаточно регулярно обновляются службы, работающие за этими портами.

Однако есть несколько разных способов защитить себя от этих проблем с безопасностью. Простой акт запуска сервисов в изолированной сетевой зоне, такой как частный VPC AWS, может значительно улучшить состояние безопасности вашего приложения, поскольку это означает, что только машины в этом VPC могут связываться с вашим сервером.

Имея это в виду, давайте перейдем к коду и посмотрим, как мы можем реализовать наш собственный простой инструмент сканирования портов на Go, который может помочь нам лучше оценить системы, которые мы разрабатываем и развертываем, на предмет любых уязвимостей безопасности.

## Сканирование порта в Go

Давайте посмотрим, как мы реализуем простую функцию сканирования портов в Go с помощью `net` пакета.

Мы начнем с создания `scanPort` функции , которая будет принимать в `protocol` , `hostname` и `port` и возвращают логическое определение того или нет , что особенно `port` было оставлено открытым:

main.go

```go
package main

import (
	"fmt"
	"net"
	"strconv"
	"time"
)

func scanPort(protocol, hostname string, port int) bool {
	address := hostname + ":" + strconv.Itoa(port)
	conn, err := net.DialTimeout(protocol, address, 60*time.Second)

	if err != nil {
		return false
	}
	defer conn.Close()
	return true
}

func main() {
	fmt.Println("Port Scanning")
	open := scanPort("tcp", "localhost", 1313)
	fmt.Printf("Port Open: %t\n", open)
}

```

В настоящее время я запускаю свой сайт, который является **сервером hugo** на порту 1313, поэтому, когда я запустил его, я должен был ожидать, что этот порт открыт и принимает входящие запросы, но давайте проверим эту теорию:

иди, беги main.go

```output
Port Scanning
Port Open: true

```

Если мы попытаемся **подключиться** к одному из нижних портов в диапазоне портов **1–1024** на нашей машине, мы должны увидеть, что он возвращается, `false` поскольку они обычно заблокированы по умолчанию или назначены службам, которые не принимают соединения на этих портах.

## Первое сканирование - нижние диапазоны портов

Нижний предел диапазона портов от 1 до 1024 - это хорошо известные порты, которые были предварительно выделены для различных служб, таких как HTTP `Port 80` , SSH `Port 22` или FTP, и `Port 21` это лишь некоторые из них.

Давайте расширим наше невероятно простое приложение для сканирования портов, указанное выше, и расширим его, чтобы перебирать нижние 1024 порта, чтобы попытаться найти открытое TCP-соединение.

Сначала мы хотим инициализировать этот проект с помощью `go mod init` команды и передать имя репозитория. Для целей этого руководства я создал [репозиторий](https://github.com/elliotforbes/athena) github: [elliotforbes / athena, для](https://github.com/elliotforbes/athena) которого я впоследствии инициализировал этот проект Go:

```output
$ go mod init github.com/elliotforbes/athena

```

Давайте начнем с создания новой папки с именем, `port/` и в ней мы создадим новый `.go` файл с именем `port.go` . Мы переместим `ScanPort` функцию из нашего `main.go` файла выше в этот новый файл и сделаем функцию заглавной, чтобы мы могли получить к ней доступ извне пакета.

Мы также `ScanResult` создадим структуру, которая будет содержать `port` и состояние, которое будет иметь тип `string` :

порт / port.go

```go
package port

import (
	"net"
	"strconv"
	"time"
)

type ScanResult struct {
	Port  int
	State string
}

func ScanPort(protocol, hostname string, port int) ScanResult {
	result := ScanResult{Port: port}
	address := hostname + ":" + strconv.Itoa(port)
	conn, err := net.DialTimeout(protocol, address, 60*time.Second)

	if err != nil {
		result.State = "Closed"
		return result
	}
	defer conn.Close()
	result.State = "Open"
	return result
}

func InitialScan(hostname string) []ScanResult {

	var results []ScanResult

	for i := 0; i <= 1024; i++ {
		results = append(results, ScanPort("tcp", hostname, i))
	}

	return results
}

```

Давайте обновим наш `main.go` файл, чтобы он импортировал наш недавно созданный `port` пакет и вызвал новую определенную `InitialScan` функцию, которая будет перебирать все **нижние 1024 порта** на хосте и пытаться открыть TCP-соединение на этих портах:

main.go

```go
package main

import (
	"fmt"

	"github.com/elliotforbes/athena/port"
)

func main() {
	fmt.Println("Port Scanning")
	results := port.InitialScan("localhost")
	fmt.Println(results)
}

```

Теперь, когда мы запустим это, мы должны увидеть, что наша программа уходит и пытается открыть TCP-соединение с нижними 1024 портами на нашей `localhost` машине.

Надеюсь, если вы запустите это на своем локальном компьютере, вы увидите, что в настоящее время нет портов в `Open` состоянии.

## Запуск UDP-сканирования

Теперь, когда у нас есть средства сканирования портов в нашей `ScanPort` функции, мы можем легко расширить наше приложение сканирования `UDP` портов, чтобы также сканировать нижние порты, добавив дополнительный цикл в нашу `InitialScan` функцию, например:

порт / port.go

```go
package port

import (
	"net"
	"strconv"
	"time"
)

type ScanResult struct {
	Port    string
	State   string
	Service string
}

func ScanPort(protocol, hostname string, port int) ScanResult {
	result := ScanResult{Port: strconv.Itoa(port) + string("/") + protocol}
	address := hostname + ":" + strconv.Itoa(port)
	conn, err := net.DialTimeout(protocol, address, 60*time.Second)

	if err != nil {
		result.State = "Closed"
		return result
	}
	defer conn.Close()
	result.State = "Open"
	return result
}

func InitialScan(hostname string) []ScanResult {

	var results []ScanResult

	for i := 0; i <= 1024; i++ {
		results = append(results, ScanPort("udp", hostname, i))
	}

	for i := 0; i <= 1024; i++ {
		results = append(results, ScanPort("tcp", hostname, i))
	}

	return results
}

```

Мы также сделали некоторые незначительные изменения в нашу `ScanResult` структуру и изменили `Port` иметь тип строки , так что мы можем хранить `port/protocol` легко , как так: `80/tcp` .

Теперь, когда мы управляем этим, наш порт-сканер будет работать через нижнюю 1024 и проверять как `TCP` и `UDP` порты и вывода результатов!

## Типы сканирования портов

В приведенном выше примере мы рассматриваем исключительно то, как сканировать порт TCP Connect на машине. Это нормально для начала, однако вы должны отметить, что иногда это может сигнализировать системе безопасности о том, что происходит потенциальный взлом.

При реализации более сложного инструмента сканирования портов следует отметить, что существует ряд других методов, которые также могут быть использованы, каждый из которых имеет свои преимущества и недостатки.

Вот некоторые из наиболее распространенных техник:

*   **Ping Scan** \- отправляет пинг и ожидает ответа.

*   **TCP Half-Open** \- также известный как `SYN` сканирование, это сканирование пытается запустить TCP-соединение, прослушивать `SYN-ACK` ответ, а затем никогда не отправить окончательный `ACK` .

*   **TCP Open** \- это просто попытка открыть TCP-соединение на хосте: порт, как мы сделали выше.

*   **UDP** \- очень похоже на сканирование TCP, за исключением использования протокола UDP.

*   **Скрытое сканирование** \- гораздо более сложный тип сканирования, который был разработан таким образом, чтобы эти сканирования не отображались в журналах подключений.

> **Задача** \- взгляните на [https://github.com/tatsushid/go-fastping](https://github.com/tatsushid/go-fastping) и импортируйте его в свой проект. Расширьте `port` пакет, включив в него функцию запуска сканирования портов ICMP в новой функции.

## Расширенное сканирование портов

Мы рассмотрели, как выполнить начальное сканирование, которое охватывает первые 1024 порта на машине как для UDP, так и для TCP. Однако, если на этих портах нет очевидных служб, которые были оставлены открытыми, то следующим шагом обычно является расширение сканирования до первых 49151 портов, которые представляют собой список зарегистрированных портов.

**Причина, по которой мы не просто сканируем все 65535 портов с самого начала,** заключается в том, что сканирование портов обычно занимает много времени, и его использование с различными уровнями сканирования может помочь сократить время, необходимое для проникновения в систему. .

Теперь мы собираемся расширить наш `athena` проект, чтобы он выполнял более широкое сканирование, создав `WideScan` функцию в нашем `port` пакете:

порт / port.go

```go
package port

import (
	"net"
	"strconv"
	"time"
)

type ScanResult struct {
	Port    string
	State   string
	Service string
}

func ScanPort(protocol, hostname string, port int) ScanResult {
	result := ScanResult{Port: strconv.Itoa(port) + string("/") + protocol}
	address := hostname + ":" + strconv.Itoa(port)
	conn, err := net.DialTimeout(protocol, address, 60*time.Second)

	if err != nil {
		result.State = "Closed"
		return result
	}
	defer conn.Close()
	result.State = "Open"
	return result
}

func InitialScan(hostname string) []ScanResult {

	var results []ScanResult

	for i := 0; i <= 1024; i++ {
		results = append(results, ScanPort("udp", hostname, i))
	}

	for i := 0; i <= 1024; i++ {
		results = append(results, ScanPort("tcp", hostname, i))
	}

	return results
}

func WideScan(hostname string) []ScanResult {
	var results []ScanResult

	for i := 0; i <= 49152; i++ {
		results = append(results, ScanPort("udp", hostname, i))
	}

	for i := 0; i <= 49152; i++ {
		results = append(results, ScanPort("tcp", hostname, i))
	}

	return results
}

```

Имея эту новую `WideScan` функцию, мы можем расширить нашу `main` функцию для вызова этой экспортированной функции из `port` пакета следующим образом:

main.go

```go
package main

import (
	"fmt"

	"github.com/elliotforbes/athena/port"
)

func main() {
	fmt.Println("Port Scanning")
	results := port.InitialScan("localhost")
	fmt.Println(results)

	widescanresults := port.WideScan("localhost")
	fmt.Println(widescanresults)

}

```

Попробуйте запустить это сейчас и посмотрите, сколько времени потребуется, даже на моем мощном Macbook Pro, подключение к `localhost` которому занимает довольно много времени. Если бы мы нацеливались на сервер в другой стране или на другом континенте, нам также пришлось бы учитывать сетевую задержку, которая значительно увеличила бы время, необходимое для выполнения этого сканирования.

## Повышение производительности с помощью горутин

В настоящее время у нас есть синхронная система, которая будет проходить через все порты один за другим и проверять, открыты ли они. Однако мы можем значительно улучшить производительность нашей системы, введя `goroutines` и заставив сканирование портов выполняться одновременно.

> **Задача** \- Повысьте производительность с помощью `goroutines` , a `sync.Mutex` и `sync.WaitGroup` так, чтобы система выполняла эти сканирования параллельно.
>
> *   [Учебник по Go Goroutines](https://tutorialedge.net/golang/concurrency-with-golang-goroutines/)
>
> *   [Учебное пособие по Go Mutex](https://tutorialedge.net/golang/go-mutex-tutorial/)
>
> *   [Перейти к уроку WaitGroup](https://tutorialedge.net/golang/go-waitgroup-tutorial/)
>

## Заключение

Итак, в этом руководстве мы рассмотрели технику сканирования портов и то, как ее можно использовать для проверки различных серверов на предмет потенциальных уязвимостей. С этим новым пониманием этой техники мы затем применили теорию на практике и построили невероятно крутой сканер портов на основе Go, который мы можем использовать в наших собственных повседневных тестах безопасности!

Надеюсь, вы нашли этот урок полезным! Если вам понравилось это или у вас есть отзывы, я хотел бы услышать ваши мысли в разделе комментариев ниже!
