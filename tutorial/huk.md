Перехватчики Git - довольно мощный способ улучшить рабочий процесс разработки без необходимости запоминать запуск дополнительных скриптов или выполнение дополнительных задач. В этой статье мы рассмотрим, как вы можете определить свои собственные простые хуки git в репозитории проекта, которые могут автоматически выполнять задачу линтинга + форматирования вашего кода Go.

Этот довольно простой пример должен дать вам представление о том, как вы можете использовать хуки git для своих собственных коварных планов.

## Пример из реальной жизни

Одним из примеров этого является один из моих текущих проектов, где команде пришлось зашифровать файлы секретов до того, как они были отправлены в репозиторий проекта. Шифрование файла было простым однострочником, но из-за большого количества зашифрованных файлов, с которыми мы работали, стало проблемой не забыть зашифровать каждый файл, который был изменен, и чаще всего мы запускали наш проект и чесали в затылке пока мы пытались выяснить, почему он не собирал новые секреты.

### Решение

Когда дело дошло до попытки решить эту проблему, мы были довольно ограничены в инструментах, которые могли использовать, и не хотели использовать что-то, что могло бы повлиять на текущий процесс разработки для людей в команде, у которых были свои предпочтения.

Здесь в игру вступили хуки git. С помощью хуков я мог определить простой `pre-commit` скрипт ловушки, который автоматически выполнял бы задачу шифрования любых незашифрованных файлов и добавления их в коммит. Я также мог бы сделать это дополнительным дополнением к `hooks/` процессу разработки команды, создав эти хуки в каталоге, чтобы, если они захотят добавить эти хуки git в свой рабочий процесс, они могли бы с помощью простой `git config core.hooksPath hooks` команды.

## Создание хука Git

Хуки на самом деле удивительно просты в создании, поскольку они представляют собой просто сценарии bash, которые имеют определенные имена в определенном каталоге. Когда вы в следующий раз выполните данную `git` команду, она автоматически выполнит этот сценарий bash при условии, что это файл с правильным именем для этой конкретной команды.

Если вы хотите создать хуки git только для вашего конкретного проекта на вашем компьютере, вы можете сделать это, перейдя в каталог текущего проекта, а затем в `.git/hooks/` каталог внутри этого проекта.

Если вы просмотрите содержимое этого каталога, вы должны увидеть что-то вроде этого:

```output
31/07/2019  22:09               478 applypatch-msg.sample
31/07/2019  22:09               896 commit-msg.sample
31/07/2019  22:09             3,327 fsmonitor-watchman.sample
31/07/2019  22:09               189 post-update.sample
31/07/2019  22:09               424 pre-applypatch.sample
31/07/2019  22:09             1,642 pre-commit.sample
31/07/2019  22:09             1,348 pre-push.sample
31/07/2019  22:09             4,898 pre-rebase.sample
31/07/2019  22:09               544 pre-receive.sample
31/07/2019  22:09             1,492 prepare-commit-msg.sample
31/07/2019  22:09             3,610 update.sample

```

Каждый из них содержит примеры хуков git, которые вы можете включить, просто переименовав файлы и удалив `.sample` окончания файлов.

Файл, который нас интересует в рамках данной статьи, - это `pre-commit` файл.

В этом же каталоге давайте создадим новый файл с именем `pre-commit` и добавим в него следующее:

```bash
#!/bin/bash

echo "Test Hook"

```

> Если вы работаете на Mac или Linux, вам нужно будет установить исполняемый бит для этого скрипта, используя `chmod` . В Windows это должно работать прямо из коробки!

```bash
chmod +x pre-commit

```

С этим набором попробуйте сделать пустую фиксацию, чтобы проверить это:

```bash
git commit --allow-empty -m "Testing Git Hook"

```

Когда вы запустите это, вы должны увидеть, что `"Test Hook"` это распечатано непосредственно перед тем, как git выполнит `commit` команду.

Потрясающие! Вы успешно создали свой собственный хук git! Теперь это будет выполняться каждый раз, когда вы что-то фиксируете в данном репозитории.

## Улучшение нашего Git Hook

Итак, мы смогли успешно создать наш первый хук git, теперь пора начать улучшать его, чтобы он действительно выполнял для нас полезную задачу, а не просто эхо некоторого текста.

Начнем с того, что добавим в этот скрипт немного го линтинга:

```bash
#!/bin/bash

echo "Test Hook"

## this will retrieve all of the .go files that have been
## changed since the last commit
STAGED_GO_FILES=$(git diff --cached --name-only -- '*.go')

## we can check to see if this is empty
if [[ $STAGED_GO_FILES == "" ]]; then
    echo "No Go Files to Update"
## otherwise we can do stuff with these changed go files
else
    for file in $STAGED_GO_FILES; do
        echo $file
    done
fi

```

Имея это место, попробуйте изменить `.go` файл в своем проекте и попытаться `git add -A` подписаться на `git commit -m "Some Message"` .

Теперь вы увидите , что только ниже нашего `"Test Hooks"` нашего `pre-commit` крючка теперь распечатывания путь к файлу , который был изменен.

$ git commit -m "Тестовая фиксация"

```output
Test Hook
test.go
[master 82ab8c6] test
 1 file changed, 2 insertions(+)

```

Aweomse, так что он может видеть, что мы обновили `.go` файл в нашем каталоге проекта, и мы можем вывести этот файл в нашем `for` цикле. Давайте расширим нашу ловушку git, чтобы автоматически форматировать этот файл для нас всякий раз, когда мы фиксируем:

.git / крючки / предварительная фиксация

```bash
#!/bin/bash

echo "Test Hook"

## this will retrieve all of the .go files that have been
## changed since the last commit
STAGED_GO_FILES=$(git diff --cached --name-only -- '*.go')

## we can check to see if this is empty
if [[ $STAGED_GO_FILES == "" ]]; then
    echo "No Go Files to Update"
## otherwise we can do stuff with these changed go files
else
    for file in $STAGED_GO_FILES; do
        ## format our file
        go fmt $file
        ## add any potential changes from our formatting to the
        ## commit
        git add $file
    done
fi

```

Теперь, когда мы переходим к сохранению любого из наших файлов, а затем добавляем и затем фиксируем их, они будут автоматически отформатированы для нас, и любые изменения, внесенные форматированием, будут автоматически добавлены к данной фиксации:

git add -A

```output
C:\Projects\test>git status
On branch master

        modified:   main.go

```

git commit -m "Обновления"

```output
Test Hook
main.go
main.go
[master 61e6ed4] Updates

```

Потрясающие! Теперь мы можем создать ловушку git, которая автоматически улучшает наш рабочий процесс разработки Go и гарантирует, что все, что мы фиксируем, является правильно отформатированным кодом!

## Распространение хуков Git между командами

Теперь, к сожалению, изменения, которые мы внесли в `hooks/` каталог в каталоге нашего проекта, `.git/` не будут отслеживаться, и поэтому донести эти изменения до различных членов вашей команды становится непросто.

Однако что вы можете сделать, чтобы обойти эту конкретную проблему, - это создать каталог, называемый `.githooks/` в каталоге вашего текущего проекта, и сохранить `pre-commit` в этом каталоге обработчик git. Вы сможете фиксировать и отслеживать это так же, как и любые другие файлы в вашем проекте, и для того, чтобы включить эти хуки на других машинах разработки, вам просто нужно запустить эту команду:

```output
$ git config core.hooksPath .githooks

```

После того, как вы выполнили эту конкретную команду, вы должны теперь увидеть, что всякий раз, когда вы пытаетесь что-то зафиксировать, теперь включены хуки, предоставленные в этом каталоге!

## Заключение

Замечательно, поэтому в этом руководстве мы рассмотрели, как можно улучшить рабочий процесс разработки Go, используя хуки git в сочетании с существующими инструментами, например, `go fmt` чтобы гарантировать, что все, что вы фиксируете в своих репозиториях, было правильно отформатировано!

Это лишь небольшая часть того, чего вы можете достичь с помощью хуков git, и, надеюсь, он даст вам некоторые идеи относительно того, как вы можете развить их дальше! Если у вас есть идеи или примеры того, как вы улучшили этот рабочий процесс, я хотел бы услышать о них в разделе комментариев ниже!
