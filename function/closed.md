# Функции и закрытия в Go

###  Письмо функционных параметров и возврата
Если есть несколько параметров, это тот же тип, он может быть записан:

```go
func testReturnFunc(v1,v2 int)(int,int)  {
	x1 := 2 * v1
	x2 := 3 * v2
	return x1,x2
}

```

Go также поддерживает наименование возвращаемого значения. Возвращение имени значения инициализировано для соответствующего типа нулевого значения. Когда вам нужно вернуть, нам нужно только простое оператор возврата:

```go
func testReturnFunc1(v int)(x1,x2 int)  {
	x1 = 2 * v
	x2 = 3 * v
	return
}

```
Функция возвращает два значения X1 и X2, если X1, X2 не назначается в функции, то будет возвращено значение по умолчанию этих двух параметров.

###  Как изменить переменные вне функции

Используя нами указатель, получите внешний указатель параметра, который включен в параметр, который назначает значение указателя на значение указателя на адрес памяти, соответствующую соответствующей переменной:

```go
func multiply(a,b int,reply *int)  {
	*reply = a *b
}

func main() {
	num := 0
	reply := &num
	multiply(3,5,reply)
	fmt.Println("return num :",*reply,num)
}
```

Выход:
```
return num : 15 15

```

###  Используйте функцию в качестве параметра

Функция может быть передана в качестве параметра других функций, а затем выполнение вызывается в других функциях, обычно называемых обратными вызовами.

```go
package main
import "fmt"

func main() {
	callback(4,add)
}
func add(a,b int)  {
	fmt.Print(a+b)
}
func callback(c int, f func(int, int))  {
	f(c,c)
}
```

 Выход:
``` 
8
```

Я понимаю этот способ обратного вызова, используя сцену в виде цепочки вызовов между несколькими методами, следующий метод опирается на некоторые из предыдущих методов, эквивалентный обратным вызове, является первым способом, добавление является вторым методом. полагаться на некоторые промежуточные значения в методе обратного вызова.

### Анонимная функция - закрытая сумка

Язык Go поддерживает анонимную функцию, то есть функция может быть передана или использована в качестве обычной переменной.

```go
i2 := func(x, y int) int { return x + y }(1,2)

```

Как указано выше, определена анонимная функция, включая два параметра x, y. Возвращает результат x + y. Следующее () указывает параметры, параметры X = 1, y = 2.

Конечно, вы также можете определить анонимные функции, не применяйте, подождите, когда вам нужно использовать, вы можете использовать модифицированные параметры, как вы можете:

```go
i2 := func(x, y int) int { return x + y }
i3 := i2(x, y)

```

## Разница между двумя способами, где находится параметр (X, Y).

Анонимная функция и закрытие в языке Go - это концепция:

Закрытие - это код кода, который может содержать бесплатные (не связанные с определенными объектами) переменными, которые не определены в этом блоке кода или в любом глобальном контексте, но определяют в среде, где определен код кода. Блок кода, который должен быть выполнен (поскольку бесплатная переменная включена в блок кода, эти бесплатные переменные и объект, который они ссылаются, не выделяются) предоставляют бесплатную переменную для обеспечения привязки вычислительной среды (область объема).

Значение замыкания значения замыкания состоит в том, что его можно использовать в качестве объекта функции или анонимной функции. Для систем типа это означает не только для указания того, что данные также указывают на код. Большинство языков, которые поддерживают функции использования, используемые в качестве первого уровня, то есть эти функции могут храниться в качестве параметров для других функций в переменных, а главное, могут быть динамически созданы и возвращены.

Закрытие на языке Go также ссылается на переменные вне функции. Реализация замыкания гарантирует, что переменные, которые закрывают ссылку, всегда существуют до тех пор, пока также используется закрытие.

Смотрим на сложный пример:

```go
func test()  {
	a := 5
	b := func()(func()){
		c := 10
		return func() {
			fmt.Printf("a,c: %d,%d \n",a,c)
			a *= 3
		}
	}()
	b()
	println(a)
}
 Выход:
a,c: 5,10
15

```

###  объяснение:

Возвращаемое значение анонимной функции является анонимная функция, возвращающаяся является анонимная функция, обращая внимание на не добавлять (), поэтому она получена с возвратом.

Затем он добавляется () в внешнем слое. Так что дайте ценность анонимной функции в B. Обратите внимание, что B на самом деле функция. Так что ниже b (). Вы можете попытаться удалить внешний слой анонимной функции, затем посмотрите на значение печати B (), какое значение B () () напечатано.

Кроме того, A может быть ссылаться в анонимной функции, но если вы ссылаетесь на внешнюю анонимную функцию, вы найдете ее. И значение изменения A в замкнутой сумке также действует в реальном адресе памяти.
