# Функции первого класса

13 мая 2021 г.

![Функции первого класса Golang](https://golangbot.com/content/images/2018/03/first-class-functions-golang.png)

Добро пожаловать в учебник №. 34 в серии руководств по [Голангу](https://golangbot.com/learn-golang-series/) .

### Что такое функции первого класса?

**Язык, поддерживающий функции первого класса, позволяет присваивать функции переменным, передавать их в качестве аргументов другим функциям и возвращать из других функций. Go поддерживает функции первого класса.**

В этом руководстве мы обсудим синтаксис и различные варианты использования функций первого класса.

### Анонимные функции

Давайте начнем с простого примера, который присваивает [функцию](https://golangbot.com/functions/) [переменной](https://golangbot.com/variables/) .

```go
package main

import (
    "fmt"
)

func main() {
    a := func() {
        fmt.Println("hello world first class function")
    }
    a()
    fmt.Printf("%T", a)
}

```

[Бегать на детской площадке](https://play.golang.org/p/Xm_ihamhlEv )

В приведенной выше программе мы присвоили функцию переменной `a` в строке №. 8\. Это синтаксис для назначения функции переменной. Если вы внимательно заметите, назначенная функция `a` не имеет имени. **Такие функции называются анонимными, поскольку у них нет имени.**

Единственный способ вызвать эту функцию — использовать переменную `a` . Мы сделали это в следующей строке. `a()` вызывает функцию, и это печатает `hello world first class function` . В строке нет. `a` 12 мы печатаем тип переменной . Это будет печатать `func()` .

Запуск этой программы напечатает

```
hello world first class function
func()

```

Также возможно вызвать анонимную функцию, не присваивая ее переменной. Давайте посмотрим, как это делается на следующем примере.

```go
package main

import (
    "fmt"
)

func main() {
    func() {
        fmt.Println("hello world first class function")
    }()
}

```

[Бегать на детской площадке](https://play.golang.org/p/c0AjB3g8UEn )

В приведенной выше программе анонимная функция определена в строке №. 8 и сразу после определения функции мы вызываем функцию, используя `()` строку №. 10\. Эта программа выведет,

```
hello world first class function

```

Также можно передавать аргументы анонимным функциям, как и любой другой функции.

```go
package main

import (
    "fmt"
)

func main() {
    func(n string) {
        fmt.Println("Welcome", n)
    }("Gophers")
}

```

[Бегать на детской площадке](https://play.golang.org/p/9ttJ5Wi4fj4 )

В приведенной выше программе строковый аргумент передается анонимной функции в строке №. 10\. Запуск этой программы распечатает,

```
Welcome Gophers

```

### Пользовательские типы функций

Точно так же, как мы определяем наши собственные типы [структур](https://golangbot.com/structs/#declaringastructure) , можно определить наши собственные типы функций.

```go
type add func(a int, b int) int

```

Приведенный выше фрагмент кода создает новый тип функции, `add` который принимает два целочисленных аргумента и возвращает целое число. Теперь мы можем определить переменные типа `add` .

Напишем программу, определяющую переменную типа `add` .

```go
package main

import (
    "fmt"
)

type add func(a int, b int) int

func main() {
    var a add = func(a int, b int) int {
        return a + b
    }
    s := a(5, 6)
    fmt.Println("Sum", s)
}

```

[Бегать на детской площадке](https://play.golang.org/p/n3yPQ7hG7ip )

В приведенной выше программе в строке № 10 мы определяем переменную `a` типа `add` и присваиваем ей функцию, сигнатура которой соответствует типу `add` . Мы вызываем функцию в строке №. 13 и присвоить результат `s` . Эта программа будет печатать,

```
Sum 11

```

### Функции высшего порядка

Определение функции высшего порядка из [вики](https://en.wikipedia.org/wiki/Higher-order_function ) — **это функция, которая выполняет хотя бы одно из следующих действий:**

*   **принимает одну или несколько функций в качестве аргументов**
*   **возвращает функцию как результат**

Давайте рассмотрим несколько простых примеров для двух описанных выше сценариев.

#### Передача функций в качестве аргументов другим функциям

```go
package main

import (
    "fmt"
)

func simple(a func(a, b int) int) {
    fmt.Println(a(60, 7))
}

func main() {
    f := func(a, b int) int {
        return a + b
    }
    simple(f)
}

```

[Бегать на детской площадке](https://play.golang.org/p/C0MNwz2TSGU)

В приведенном выше примере в строке №. 7 мы определяем функцию, `simple` которая принимает *функцию, принимающую два аргумента типа int, и возвращает целое число* в качестве параметра. Внутри основной функции в строке нет. 12 мы создаем анонимную функцию `f` , сигнатура которой совпадает с параметром функции `simple` . Мы вызываем `simple` и передаем `f` в качестве аргумента ему в следующей строке. Эта программа выводит `67` на печать.

#### Возврат функций из других функций

Теперь давайте перепишем программу выше и вернем функцию из `simple` функции.

```go
package main

import (
    "fmt"
)

func simple() func(a, b int) int {
    f := func(a, b int) int {
        return a + b
    }
    return f
}

func main() {
    s := simple()
    fmt.Println(s(60, 7))
}

```

[Бегать на детской площадке](https://play.golang.org/p/82y2caejUy8 )

В приведенной выше программе простая функция в строке № 7 возвращает функцию, которая принимает два `int` аргумента и возвращает `int` аргумент.

Эта простая функция вызывается из строки №. 15\. Возвращаемое значение из simple присваивается `s` . Теперь `s` содержит функцию, возвращаемую `simple` функцией. Мы вызываем `s` и передаем ему два аргумента int в строке №. 16\. Эта программа выводит `67` .

### Закрытия

Замыкания — это частный случай анонимных функций. Замыкания — это анонимные функции, которые обращаются к переменным, определенным вне тела функции.

Пример прояснит ситуацию.

```go
package main

import (
    "fmt"
)

func main() {
    a := 5
    func() {
        fmt.Println("a =", a)
    }()
}

```

[Бегать на детской площадке](https://play.golang.org/p/6QriMs-zbnf)

В приведенной выше программе анонимная функция обращается к переменной `a` , которая присутствует вне ее тела в строке №. 10\. Следовательно, эта анонимная функция является замыканием.

Каждое замыкание связано со своей собственной переменной окружения. Давайте разберемся, что это значит, на простом примере.

```go
package main

import (
    "fmt"
)

func appendStr() func(string) string {
    t := "Hello"
    c := func(b string) string {
        t = t + " " + b
        return t
    }
    return c
}

func main() {
    a := appendStr()
    b := appendStr()
    fmt.Println(a("World"))
    fmt.Println(b("Everyone"))

    fmt.Println(a("Gopher"))
    fmt.Println(b("!"))
}

```

[Работать в фоновом режиме](https://play.golang.org/p/134NiQGPOcS)

В приведенной выше программе функция `appendStr` возвращает замыкание. Это замыкание привязано к переменной `t` . Давайте разберемся, что это значит.

Переменные `a` и `b` объявленные в строке №. 17, 18 являются замыканиями и привязаны к своему собственному значению `t` .

Сначала мы вызываем `a` с параметром `World` . Теперь значение `a` версии `t` становится равным `Hello World` .

В строке нет. 20 вызываем `b` с параметром `Everyone` . Так `b` как он привязан к своей собственной переменной `t` , `b` версия `t` имеет начальное значение `Hello` снова. Следовательно, после вызова этой функции значение `b` версии t становится равным `Hello Everyone` . Остальная часть программы говорит сама за себя.

Эта программа будет печатать,

```
Hello World
Hello Everyone
Hello World Gopher
Hello Everyone !

```

### Практическое использование первоклассных функций

До сих пор мы определили, что такое функции первого класса, и рассмотрели несколько надуманных примеров, чтобы узнать, как они работают. Теперь давайте напишем конкретную программу, демонстрирующую практическое использование первоклассных функций.

Мы создадим программу, которая фильтрует [часть](https://golangbot.com/arrays-and-slices/) студентов по некоторым критериям. Давайте подойдем к этому шаг за шагом.

Сначала давайте определим тип студента.

```go
type student struct {
    firstName string
    lastName string
    grade string
    country string
}

```

Следующим шагом будет написание `filter` функции. Эта функция принимает в качестве параметров срез студентов и функцию, которая определяет, соответствует ли студент критериям фильтрации. Мы поймем лучше, когда напишем эту функцию. Давайте продолжим и сделаем это.

```go
func filter(s []student, f func(student) bool) []student {
    var r []student
    for _, v := range s {
        if f(v) == true {
            r = append(r, v)
        }
    }
    return r
}

```

В приведенной выше функции второй параметр to `filter` — это функция, которая принимает a `student` в качестве параметра и возвращает a `bool` . Эта функция определяет, соответствует ли конкретный студент критериям или нет. Мы повторяем фрагмент студента в строке №. 3 и и мы передаем каждого ученика в качестве параметра функции `f` . Если это возвращается `true` , это означает , что учащийся прошел критерии фильтрации и он добавлен в срез `r` . Возможно, вас немного смущает реальное использование этой функции, но все станет ясно, как только мы закончим программу. Я добавил основную функцию и предоставил полную программу ниже.

```go
package main

import (
    "fmt"
)

type student struct {
    firstName string
    lastName  string
    grade     string
    country   string
}

func filter(s []student, f func(student) bool) []student {
    var r []student
    for _, v := range s {
        if f(v) == true {
            r = append(r, v)
        }
    }
    return r
}

func main() {
    s1 := student{
        firstName: "Naveen",
        lastName:  "Ramanathan",
        grade:     "A",
        country:   "India",
    }
    s2 := student{
        firstName: "Samuel",
        lastName:  "Johnson",
        grade:     "B",
        country:   "USA",
    }
    s := []student{s1, s2}
    f := filter(s, func(s student) bool {
        if s.grade == "B" {
            return true
        }
        return false
    })
    fmt.Println(f)
}

```

[Бегать на детской площадке](https://play.golang.org/p/YUL1CqSrvfc)

В основной функции мы сначала создаем двух учеников `s1` и `s2` добавляем их в slice `s` . Теперь предположим, что мы хотим узнать всех учеников, у которых есть оценка `B` . Мы установили это в приведенной выше программе, передав функцию, которая проверяет, есть ли у ученика оценка, `B` и если да, то возвращает true в качестве параметра `filter` функции в строке №. 38\. Приведенная выше программа напечатает,

```
[{Samuel Johnson B USA}]

```

Допустим, мы хотим найти всех студентов из Индии. Это можно легко сделать, изменив параметр функции на функцию фильтра.
Я предоставил код, который делает это ниже,

```go
c := filter(s, func(s student) bool {
    if s.country == "India" {
        return true
    }
    return false
})
fmt.Println(c)

```

Пожалуйста, добавьте это в основную функцию и проверьте вывод.

Давайте закончим этот раздел, написав еще одну программу. Эта программа выполнит те же операции над каждым элементом среза и вернет результат. Например, если мы хотим умножить все целые числа в срезе на 5 и вернуть результат, это можно легко сделать с помощью функций первого класса. Такие виды функций, которые работают с каждым элементом коллекции, называются `map` функциями. Я предоставил программу ниже. Это не требует пояснений.

```go
package main

import (
    "fmt"
)

func iMap(s []int, f func(int) int) []int {
    var r []int
    for _, v := range s {
        r = append(r, f(v))
    }
    return r
}
func main() {
    a := []int{5, 6, 7, 8, 9}
    r := iMap(a, func(n int) int {
        return n * 5
    })
    fmt.Println(r)
}

```

[Бегать на детской площадке](https://play.golang.org/p/cs37QwCQ_0H)

Вышеупомянутая программа будет печатать,

```
[25 30 35 40 45]

```

Вот краткий обзор того, что мы узнали в этом уроке,

*   Что такое функции первого класса?
*   Анонимные функции
*   Пользовательские типы функций
*   Функции высшего порядка
    *   Передача функций в качестве аргументов другим функциям
    *   Возврат функций из других функций
*   Закрытия
*   Практическое использование первоклассных функций

Вот и все для функций первого класса. Хорошего дня.
