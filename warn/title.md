## Введение

У меня всегда было чувство на грани любви и ненависти, когда дело доходило до изучения новых языков. С одной стороны, языки имеют настолько фундаментальное значение для того, что мы делаем, что даже мелкое различие может оказать ощутимое значение. Этот вау эффект когда какой-то клик может оказать настолько сильное влияние на то, как вы программируете, что может предопределить ваши ожидания от других языков. С другой стороны, понимание языка является поэтапным процессом. Изучение новых ключевых слов, системы типов, стиля кодирования, а так же новых библиотек, сообществ и парадигм это много работы, которую, казалось бы сложно оправдать. По сравнению со всем остальным, что мы могли бы изучить, новые языки часто кажутся плохой инвестицией нашего времени.

Тем не менее, мы должны двигаться вперед. Мы должны делать постепенные шаги, потому что, опять же, языки являются основой того, что мы делаем. И хотя изменения являются поэтапными, они, как правило, имеют широкую область применения и влияют на продуктивность, читабельность, быстродействие, тестируемость, управление зависимостями, обработку ошибок, документацию, профилирование, сообщества, стандартные библиотеки, и так далее.

У нас может возникнуть важный вопрос: почему Go? Для меня, существуют две весомые причины. Первая в том, что это относительно простой язык с относительно простой стандартной библиотекой. Во многих отношениях инкрементная природа Go является упрощением некоторых сложностей, которые были добавлены к другим языкам за последнюю пару десятилетий. Другая причина в том, что для многих разработчиков он будет дополнять их существующий арсенал.

Go был разработан в качестве системного языка (например, для операционных систем, драйверов устройств) и направлен на C и C++ разработчиков. По данным команды Go, и что верно для меня, разработчики приложений, не системные разработчики, являются основными пользователями Go. Почему? Я не могу авторитетно говорить за системных разработчиков, но те из нас, кто создает веб-сайты, сервисы, приложения для рабочего стола, и т. п. частично приходят к необходимости наличия класса систем, которые находятся где-то между системами низкого уровня и приложениями высокого уровня.

Это может быть обмен сообщениями, кеширование, тяжелые вычисления для анализа данных, утилиты командной строки, логирование или мониторинг. Я не знаю как это назвать, но в течении моей карьеры, когда растет сложность системы и параллелизм часто измеряется в десятках тысяч потоков, появляется быстро растущая потребность в пользовательских инфраструктурных системах. Вы можете построить систему с помощью Ruby или Python или чего-то еще (и многие это делают), но для таких типов систем выгодней использовать более жесткую систему типов и высокую производительность. Кроме того, вы можете использовать Go для разработки веб-сайтов (и многие это делают), но я по прежнему считаю что Node или Ruby с большим отрывом превосходят его для таких систем.

Есть и другие области применения, в которых Go превосходит другие языки. Например, не нужно устанавливать никаких дополнительных зависимостей при запуске скомпилированной программы на Go. Вам не нужно переживать, есть ли у ваших пользователей Ruby или установлена ли JVM, и если да, то какой версии. По этой причине Go становится все более популярным как язык для приложений командной строки и другим разновидностям утилит, которые вам необходимо распространять (например сборщик файлов логов).

Становится ясно, что изучение Go будет эффективным использованием вашего времени. Вам не нужно будет тратить много часов на изучение или хотя бы освоение Go, и в конечном итоге у вас останется что-то полезное от ваших усилий.

## Примечание автора

Я колебался писать эту книгу по нескольким причинам. Первая в том, что Go имеет солидную документацию, в частности Effective Go.

Вторая в моем дискомфорте при написании книги о языке. Когда я написал маленькую книгу о MongoDB (The Little MongoDB Book), можно было с уверенностью сказать, что большинство читателей поняли основы реляционных баз данных и моделирования. С маленькой книгой о Redis (The Little Redis Book) вы могли получить представление о хранилищах ключ-значение.

Когда я думаю об абзацах и главах, которые впереди, я знаю, что буду не в состоянии сделать те же предположения. Сколько времени займет разговор об интерфейсах, зная, что для некоторых это будет новая концепция, а другим будет достаточно сказать, что в Go есть интерфейсы? В конечном счете, меня утешает то, что вы можете дать мне знать, если какие-то части слишком поверхностные или другие слишком подробные. Считайте это ценой за книгу.
