# Обзор системы Go Type

В этой статье будут представлены все виды типов в Go и концепции системы типов Go. Не зная этих фундаментальных концепций, трудно получить полное представление о Go.

### Концепция: основные типы

Встроенные базовые типы в Go также были представлены во [встроенных базовых типах и основных литералах значений](https://go101.org/article/basic-types-and-value-literals.html) . Для полноты текущей статьи эти встроенные базовые типы повторно перечислены здесь.

*   Встроенный тип строки: `string` .
*   Встроенный логический тип: `bool` .
*   Встроенные числовые типы:
    *   `int8`, `uint8` (`byte`), `int16`, `uint16`, `int32` (`rune`), `uint32`, `int64`, `uint64`, `int`, `uint`, `uintptr`.
    *   `float32`, `float64`.
    *   `complex64` , `complex128` .

Обратите внимание, `byte` что это встроенный псевдоним `uint8` , а `rune` также встроенный псевдоним `int32` . Мы также можем объявить пользовательские псевдонимы типов (см. ниже).

За исключением [строковых типов](https://go101.org/article/string.html) , серия статей Go 101 не будет пытаться объяснить больше других основных типов.

17 встроенных базовых типов являются предварительно объявленными типами.

### Концепция: составные типы

Go поддерживает следующие составные типы:

*   [типы указателей](https://go101.org/article/pointer.html) \- указатели C похожи.
*   [типы структур](https://go101.org/article/struct.html) \- похожи на структуры C.
*   [типы](https://go101.org/article/function.html) функций — функции являются первоклассными типами в Go.
*   [типы контейнеров](https://go101.org/article/container.html) :
    *   типы массивов - типы контейнеров фиксированной длины.
    *   Тип фрагмента - типы контейнеров с динамической длиной и динамической емкостью.
    *   типы карт - карты представляют собой ассоциативные массивы (или словари). Стандартный компилятор Go реализует карты в виде хеш-таблиц.
*   [типы](https://go101.org/article/channel.html) каналов — каналы используются для синхронизации данных между горутинами (зеленые потоки в Go).
*   [типы интерфейсов](https://go101.org/article/interface.html) — интерфейсы играют ключевую роль в отражении и полиморфизме.

Безымянные составные типы могут быть обозначены соответствующими литералами типов. Ниже приведены некоторые примеры буквального представления всех видов безымянных составных типов (имя и безымянные типы будут объяснены ниже).

```go
// Assume T is an arbitrary type and Tkey is
// a type supporting comparison (== and !=).

*T         // a pointer type
[5]T       // an array type
[]T        // a slice type
map[Tkey]T // a map type

// a struct type
struct {
	name string
	age  int
}

// a function type
func(int) (bool, string)

// an interface type
interface {
	Method0(string) int
	Method1() (int, bool)
}

// some channel types
chan T
chan<- T
<-chan T

```

[Сравнимые и несравнимые типы](https://go101.org/article/type-system-overview.html#types-not-support-comparison) будут объяснены ниже.

### Факт: виды типов

Каждому из упомянутых выше основных и составных типов соответствует один вид типов. Помимо этих типов, небезопасные типы указателей, представленные в [`unsafe` стандартном пакете,](https://golang.org/pkg/unsafe) также относятся к одному типу типов в Go. Итак, до сих пор (Go 1.19) в Go было 26 видов типов.

### Синтаксис: определения типов

*( **Определение** типа или объявление определения типа, первоначально называвшееся **объявлением типа** , было единственным способом объявления типа до Go 1.9. Начиная с Go 1.9, определение типа стало одной из двух форм объявлений типа. Новая форма называется **объявлением псевдонима типа** , которое будет представлен в разделе ниже.)*

В Go мы можем определить новые типы, используя следующую форму. В синтаксисе `type` это ключевое слово.

```go
// Define a solo new type.
type NewTypeName SourceType

// Define multiple new types together.
type (
	NewTypeName1 SourceType1
	NewTypeName2 SourceType2
)

```

Имена новых типов должны быть идентификаторами. Но обратите внимание, что имена типов, объявленные на уровне пакета, не могут быть [`init`](https://go101.org/article/packages-and-imports.html#init) . Это то же самое для следующих введенных псевдонимов типов.

Объявление второго типа в приведенном выше примере включает две спецификации типа. Если объявление типа содержит более одной спецификации типа, спецификации типа должны быть заключены в пару `()` .

Примечание,

*   новый определенный тип и соответствующий ему исходный тип в определениях типов — это два разных типа.
*   два типа, определенные в двух определениях типов, всегда являются двумя разными типами.
*   новый определенный тип и исходный тип будут использовать один и тот же базовый тип (см. ниже определение базовых типов), и их значения могут быть преобразованы друг в друга.
*   типы могут быть определены в телах функций.

Некоторые примеры определения типа:

```go
// The following new defined and source types are all
// basic types. The source types are all predeclared.
type (
	MyInt int
	Age   int
	Text  string
)

// The following new defined and source types are all
// composite types. The source types are all unnamed.
type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

func f() {
	// The names of the three defined types
	// can be only used within the function.
	type PersonAge map[string]int
	type MessageQueue chan string
	type Reader interface{Read([]byte) int}
}

```

Обратите внимание, что от Go 1.9 до Go 1.17 спецификация Go когда-либо считала предварительно объявленные встроенные типы определенными типами. Но начиная с Go 1.18 спецификация Go уточняет, что предварительно объявленные встроенные типы не являются определенными типами.

### Концепция: Пользовательские универсальные типы и экземпляры типов

Начиная с Go 1.18, Go поддерживает настраиваемые универсальные типы (и функции). Универсальный тип должен быть создан для использования в качестве типов значений.

Универсальный тип — это определенный тип, а созданные им типы — это именованные типы (именованные типы объясняются в следующем разделе).

Двумя другими важными понятиями в пользовательских универсальных шаблонах являются ограничения и параметры типа.

В этой книге пользовательские дженерики подробно не рассматриваются. Пожалуйста, прочтите книгу [Go Generics 101](https://go101.org/generics/101.html) о том, как объявлять и использовать универсальные типы и функции.

### Концепция: именованные типы и безымянные типы

До версии Go 1.9 терминология **именованного типа** точно определялась в спецификации Go. Именованный тип был определен как тип, представленный идентификатором. Наряду с функцией псевдонима пользовательского типа, представленной в Go 1.9 (см. следующий раздел), терминология **именованного типа** была удалена из спецификации Go и заменена терминологией **определенного типа .** Начиная с Go 1.18, наряду с введением пользовательских дженериков, терминология **именованного типа** была снова добавлена ​​в спецификацию Go.

Именованный тип может быть

*   предварительно объявленный тип;
*   определенный (нестандартный универсальный) тип;
*   инстанцированный тип (универсального типа);
*   тип параметра типа (используется в пользовательских универсальных шаблонах).

Другие типы значений называются безымянными типами. Безымянный тип должен быть составным типом (а не наоборот).

### Синтаксис: Объявления псевдонимов типов

Начиная с Go 1.9, мы можем объявлять пользовательские псевдонимы типов, используя следующий синтаксис. Синтаксис объявления псевдонима очень похож на определение типа, но обратите внимание, что `=` в спецификации псевдонима каждого типа есть .

```go
type (
	Name = string
	Age  = int
)

type table = map[string]int
type Table = map[Name]Age

```

Псевдонимы типов должны быть идентификаторами. Как и определения типов, псевдонимы типов также могут быть объявлены в телах функций.

Имя типа (или литерал) и его псевдонимы обозначают идентичный тип. Согласно приведенным выше объявлениям, `Name` это псевдоним `string` , поэтому оба обозначают один и тот же тип. То же самое относится и к другим трем парам обозначений типов (имен или литералов):

*   `Age` а также `int`
*   `table` а также `map[string]int`
*   `Table` а также `map[Name]Age`

На самом деле литералы `map[string]int` и `map[Name]Age` также оба обозначают один и тот же тип. Таким образом, псевдонимы `table` также `Table` обозначают один и тот же тип.

Обратите внимание, хотя псевдоним типа всегда имеет имя, он может обозначать безымянный тип. Например, псевдонимы `table` и `Table` обозначают один и тот же безымянный тип `map[string]int` .

### Концепция: базовые типы

В Go у каждого типа есть базовый тип. Правила:

*   для встроенных типов соответствующие базовые типы сами по себе.
*   для `Pointer` типа, определенного в `unsafe` стандартном пакете кода, его базовым типом является он сам (по крайней мере, мы можем так думать. Фактически, базовый тип `unsafe.Pointer` типа плохо документирован. Мы также можем думать, что базовым типом является `*T` , где `T` представляет собой произвольный тип). `unsafe.Pointer` также рассматривается как встроенный тип.
*   базовым типом безымянного типа, который должен быть составным типом, является он сам.
*   в объявлении типа вновь объявленный тип и исходный тип имеют один и тот же базовый тип.

Примеры:

```go
// The underlying types of the following ones are both int.
type (
	MyInt int
	Age   MyInt
)

// The following new types have different underlying types.
type (
	IntSlice   []int   // underlying type is []int
	MyIntSlice []MyInt // underlying type is []MyInt
	AgeSlice   []Age   // underlying type is []Age
)

// The underlying types of []Age, Ages, and AgeSlice
// are all the unnamed type []Age.
type Ages AgeSlice

```

Как можно отследить базовый тип по объявленному пользователем типу? Правило состоит в том, что при встрече со встроенным базовым типом или безымянным типом трассировка должна быть остановлена. Возьмите объявления типов, показанные выше, в качестве примеров, давайте проследим их базовые типы.

MyInt → целое Возраст → MyInt → int IntSlice → \[\]int MyIntSlice → \[\]MyInt → \[\]int AgeSlice → \[\]Age → \[\]MyInt  → \[\]int Ages → AgeSlice → \[\]Age → \[\]MyInt  → \[\]int

В Го,

*   типы, лежащие в основе типов, `bool` называются **булевыми типами** ;
*   типы, базовые типы которых являются любым из встроенных целочисленных типов, называются **целочисленными типами** ;
*   типы, базовые типы которых либо являются, либо `float32` называются `float64` типами с **плавающей запятой** ;
*   типы, базовые типы которых либо являются, либо `complex64` называются `complex128` сложными **типами** ;
*   целые числа, типы с плавающей запятой и сложные типы также называются **числовыми типами** ;
*   типы, лежащие в основе типов, `string` называются **строковыми типами** .

Концепция базового типа играет важную роль в [преобразованиях значений, присваиваниях и сравнениях в Go](https://go101.org/article/value-conversions-assignments-and-comparisons.html) .

### Концепция: ценности

Экземпляр типа называется «значением» типа. Значения одного типа имеют некоторые общие свойства. Тип может иметь много значений. Одним из них является нулевое значение типа.

Каждый тип имеет нулевое значение, которое можно рассматривать как значение по умолчанию для типа. Предварительно объявленный `nil` идентификатор может использоваться для представления нулевых значений срезов, карт, функций, каналов, указателей (в том числе указателей с небезопасным типом) и интерфейсов. Для получения дополнительной информации `nil` , пожалуйста, прочитайте [nil в Go](https://go101.org/article/nil.html) .

В коде существует несколько видов форм представления значений, включая [литералы](https://go101.org/article/basic-types-and-value-literals.html) , [именованные константы](https://go101.org/article/constants-and-variables.html#constant) , [переменные](https://go101.org/article/constants-and-variables.html#variable) и [выражения](https://go101.org/article/expressions-and-statements.html) , хотя первые три можно рассматривать как частные случаи последнего.

Значение может быть [типизированным или нетипизированным](https://go101.org/article/constants-and-variables.html#untyped-value) .

Все виды основных литералов значений были представлены в статье [основные типы и основные литералы значений](https://go101.org/article/basic-types-and-value-literals.html) . В Go есть еще два вида литералов: составные литералы и функциональные литералы.

Функциональные литералы, как следует из названия, используются для представления значений функций. Объявление [функции](https://go101.org/article/function-declarations-and-calls.html#declaration) состоит из литерала функции и идентификатора (имени функции).

Составные литералы используются для представления значений типов структур и типов контейнеров (массивов, срезов и карт) . Дополнительные сведения см. [в статьях о структурах в Go](https://go101.org/article/struct.html) и [контейнерах в Go](https://go101.org/article/container.html) .

Нет литералов для представления значений указателей, каналов и интерфейсов.

### Концепция: Ценные части

Во время выполнения многие значения хранятся где-то в памяти. В Go у каждого из таких значений есть прямая часть. Однако некоторые из них имеют одну или несколько косвенных частей. Каждая часть значения занимает непрерывный сегмент памяти. На косвенные базовые части значения ссылается его прямая часть через ( [безопасные](https://go101.org/article/pointer.html) или [небезопасные](https://go101.org/article/unsafe.html) ) указатели.

[**Часть значения**](https://go101.org/article/value-part.html) терминологии не определена в спецификации Go. Он просто используется в Go 101, чтобы упростить некоторые объяснения и помочь программистам Go лучше понять типы и значения Go.

### Концепция: размеры значений

Когда значение хранится в памяти, количество байтов, занимаемых прямой частью значения, называется размером значения. Поскольку все значения одного и того же типа имеют одинаковый размер значения, мы часто называем его просто размером типа.

Мы можем использовать `Sizeof` функцию из `unsafe` стандартного пакета, чтобы получить размер любого значения.

В спецификации Go не указаны требования к размеру значения для нечисловых типов. Требования к размерам значений всех видов основных числовых типов перечислены в статье [основные типы и основные литералы значений](https://go101.org/article/basic-types-and-value-literals.html) .

### Концепция: базовый тип указателя

Предположим, что для типа указателя его базовый тип может быть обозначен как `*T` литерал, тогда `T` он называется базовым типом типа указателя.

Дополнительную информацию о типах и значениях указателей можно найти в статье [указатели в Go](https://go101.org/article/pointer.html) .

### Концепция: поля структурного типа

Тип структуры состоит из набора объявлений переменных-членов. Каждое из объявлений переменных-членов называется «полем» типа структуры. Например, следующий тип структуры `Book` имеет три поля `author` : `title` и `pages` .

```go
struct {
	author string
	title  string
	pages  int
}

```

Дополнительную информацию о типах и значениях структур можно найти в статье [structs in Go](https://go101.org/article/struct.html) .

### Концепция: сигнатура типов функций

Сигнатура типа функции состоит из списка определений входных параметров и списка определений выходных результатов функции.

Имя и тело функции не являются частью сигнатуры функции. Типы параметров и результатов важны для сигнатуры функции, но имена параметров и результатов не важны.

Пожалуйста, прочитайте [функции в Go](https://go101.org/article/function.html) для получения более подробной информации о типах функций и значениях функций.

### Концепция: методы и набор методов типа

В Go некоторые типы могут иметь [методы](https://go101.org/article/method.html) . Методы также могут называться функциями-членами. Набор методов типа состоит из всех методов типа.

### Концепция: динамический тип и динамическое значение значения интерфейса

Значения интерфейса — это значения, типы которых являются типами интерфейса.

Каждое значение интерфейса может включать в себя значение, не являющееся интерфейсом. Значение, помещенное в значение интерфейса, называется динамическим значением значения интерфейса. Тип динамического значения называется динамическим типом значения интерфейса. Значение интерфейса, не упаковывающее ничего, является нулевым значением интерфейса. Нулевое значение интерфейса не имеет ни динамического значения, ни динамического типа.

Тип интерфейса может указывать ноль или несколько методов, которые формируют набор методов типа интерфейса.

Если набор методов типа, который является интерфейсным или неинтерфейсным типом, является надмножеством набора методов интерфейсного типа, мы говорим, что тип [реализует](https://go101.org/article/interface.html#implementation) интерфейсный тип.

Дополнительные сведения о типах и значениях интерфейсов см . [в разделе Интерфейсы в Go](https://go101.org/article/interface.html) .

### Понятие: конкретная ценность и конкретный тип ценности

Для (типизированного) неинтерфейсного значения его конкретное значение — это оно само, а его конкретный тип — это тип значения.

Нулевое значение интерфейса не имеет ни конкретного типа, ни конкретного значения. Для ненулевого значения интерфейса его конкретное значение является его динамическим значением, а его конкретный тип является его динамическим типом.

### Концепция: типы контейнеров

Массивы, срезы и карты можно рассматривать как формальные типы контейнеров.

Иногда строковые и канальные типы также можно неофициально рассматривать как контейнерные типы.

Каждое значение формального или неформального типа контейнера имеет длину.

Дополнительную информацию о формальных типах и значениях контейнеров можно найти в статье о [контейнерах в Go](https://go101.org/article/container.html) .

### Концепция: ключевой тип типа карты

Если базовый тип типа карты может быть обозначен как `map[Tkey]T` , то `Tkey` он называется ключевым типом типа карты. `Tkey` должен быть сопоставимого типа (см. ниже).

### Концепция: тип элемента типа контейнера

Типы элементов, хранящихся в значениях типа контейнера, должны быть идентичными. Идентичный тип элементов называется типом элемента типа контейнера.

*   Для типа массива, если его базовый тип — `[N]T` , то тип его элемента — `T` .
*   Для типа фрагмента, если его базовый тип — `[]T` , то тип его элемента — `T` .
*   Для типа карты, если его базовый тип — `map[Tkey]T` , то тип его элемента — `T` .
*   Для типа канала, если его базовый тип — или `chan T` , то его тип элемента — . `chan<- T` `<-chan T` `T`
*   Тип элемента любого строкового типа всегда `byte` (также известный как `uint8` ).

### Концепция: направления типов каналов

Значения канала можно рассматривать как синхронизированные очереди «первым поступил — первым обслужен» (FIFO). Типы и значения каналов имеют направления.

*   Значение канала, которое можно отправить и получить, называется двунаправленным каналом. Его тип называется двунаправленным типом канала. Базовые типы двунаправленных типов каналов обозначаются `chan T` литералом.
*   Значение канала, которое доступно только для отправки, называется каналом только для отправки. Его тип называется типом канала только для отправки. Типы каналов только для отправки обозначаются `chan<- T` литералом.
*   Значение канала, которое доступно только для приема, называется каналом только для приема. Его тип называется каналом только для приема. Типы каналов только для приема обозначаются `<-chan T` литералом.

Дополнительную информацию о типах и значениях каналов можно найти в статье [каналы в Go](https://go101.org/article/channel.html) .

### Факт: типы, которые поддерживают или не поддерживают сравнения

В настоящее время (Go 1.19) Go не поддерживает сравнения (с операторами `==` и `!=` ) для значений следующих типов:

*   типы срезов
*   типы карт
*   типы функций
*   любой тип структуры с полем, тип которого несравним, и любой тип массива, тип элемента которого несравним.

Вышеперечисленные типы называются несравнимыми типами. Все остальные типы называются сопоставимыми типами. Компиляторы запрещают сравнивать два значения несравнимых типов.

Обратите внимание, что несравнимые типы также называются несравнимыми типами во многих статьях.

Ключевой тип любого типа карты должен быть сопоставимым типом.

Подробнее о подробных правилах сравнений мы можем узнать из статьи [преобразования значений, присваивания и сравнения в Go](https://go101.org/article/value-conversions-assignments-and-comparisons.html#comparison-rules) .

### Факт: объектно-ориентированное программирование в Go

Go не является полнофункциональным языком объектно-ориентированного программирования, но Go действительно поддерживает некоторые элементы объектно-ориентированного программирования. Пожалуйста, прочтите следующие перечисленные статьи для получения подробной информации:

*   [методы в Go](https://go101.org/article/method.html) .
*   [реализации на Go](https://go101.org/article/interface.html#implementation) .
*   [встраивание типа в Go](https://go101.org/article/type-embedding.html) .

### Факт: дженерики в Go

До Go 1.18 общие функции в Go были ограничены встроенными типами и функциями. Начиная с Go 1.18 уже поддерживаются пользовательские дженерики. Пожалуйста, прочтите [дженерики в](https://go101.org/article/generic.html) статье Go для встроенных дженериков и книгу [Go Generics 101](https://go101.org/generics/101.html) для пользовательских дженериков.
