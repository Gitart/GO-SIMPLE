# Методы в Go

Go поддерживает некоторые функции объектно-ориентированного программирования. Метод является одной из таких функций. В этой статье будут представлены концепции, связанные с методами в Go.

### Объявления методов

В Go мы можем (явно) объявить метод для типа `T` и `*T` , который `T` должен удовлетворять 4 условиям:

1.  `T` должен быть [определенного типа](https://go101.org/article/type-system-overview.html#type-definition) ;
2.  `T` должен быть определен в том же пакете, что и объявление метода;
3.  `T` не должен быть указателем;
4.  `T` не должен быть типом интерфейса. Типы интерфейсов будут описаны в [следующей статье](https://go101.org/article/interface.html) .

Тип `T` и `*T` называются типом приемника соответствующих методов, объявленных для них. Тип `T` называется базовым типом получателя всех методов, объявленных как для типа, так `T` и для `*T` .

Обратите внимание, что мы также можем объявлять методы для [псевдонимов](https://go101.org/article/type-system-overview.html#type-alias) типов `T` и `*T` указанных выше типов. Эффект такой же, как при объявлении методов для самих типов `T` и . `*T`

Если метод объявлен для типа, мы можем сказать, что тип имеет (или владеет) метод.

Из вышеперечисленных условий получим выводы, что мы никогда (явно) не можем объявлять методы для:

*   предварительно объявленные типы, такие как `int` и `string` , потому что мы не можем объявлять методы в `builtin` стандартном пакете.
*   типы интерфейсов. Но тип интерфейса может владеть методами. Подробности читайте [в следующей статье](https://go101.org/article/interface.html) .
*   [безымянные типы,](https://go101.org/article/type-system-overview.html#named-type) кроме типов указателей с формой `*T` , описанной выше.

Объявление метода похоже на объявление функции, но оно имеет дополнительную часть объявления параметра. Часть дополнительных параметров может содержать один и только один параметр типа получателя метода. Единственный параметр называется параметром получателя объявления метода. Параметр получателя должен быть заключен в `()` и объявлен между `func` ключевым словом и именем метода.

Вот несколько примеров объявления методов:

```go
// Age and int are two distinct types. We
// can't declare methods for int and *int,
// but can for Age and *Age.
type Age int
func (age Age) LargerThan(a Age) bool {
	return age > a
}
func (age *Age) Increase() {
	*age++
}

// Receiver of custom defined function type.
type FilterFunc func(in int) bool
func (ff FilterFunc) Filte(in int) bool {
	return ff(in)
}

// Receiver of custom defined map type.
type StringSet map[string]struct{}
func (ss StringSet) Has(key string) bool {
	_, present := ss[key]
	return present
}
func (ss StringSet) Add(key string) {
	ss[key] = struct{}{}
}
func (ss StringSet) Remove(key string) {
	delete(ss, key)
}

// Receiver of custom defined struct type.
type Book struct {
	pages int
}

func (b Book) Pages() int {
	return b.pages
}

func (b *Book) SetPages(pages int) {
	b.pages = pages
}

```

Из приведенных выше примеров мы знаем, что базовые типы приемника могут быть не только типами структур, но также могут быть другими типами, такими как базовые типы и типы контейнеров, если базовые типы приемника удовлетворяют 4 условиям, перечисленным выше.

В некоторых других языках программирования имена параметров приемника всегда являются неявными `this` , что не является рекомендуемым идентификатором для имен параметров приемника в Go.

Приемник типа `*T` называется ***приемником*** \-указателем, приемники без указателя называются ***приемниками-значением*** . Лично я не рекомендую рассматривать ***указатель*** терминологии как противоположность ***значению*** терминологии , потому что значения указателя — это просто специальные значения. Но я не против использования здесь терминов получателя указателя и получателя значения. Причина будет объяснена ниже.

Имена методов могут быть пустым идентификатором `_` . Тип может иметь несколько методов с пустым идентификатором в качестве имени. Но такие методы никогда нельзя вызывать. Только экспортированные методы можно вызывать из других пакетов. Вызовы методов будут представлены в следующем разделе.

### Каждый метод соответствует неявной функции

Для каждого объявления метода компилятор объявит для него соответствующую неявную функцию. Для последних двух методов, объявленных для типа `Book` и типа `*Book` в последнем примере в последнем разделе, компилятор неявно объявляет две следующие функции:

```go
func Book.Pages(b Book) int {
	// The body is the same as the Pages method.
	return b.pages
}

func (*Book).SetPages(b *Book, pages int) {
	// The body is the same as the SetPages method.
	b.pages = pages
}

```

В каждом из двух объявлений неявных функций параметр получателя удаляется из соответствующего объявления метода и вставляется в список обычных параметров первым. Тела функций двух неявно объявленных функций такие же, как и их соответствующие явные тела методов.

Имена неявных функций `Book.Pages` и `(*Book).SetPages` , имеют форму `TypeDenotation.MethodName` . Поскольку идентификаторы в Go не могут содержать специальные символы точки, два имени неявных функций не являются допустимыми идентификаторами, поэтому две функции нельзя объявить явно. Они могут быть объявлены компилятором только неявно, но могут быть вызваны в пользовательском коде:

```go
package main

import "fmt"

type Book struct {
	pages int
}

func (b Book) Pages() int {
	return b.pages
}

func (b *Book) SetPages(pages int) {
	b.pages = pages
}

func main() {
	var book Book
	// Call the two implicit declared functions.
	(*Book).SetPages(&book, 123)
	fmt.Println(Book.Pages(book)) // 123
}

```

Фактически, компиляторы не только объявляют две неявные функции, они также переписывают два соответствующих явно объявленных метода, чтобы позволить двум методам вызывать две неявные функции в телах методов (по крайней мере, мы можем думать, что это происходит), как показано ниже. код показывает:

```go
func (b Book) Pages() int {
	return Book.Pages(b)
}

func (b *Book) SetPages(pages int) {
	(*Book).SetPages(b, pages)
}

```

### Неявные методы с приемниками указателей

Для каждого метода, объявленного для типа получателя значения `T` , соответствующий метод с тем же именем будет неявно объявлен компилятором для типа `*T` . В приведенном выше примере `Pages` метод объявлен для типа `Book` , поэтому метод с тем же именем `Pages` неявно объявлен для типа `*Book` :

```go
// Note: this is not a legal Go syntax.
// It is shown here just for explanation purpose.
// It indicates that the expression (&aBook).Pages
// is evaluated as aBook.Pages (see below sections).
func (b *Book) Pages = (*b).Pages

```

Вот почему я не отказываюсь от использования терминологии получателя значения (как противоположность терминологии получателя указателя). В конце концов, когда мы явно объявляем метод для типа без указателя, фактически объявляются два метода: явный для типа без указателя и неявный для соответствующего типа указателя.

Как упоминалось в предыдущем разделе, для каждого объявленного метода компиляторы также объявляют для него соответствующую неявную функцию. Таким образом, для неявно объявленного метода компилятор объявляет следующую неявную функцию.

```go
func (*Book).Pages(b *Book) int {
	return Book.Pages(*b)
}

```

Другими словами, для каждого явно объявленного метода с приемником значения одновременно будут объявлены две неявные функции и один неявный метод.

### Спецификации методов и наборы методов

Спецификацию метода можно рассматривать как [прототип функции](https://go101.org/article/function.html#prototype) без `func` ключевого слова. Мы можем просмотреть каждое объявление метода, состоящее из `func` ключевого слова, объявления параметра получателя, спецификации метода и тела метода (функции).

Например, спецификации методов `Pages` и `SetPages` , показанные выше, таковы:

```go
Pages() int
SetPages(pages int)

```

Каждый тип имеет набор методов. Набор методов неинтерфейсного типа состоит из всех спецификаций методов, объявленных явно или неявно для типа, за исключением тех, имена которых являются пустым идентификатором `_` . Типы интерфейсов будут описаны в [следующей статье](https://go101.org/article/interface.html) .

Например, наборы методов `Book` типа, показанного в предыдущих разделах,

```go
Pages() int

```

и набор методов `*Book` типа

```go
Pages() int
SetPages(pages int)

```

Порядок спецификаций методов в наборе методов не важен для набора методов.

Для набора методов, если каждая спецификация метода в нем также находится в другом наборе методов, то мы говорим, что первый набор методов является подмножеством второго, а последний является надмножеством первого. Если два набора методов являются подмножествами (или надмножествами) друг друга, то мы говорим, что два набора методов идентичны.

Учитывая тип `T` , предположим, что это ни тип указателя, ни тип интерфейса, по [причине](https://go101.org/article/method.html#implicit-pointer-methods) , упомянутой в последнем разделе, набор методов типа `T` всегда является подмножеством набора методов типа `*T` . Например, набор методов `Book` типа, показанного выше, является подмножеством набора методов этого `*Book` типа.

Обратите внимание, **что неэкспортированные имена методов, начинающиеся с букв нижнего регистра, из разных пакетов всегда будут рассматриваться как два разных имени метода, даже если эти два имени метода в буквальном смысле совпадают.**

Наборы методов играют важную роль в функции полиморфизма Go. Подробнее о полиморфизме читайте [в следующей статье](https://go101.org/article/interface.html) (интерфейсы в Go).

Наборы методов следующих типов всегда пусты:

*   встроенные базовые типы.
*   определенные типы указателей.
*   типы указателей, базовыми типами которых являются интерфейсы или типы указателей.
*   безымянный массив, срез, карта, функция и типы каналов.

### Значения методов и вызовы методов

Методы на самом деле являются специальными функциями. Методы часто называют функциями-членами. Когда тип владеет методом, каждое значение типа будет владеть неизменяемым членом функционального типа. Имя члена совпадает с именем метода, а тип члена такой же, как у функции, объявленной с формой объявления метода, но без принимающей части.

Вызов метода — это просто вызов такой функции-члена. Для значения `v` его метод `m` может быть представлен с помощью формы селектора `v.m` , которая является значением функции.

Пример, содержащий вызовы некоторых методов:

```go
package main

import "fmt"

type Book struct {
	pages int
}

func (b Book) Pages() int {
	return b.pages
}

func (b *Book) SetPages(pages int) {
	b.pages = pages
}

func main() {
	var book Book

	fmt.Printf("%T \n", book.Pages)       // func() int
	fmt.Printf("%T \n", (&book).SetPages) // func(int)
	// &book has an implicit method.
	fmt.Printf("%T \n", (&book).Pages) // func() int

	// Call the three methods.
	(&book).SetPages(123)
	book.SetPages(123) // equivalent to the last line
	fmt.Println(book.Pages())    // 123
	fmt.Println((&book).Pages()) // 123
}

```

*(В отличие от языка C, в Go нет `->` оператора для вызова методов с получателями указателей, поэтому `(&book)->SetPages(123)` в Go это недопустимо.)*

Ждать! Почему строка `book.SetPages(123)` в приведенном выше примере компилируется нормально? Ведь метод `SetPages` не объявлен для `Book` типа. С одной стороны, это можно рассматривать как синтаксический сахар, облегчающий программирование. Этот сахар работает только для адресуемых получателей значений. Компилятор неявно возьмет адрес адресуемого значения `book` , когда оно будет передано в качестве аргумента получателя `SetPages` вызова метода. С другой стороны, мы также должны думать , что `aBookExpression.SetPages` это всегда допустимый селектор (с точки зрения синтаксиса), даже если выражение `aBookExpression` оценивается как неадресуемое `Book` значение, и в этом случае селектор `aBookExpression.SetPages` недействителен (но допустим).

Как упоминалось выше, когда метод объявляется для типа, каждое значение типа будет иметь функцию-член. Нулевые значения не являются исключениями, независимо от того, представлены ли нулевые значения типов с помощью `nil` .

Пример:

```go
package main

type StringSet map[string]struct{}
func (ss StringSet) Has(key string) bool {
	// Never panic here, even if ss is nil.
	_, present := ss[key]
	return present
}

type Age int
func (age *Age) IsNil() bool {
	return age == nil
}
func (age *Age) Increase() {
	*age++ // If age is a nil pointer, then
	       // dereferencing it will panic.
}

func main() {
	_ = (StringSet(nil)).Has   // will not panic
	_ = ((*Age)(nil)).IsNil    // will not panic
	_ = ((*Age)(nil)).Increase // will not panic

	_ = (StringSet(nil)).Has("key") // will not panic
	_ = ((*Age)(nil)).IsNil()       // will not panic

	// This following line will panic. But the
	// panic is not caused by invoking the method.
	// It is caused by the nil pointer dereference
	// within the method body.
	((*Age)(nil)).Increase()
}

```

### Аргументы получателя передаются путем копирования

Так же, как и общие аргументы функции, аргументы получателя также передаются путем копирования. Таким образом, изменения в [прямой части](https://go101.org/article/value-part.html) аргумента получателя в вызове метода не будут отражаться за пределами метода.

Пример:

```go
package main

import "fmt"

type Book struct {
	pages int
}

func (b Book) SetPages(pages int) {
	b.pages = pages
}

func main() {
	var b Book
	b.SetPages(123)
	fmt.Println(b.pages) // 0
}

```

Другой пример:

```go
package main

import "fmt"

type Book struct {
	pages int
}

type Books []Book

func (books Books) Modify() {
	// Modifications on the underlying part of
	// the receiver will be reflected to outside
	// of the method.
	books[0].pages = 500
	// Modifications on the direct part of the
	// receiver will not be reflected to outside
	// of the method.
	books = append(books, Book{789})
}

func main() {
	var books = Books{{123}, {456}}
	books.Modify()
	fmt.Println(books) // [{500} {456}]
}

```

Немного не по теме, если поменять местами две строки в заказах вышеуказанного `Modify` метода, то обе модификации не будут отражены за пределами тела метода.

```go
func (books Books) Modify() {
	books = append(books, Book{789})
	books[0].pages = 500
}

func main() {
	var books = Books{{123}, {456}}
	books.Modify()
	fmt.Println(books) // [{123} {456}]
}

```

Причина в том, что при `append` вызове будет выделен новый блок памяти для хранения элементов копии переданного аргумента получателя слайса. Распределение не будет отражаться на самом переданном аргументе получателя слайса.

Чтобы обе модификации отражались за пределами тела метода, получатель метода должен быть указателем.

```go
func (books *Books) Modify() {
	*books = append(*books, Book{789})
	(*books)[0].pages = 500
}

func main() {
	var books = Books{{123}, {456}}
	books.Modify()
	fmt.Println(books) // [{500} {456} {789}]
}

```

### Нормализация значения метода

Во время компиляции компиляторы нормализуют каждое выражение значения метода, изменяя неявные операции взятия адреса и разыменования указателя на явные операции в этом выражении значения метода.

Предположим `v` , что это значение типа `T` и `v.m` допустимое выражение значения метода,

*   если `m` это метод, явно объявленный для типа `*T` , то компиляторы нормализуют его как `(&v).m` ;
*   если `m` это метод, явно объявленный для типа `T` , то выражение значения метода `v.m` уже нормализовано.

Предположим `p` , что это значение типа `*T` и `p.m` допустимое выражение значения метода,

*   если `m` это метод, явно объявленный для типа `T` , то компиляторы нормализуют его как `(*p).m` ;
*   если `m` это метод, явно объявленный для типа `*T` , то выражение значения метода `p.m` уже нормализовано.

Нормализация значения продвигаемого метода будет объяснена в следующей статье о [встраивании типов .](https://go101.org/article/type-embedding.html#method-value-evaluation)

### Оценка значения метода

Предположим `v.m` , что это нормализованное выражение значения метода, во время выполнения, когда значение метода `v.m` оценивается, аргумент получателя `v` оценивается, а копия результата оценки сохраняется и используется в последующих вызовах значения метода.

Например, в следующем коде

*   выражение значения метода `b.Pages` уже нормализовано. `b` Во время выполнения сохраняется копия аргумента получателя . Копия аналогична `Book{pages: 123}` , последующее изменение значения `b` не влияет на эту копию. Вот почему вызов `f1()` печатает `123` .
*   выражение значения метода `p.Pages` нормализовано `(*p).Pages` во время компиляции. Во время выполнения аргумент получателя `*p` оценивается до текущего `b` значения, которое равно `Book{pages: 123}` . Копия результата оценки сохраняется и используется при последующих вызовах значения метода, поэтому вызов `f2()` также печатает `123` .
*   выражение значения метода `p.Pages2` уже нормализовано. `p` Во время выполнения сохраняется копия аргумента получателя . Сохраненное значение является адресом значения `b` , поэтому любые изменения `b` будут отражены через разыменование сохраненного значения, поэтому вызов `g1()` выводит `789` .
*   выражение значения метода `b.Pages2` нормализовано `(&b).Pages2` во время компиляции. Во время выполнения копия результата оценки `&b` сохраняется. Сохраненное значение является адресом значения `b` , поэтому любые изменения `b` будут отражены через разыменование сохраненного значения, поэтому вызов `g2()` выводит `789` .

```go
package main

import "fmt"

type Book struct {
	pages int
}

func (b Book) Pages() int {
	return b.pages
}

func (b *Book) Pages2() int {
	return (*b).Pages()
}

func main() {
	var b = Book{pages: 123}
	var p = &b
	var f1 = b.Pages
	var f2 = p.Pages
	var g1 = p.Pages2
	var g2 = b.Pages2
	b.pages = 789
	fmt.Println(f1()) // 123
	fmt.Println(f2()) // 123
	fmt.Println(g1()) // 789
	fmt.Println(g2()) // 789
}

```

### Определенный тип не получает методы, явно объявленные для исходного типа, используемого в его определении

Например, в следующем коде, в отличие от определенного типа `MyInt` , у определенного типа `Age` нет `IsOdd` метода.

```go
package main

type MyInt int
func (mi MyInt) IsOdd() bool {
	return mi%2 == 1
}

type Age MyInt

func main() {
	var x MyInt = 3
	_ = x.IsOdd() // okay

	var y Age = 36
	// _ = y.IsOdd() // error: y.IsOdd undefined
	_ = y
}

```

### Должен ли быть объявлен метод с приемником указателя или приемником значения?

Во-первых, из последнего раздела мы знаем, что иногда мы должны объявлять методы с получателями указателей.

На самом деле, мы всегда можем объявить методы с приемниками указателей без каких-либо логических проблем. Это всего лишь вопрос производительности программы, поэтому иногда лучше объявить методы с приемниками значений.

Для случаев приемники значений и приемники указателей приемлемы, вот некоторые факторы, которые необходимо учитывать для принятия решений.

*   Слишком большое количество копий указателя может увеличить нагрузку на сборщик мусора.
*   Если размер типа получателя значения велик, то стоимость копии аргумента получателя может быть значительной. Все типы указателей имеют [небольшой размер](https://go101.org/article/value-copy-cost.html) .
*   Объявление методов приемников значений и приемников указателей для одного и того же базового типа с большей вероятностью вызовет гонку данных, если объявленные методы вызываются одновременно в нескольких горутинах.
*   Значения типов в `sync` стандартном пакете не должны копироваться, поэтому объявление методов с приемниками значений для структурных типов, которые [встраивают](https://go101.org/article/type-embedding.html) типы в `sync` стандартный пакет, проблематично.

Если трудно принять решение, должен ли метод использовать приемник указателя или приемник значения, просто выберите способ приемника указателя.
