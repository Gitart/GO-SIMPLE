# Тип встраивания

Из структур статей [в Go](https://go101.org/article/struct.html) мы знаем, что тип структуры может иметь много полей. Каждое поле состоит из одного имени поля и одного типа поля. Фактически, иногда поле структуры может состоять только из типа поля. Способ объявления полей структуры называется внедрением типа.

В этой статье объясняется назначение встраивания типов и все подробности встраивания типов.

### Как выглядит встраивание типов?

Вот пример, демонстрирующий встраивание типов:

```go
package main

import "net/http"

func main() {
	type P = *bool
	type M = map[int]int
	var x struct {
		string // a named non-pointer type
		error  // a named interface type
		*int   // an unnamed pointer type
		P      // an alias of an unnamed pointer type
		M      // an alias of an unnamed type

		http.Header // a named map type
	}
	x.string = "Go"
	x.error = nil
	x.int = new(int)
	x.P = new(bool)
	x.M = make(M)
	x.Header = http.Header{}
}

```

В приведенном выше примере шесть типов встроены в тип структуры. Каждое вложение типа образует встроенное поле.

Встроенные поля также называются анонимными полями. Однако каждое встроенное поле имеет неявно указанное имя. Неполное [имя](https://golang.org/ref/spec#Qualified_identifiers) типа встроенного поля действует как имя поля. Например, имена шести встроенных полей в приведенных выше примерах — `string` , `error` , `int` , `P` , `M` и `Header` , соответственно.

### Какие типы могут быть встроены?

Текущая спецификация Go (версия 1.19) [гласит:](https://golang.org/ref/spec#Struct_types)

> Встроенное поле должно быть указано как имя типа `T` или как указатель на имя неинтерфейсного типа `*T` , и `T` само по себе не может быть типом указателя.

Приведенное выше описание верно до Go 1.9. Однако с введением псевдонимов типов в Go 1.9 описание [становится немного устаревшим и неточным](https://github.com/golang/go/issues/22005) . Например, описание не включает регистр `P` поля в примере в последнем разделе.

Здесь статья пытается дать более точные описания.

*   Имя типа `T` может быть внедрено как встроенное поле, если оно не `T` обозначает именованный тип указателя или тип указателя, базовым типом которого является либо указатель, либо тип интерфейса.
*   Тип указателя `*T` , где `T` — имя типа, обозначающее базовый тип типа указателя, может быть внедрен как встроенное поле, если только имя типа не `T` обозначает тип указателя или интерфейса.

Ниже перечислены некоторые примеры типов, которые можно и нельзя встраивать:

```go
type Encoder interface {Encode([]byte) []byte}
type Person struct {name string; age int}
type Alias = struct {name string; age int}
type AliasPtr = *struct {name string; age int}
type IntPtr *int
type AliasPP = *IntPtr

// These types and aliases can be embedded.
Encoder
Person
*Person
Alias
*Alias
AliasPtr
int
*int

// These types and aliases can't be embedded.
AliasPP          // base type is a pointer type
*Encoder         // base type is an interface type
*AliasPtr        // base type is a pointer type
IntPtr           // named pointer type
*IntPtr          // base type is a pointer type
*chan int        // base type is an unmaed type
struct {age int} // unnamed non-pointer type
map[string]int   // unnamed non-pointer type
[]int64          // unnamed non-pointer type
func()           // unnamed non-pointer type

```

В структуре не может быть двух полей с одинаковыми именами, исключений для анонимных полей структуры нет. В соответствии с правилами именования встроенных полей безымянный тип указателя не может быть встроен вместе с его базовым типом в один и тот же тип структуры. Например, `int` и `*int` не может быть встроен в структуру того же типа.

Тип структуры не может рекурсивно внедрять себя или свои псевдонимы.

Как правило, имеет смысл встраивать только те типы, у которых есть поля или методы (в следующих разделах будет объяснено, почему), хотя некоторые типы без полей и методов также могут быть внедрены.

### В чем смысл встраивания типов?

Основная цель встраивания типов — расширить функциональные возможности встроенных типов в тип встраивания, чтобы нам не нужно было повторно реализовывать функциональные возможности вложенных типов для типа встраивания.

Многие другие объектно-ориентированные языки программирования используют наследование для достижения той же цели внедрения типов. Оба механизма имеют свои [преимущества и недостатки](https://en.wikipedia.org/wiki/Composition_over_inheritance) . Здесь в этой статье не будет обсуждаться, какой из них лучше. Мы просто должны знать, что Go выбрал механизм встраивания типов, и между ними есть большая разница:

*   Если тип `T` наследует другой тип, то тип `T` получает способности другого типа. В то же время каждое значение типа `T` можно также рассматривать как значение другого типа.
*   Если тип `T` встраивает в себя другой тип, то тип other type становится частью type `T` , и type `T` получает возможности другого типа, но никакие значения type `T` не могут рассматриваться как значения другого типа.

Вот пример, показывающий, как встроенный тип расширяет функциональные возможности встроенного типа.

```go
package main

import "fmt"

type Person struct {
	Name string
	Age  int
}
func (p Person) PrintName() {
	fmt.Println("Name:", p.Name)
}
func (p *Person) SetAge(age int) {
	p.Age = age
}

type Singer struct {
	Person // extends Person by embedding it
	works  []string
}

func main() {
	var gaga = Singer{Person: Person{"Gaga", 30}}
	gaga.PrintName() // Name: Gaga
	gaga.Name = "Lady Gaga"
	(&gaga).SetAge(31)
	(&gaga).PrintName()   // Name: Lady Gaga
	fmt.Println(gaga.Age) // 31
}

```

Из вышеприведенного примера видно, что после встраивания type `Person` тип `Singer` получает все методы и поля типа `Person` , а type `*Singer` получает все методы типа `*Person` . Верны ли выводы? Следующие разделы ответят на этот вопрос.

Обратите внимание, что `Singer` значение не является `Person` значением, следующий код не компилируется:

```go
var gaga = Singer{}
var _ Person = gaga

```

### Получает ли встроенный тип поля и методы встроенных типов?

Давайте перечислим все поля и методы типа `Singer` и методы типа, `*Singer` используемые в последнем примере, используя [функции отражения,](https://go101.org/article/reflection.html) предоставленные в `reflect` стандартном пакете.

```go
package main

import (
	"fmt"
	"reflect"
)

... // the types declared in the last example

func main() {
	t := reflect.TypeOf(Singer{}) // the Singer type
	fmt.Println(t, "has", t.NumField(), "fields:")
	for i := 0; i < t.NumField(); i++ {
		fmt.Print(" field#", i, ": ", t.Field(i).Name, "\n")
	}
	fmt.Println(t, "has", t.NumMethod(), "methods:")
	for i := 0; i < t.NumMethod(); i++ {
		fmt.Print(" method#", i, ": ", t.Method(i).Name, "\n")
	}

	pt := reflect.TypeOf(&Singer{}) // the *Singer type
	fmt.Println(pt, "has", pt.NumMethod(), "methods:")
	for i := 0; i < pt.NumMethod(); i++ {
		fmt.Print(" method#", i, ": ", pt.Method(i).Name, "\n")
	}
}

```

Результат:

```
main.Singer has 2 fields:
 field#0: Person
 field#1: works
main.Singer has 1 methods:
 method#0: PrintName
*main.Singer has 2 methods:
 method#0: PrintName
 method#1: SetAge

```

Из результата мы знаем, что тип `Singer` действительно владеет `PrintName` методом, а тип `*Singer` действительно владеет двумя методами, `PrintName` и `SetAge` . Но тип `Singer` не владеет `Name` полем. Тогда почему выражение селектора `gaga.Name` допустимо для `Singer` значения `gaga` ? Пожалуйста, прочитайте следующий раздел, чтобы узнать причину.

### Сокращения селекторов

Из статей о [структурах в Go](https://go101.org/article/struct.html) и [методах в Go](https://go101.org/article/method.html) мы узнали, что для значения называется селектором, где `x` либо имя поля, либо имя метода. Если это имя поля, то оно должно быть значением структуры или значением указателя структуры. Селектор — это выражение, представляющее значение. Если селектор обозначает поле, он также может иметь свои собственные поля (если это значение структуры) и методы. Например , где также может быть либо имя поля, либо имя метода. `x.y` `y` `y` `x` `x.y` `x.y` `x.y.z` `z`

В Go (без учета конфликта селекторов и затенения, описанных в следующем разделе), ***если отчество в селекторе соответствует встроенному полю, то это имя может быть опущено в селекторе*** . Вот почему встроенные поля также называются анонимными полями.

Например:

```go
package main

type A struct {
	FieldX int
}

func (a A) MethodA() {}

type B struct {
	*A
}

type C struct {
	B
}

func main() {
	var c = &C{B: B{A: &A{FieldX: 5}}}

	// The following 4 lines are equivalent.
	_ = c.B.A.FieldX
	_ = c.B.FieldX
	_ = c.A.FieldX // A is a promoted field of C
	_ = c.FieldX   // FieldX is a promoted field

	// The following 4 lines are equivalent.
	c.B.A.MethodA()
	c.B.MethodA()
	c.A.MethodA()
	c.MethodA() // MethodA is a promoted method of C
}

```

Вот почему это выражение `gaga.Name` допустимо в примере из последнего раздела. Потому что это просто сокращение от `gaga.Person.Name` .

Точно так же селектор `gaga.PrintName` можно рассматривать как сокращение от `gaga.Person.PrintName` . Но это также нормально, если мы думаем, что это не стенография. В конце концов, у типа `Singer` действительно есть `PrintName` метод, хотя метод объявлен неявно (подробности см. в следующем разделе). По той же причине селектор `(&gaga).PrintName` и `(&gaga).SetAge` также может рассматриваться как или не как сокращение от `(&gaga.Person).PrintName` и `(&gaga.Person).SetAge` .

`Name` называется продвигаемым полем типа `Singer` . `PrintName` называется расширенным методом типа `Singer` .

Обратите внимание, мы также можем использовать селектор `gaga.SetAge` , только если `gaga` это адресуемое значение типа `Singer` . Это просто синтаксический сахар `(&gaga).SetAge` . Пожалуйста, прочитайте [вызовы методов](https://go101.org/article/method.html#call) для деталей.

В приведенных выше примерах `c.B.A.FieldX` называется полная форма селекторов `c.FieldX` и `c.B.FieldX` . `c.A.FieldX` Точно так же называется `c.B.A.MethodA` полная форма селекторов `c.MethodA` и `c.B.MethodA` . `c.A.MethodA`

Если каждое отчество в полной форме селектора соответствует вложенному полю, то количество отчеств в селекторе называется глубиной селектора. Например, глубина селектора, `c.MethodA` использованного в приведенном выше примере, равна *2* , а полная форма селектора — `c.B.A.MethodA` .

### Селекторное затенение и столкновение

Для значения `x` (мы всегда должны предполагать, что оно адресуемое, даже если это не так), возможно, что многие из его селекторов полной формы имеют один и тот же последний элемент, `y` и каждое второе имя этих селекторов представляет встроенное поле. Для таких случаев

*   только полный селектор с наименьшей глубиной (предположим, что он единственный) может быть сокращен как `x.y` . Другими словами, `x.y` обозначает селектор полной формы с наименьшей глубиной. Другие полноформатные селекторы **затенены** селектором с наименьшей глубиной.
*   если имеется более одного полноформатного селектора с наименьшей глубиной, то ни один из этих полноформатных селекторов не может быть сокращен до `x.y` . Мы говорим, что селекторы полной формы с наименьшей глубиной **конфликтуют** друг с другом.

Если селектор метода затенен другим селектором метода и две соответствующие сигнатуры метода идентичны, мы говорим, что первый метод переопределен другим.

Например, предположим `A` , `B` и `C` три [определенных типа](https://go101.org/article/type-system-overview.html#type-definition) .

```go
type A struct {
	x string
}
func (A) y(int) bool {
	return false
}

type B struct {
	y bool
}
func (B) x(string) {}

type C struct {
	B
}

```

Следующий код не компилируется. Причина в глубине селекторов `v1.A.x` и `v1.B.x` равных, поэтому два селектора сталкиваются друг с другом, и ни один из них не может быть сокращен до `v1.x` . Такая же ситуация с селекторами `v1.A.y` и `v1.B.y` .

```go
var v1 struct {
	A
	B
}

func f1() {
	_ = v1.x // error: ambiguous selector v1.x
	_ = v1.y // error: ambiguous selector v1.y
}

```

Следующий код компилируется нормально. Селектор `v2.C.B.x` затенен `v2.A.x` , поэтому на самом деле селектор `v2.x` является сокращенной формой `v2.A.x` . По той же причине селектор `v2.y` — это сокращенная форма `v2.A.y` , а не `v2.C.B.y` .

```go
var v2 struct {
	A
	C
}

func f2() {
	fmt.Printf("%T \n", v2.x) // string
	fmt.Printf("%T \n", v2.y) // func(int) bool
}

```

Сталкивающиеся или затененные селекторы не препятствуют продвижению их более глубоких селекторов. Например, в следующем примере селекторы `.M` и по- `.z` прежнему повышаются.

```go
package main

type x string
func (x) M() {}

type y struct {
	z byte
}

type A struct {
	x
}
func (A) y(int) bool {
	return false
}

type B struct {
	y
}
func (B) x(string) {}

func main() {
	var v struct {
		A
		B
	}
	//_ = v.x // error: ambiguous selector v.x
	//_ = v.y // error: ambiguous selector v.y
	_ = v.M // ok. <=> v.A.x.M
	_ = v.z // ok. <=> v.B.y.z
}

```

Одна необычная деталь, которую следует отметить, заключается в том, что два неэкспортированных метода (или поля) из двух разных пакетов всегда рассматриваются как два разных идентификатора, даже если их имена идентичны. Таким образом, они никогда не будут конфликтовать или затенять друг друга, когда их типы владельцев встроены в один и тот же тип структуры. Например, программа, состоящая из двух пакетов, как показано ниже, будет нормально компилироваться и работать. Но если все `m()` вхождения заменить на `M()` , то программа не скомпилируется `A.M` и будет `B.M` конфликтовать друг с другом, поэтому `c.M` это недействительный селектор.

```go
package foo // import "x.y/foo"

import "fmt"

type A struct {
	n int
}

func (a A) m() {
	fmt.Println("A", a.n)
}

type I interface {
	m()
}

func Bar(i I) {
	i.m()
}

```

```go
package main

import "fmt"
import "x.y/foo"

type B struct {
	n bool
}

func (b B) m() {
	fmt.Println("B", b.n)
}

type C struct{
	foo.A
	B
}

func main() {
	var c C
	c.m()      // B false
	foo.Bar(c) // A 0
}

```

### Неявные методы встраивания типов

Как упоминалось выше, и у типа, `Singer` и у типа `*Singer` есть `PrintName` метод, и у типа `*Singer` тоже есть `SetAge` метод. Однако мы никогда явно не объявляем эти методы для двух типов. Откуда берутся эти методы?

На самом деле, предположим, что тип структуры `S` встраивает тип (или псевдоним типа) `T` и встраивание допустимо,

*   для каждого метода встроенного типа `T` , если селекторы этого метода не сталкиваются с другими селекторами и не затеняются ими, тогда компиляторы неявно объявят соответствующий метод с той же спецификацией для встраиваемого типа структуры `S` . И, следовательно, компиляторы также будут [неявно объявлять соответствующий метод](https://go101.org/article/method.html#implicit-pointer-methods) для типа указателя `*S` .
*   для каждого метода типа указателя `*T` , если селекторы этого метода не сталкиваются с другими селекторами и не затеняются ими, тогда компиляторы неявно объявят соответствующий метод с той же спецификацией для типа указателя `*S` .

Проще говоря,

*   type `struct{T}` и type `*struct{T}` оба получают все методы типа, обозначенного `T` .type `*struct{T}` .
*   type `*struct{T}` , type `struct{*T}` и type `*struct{*T}` получают все методы type `*T` .

Следующие (продвинутые) методы неявно объявляются компиляторами для type `Singer` и type `*Singer` .

```go
// Note: these declarations are not legal Go syntax.
// They are shown here just for explanation purpose.
// They indicate how implicit method values are
// evaluated (see the next section for more).
func (s Singer) PrintName = s.Person.PrintName
func (s *Singer) PrintName = (*s).Person.PrintName
func (s *Singer) SetAge = (&(*s).Person).SetAge

```

Правые части — это соответствующие селекторы полной формы.

Из методов статьи [в Go](https://go101.org/article/method.html) мы знаем, что нельзя явно объявлять методы для безымянных типов структур и безымянных типов указателей, чьи базовые типы являются безымянными структурными типами. Но благодаря встраиванию типов такие безымянные типы также могут владеть методами.

Если тип структуры включает тип, который реализует тип интерфейса (встроенный тип может быть самим типом интерфейса), то, как правило, тип структуры также реализует тип интерфейса, за исключением того, что существует метод, указанный типом интерфейса, затененный или конфликтующий с другим типом. методы или поля. Например, в приведенном выше примере программы и тип встраиваемой структуры, и тип указателя, базовым типом которого является тип встраиваемой структуры, реализуют тип интерфейса `I` .

Обратите внимание, что тип получает только методы тех типов, которые он встраивает прямо или косвенно. Другими словами, набор методов типа состоит из методов, объявленных непосредственно (явно или неявно) для типа, и набора методов базового типа типа. Например, в следующем коде

*   у типа `Age` нет методов, потому что он не встраивает никаких типов.
*   тип `X` имеет два метода `IsOdd` и `Double` . `IsOdd` получается встраиванием типа `MyInt` .
*   у типа `Y` нет методов, потому что встроенный тип `Age` не имеет методов.
*   у типа `Z` есть только один метод, `IsOdd` который получается встраиванием типа `MyInt` . Он не получает метод `Double` из типа `X` , поскольку он не встраивает тип `X` .

```go
type MyInt int
func (mi MyInt) IsOdd() bool {
	return mi%2 == 1
}

type Age MyInt

type X struct {
	MyInt
}
func (x X) Double() MyInt {
	return x.MyInt + x.MyInt
}

type Y struct {
	Age
}

type Z X

```

### Нормализация и оценка значений продвигаемого метода

Предположим `v.m` , что это допустимое выражение значения продвинутого метода, компиляторы нормализуют его в результате замены неявных операций взятия адреса и разыменования указателя на явные в соответствующем селекторе полной формы `v.m` .

Так же, как и при любой другой [оценке значения метода](https://go101.org/article/method.html#method-value-evaluation) , для нормализованного выражения значения метода `v.m` во время выполнения, когда оценивается значение метода `v.m` , оценивается аргумент получателя `v` , а копия результата оценки сохраняется и используется в последующих вызовах значения метода. .

Например, в следующем коде

*   селектор полной формы расширенного выражения метода `s.M1` — `s.T.X.M1` . После изменения в нем операций неявного взятия адреса и разыменования указателя он становится `(*s.T).X.M1` . Во время выполнения `(*s.T).X` оценивается аргумент получателя, а копия результата оценки сохраняется и используется в последующих вызовах повышенного значения метода. Результат оценки `1` , поэтому вызов `f()` всегда печатает `1` .
*   селектор полной формы расширенного выражения метода `s.M2` — `s.T.X.M2` . После изменения в нем операций неявного взятия адреса и разыменования указателя он становится `(&(*s.T).X).M2` . Во время выполнения `&(*s.T).X` оценивается аргумент получателя, а копия результата оценки сохраняется и используется в последующих вызовах повышенного значения метода. Результатом оценки является адрес поля `s.X` (он же `(*s.T).X` ). Любое изменение значения `s.X` будет отражаться через разыменование адреса, но изменения значения `s.T` не влияют на результат оценки, поэтому оба `g()` вызова print `2` .

```go
package main

import "fmt"

type X int

func (x X) M1() {
	fmt.Println(x)
}

func (x *X) M2() {
	fmt.Println(*x)
}

type T struct { X }

type S struct { *T }

func main() {
	var t = &T{X: 1}
	var s = S{T: t}
	var f = s.M1 // <=> (*s.T).X.M1
	var g = s.M2 // <=> (&(*s.T).X).M2
	s.X = 2
	f() // 1
	g() // 2
	s.T = &T{X: 3}
	f() // 1
	g() // 2
}

```

### Типы интерфейсов Типы встроенных интерфейсов

Не только структурные типы могут встраивать другие типы, но также могут встраивать интерфейсные типы, но интерфейсные типы могут встраивать только интерфейсные типы. Пожалуйста, прочитайте [интерфейсы в Go](https://go101.org/article/interface.html) для деталей.

### Интересный пример встраивания типов

В заключение рассмотрим интересный пример. Пример программы будет мертвым циклом и переполнением стека. Если вы поняли вышеприведенное содержание , [полиморфизм](https://go101.org/article/interface.html#polymorphism) и встраивание типов, легко понять, почему это будет мертвая петля.

```go
package main

type I interface {
	m()
}

type T struct {
	I
}

func main() {
	var t T
	var i = &t
	t.I = i
	i.m() // will call t.m(), then call i.m() again, ...
}
```
