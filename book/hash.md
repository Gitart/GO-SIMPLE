# Объясните термин Криптография вкратце

Термин «криптография» происходит от двух греческих слов, а именно «криптография» и «графика». Согласно греческому языку, крипто означает секрет, а графическое означает письмо. Термин криптография стал более популярным с введением всех криптовалют, таких как биткойн, эфириум и лайткойн.


# Ривест\-Шамир\-Адлеман (ЮАР)

В 1977 году три молодых ученых Рон Ривест, Ади Шамир и Леонард Адлеман из Массачусетского технологического института (MIT) взяли концепцию криптографии с открытым ключом и разработали алгоритм, который мы назвали алгоритмом RSA. Используя первые буквы своих фамилий, они получили RSA. Этот алгоритм использует криптографию с открытым ключом (также называемую асимметричным шифрованием), поэтому он использует два разных ключа для шифрования и дешифрования данных. В RSA генерируется пара ключей, где один ключ раскрывается во внешнем мире, известный как открытый ключ, а другой хранит секрет пользователя, известный как закрытый ключ. Они разработали этот алгоритм для решения двух ключевых проблем: создания защищенных соединений без необходимости доверять отдельному координатору распределения ключей ваш ключ и для проверки того, что сообщение не повреждено заявленным отправителем.

---

## Основная концепция RSA

В криптографии с асимметричным ключом она генерирует пару ключей. Открытый ключ публикуется с другой стороны, закрытый ключ остается секретным. Эти два ключа численно связаны друг с другом. Поскольку он генерирует эти ключи с помощью односторонней функции, невозможно создать закрытый ключ после того, как он узнает открытый ключ, и наоборот. Сообщение, зашифрованное с помощью ключа, нецелесообразно дешифровать с использованием аналогичного ключа. Следовательно, секретность сообщения остается защищенной.

Предположим, что Алиса и Боб должны передавать секретные сообщения между собой, используя алгоритм RSA. Сначала они генерируют свои надлежащие наборы ключей и публикуют открытый ключ, чтобы другой орган мог получить к нему доступ.
Их открытые и закрытые ключи обозначены следующим образом:
**Public\-A** и **Private\-A** для Алисы
**Public\-B** и **Private\-B** для Bob.

Когда Алиса отправляет сообщение Бобу, она шифрует сообщение (M) с помощью Public\-B и генерирует зашифрованный текст (C) по формуле:
**C = Public\-B (M).**

Получив Cipher\-B, Боб может расшифровать сообщение, используя свой закрытый ключ Private\-B. Это может быть формально выражено как:
**M = Private\-B (C)**

Каждая из сторон хранит свой секретный ключ в секрете друг от друга. Следовательно, сообщение, зашифрованное с использованием открытого ключа, может быть дешифровано только с помощью соответствующего закрытого ключа.
 ---
 

---

## Что такое криптография?

Проще говоря, процесс изменения сообщений таким образом, что их значение скрыто от врага или противника, который может их захватить, известен как криптография. Криптография \- это наука о секретном письме, которая использует многочисленные методы для защиты информации, представленной в нечитаемом формате. Только указанные получатели могут быть преобразованы в этот нечитаемый формат в читаемый формат.

В безопасных электронных транзакциях применяются криптографические методы для защиты сообщений электронной почты, данных кредитной карты, аудио / видео трансляции, носителей информации и другой конфиденциальной информации. Используя криптографические системы, отправитель может сначала зашифровать сообщение, а затем передать его через сеть. С другой стороны, получатель может расшифровать сообщение и восстановить его исходное содержимое.

---

## Компоненты криптографии

**Открытый текст:** открытый текст может быть текстом, двоичным кодом или изображением, которое необходимо преобразовать в формат, который не может быть прочитан никем, кроме тех, кто хранит секрет его разблокировки. Это относится к исходному незашифрованному или неизмененному сообщению, которое отправитель желает отправить.

**Зашифрованный** *текст* **:** в процессе шифрования *открытый текст* преобразуется в формат срочно, результирующий формат называется зашифрованным текстом. Это относится к зашифрованному сообщению, которое получает получатель. Однако зашифрованный текст подобен открытому тексту, который использовался в процессе шифрования для воспроизведения окончательного результата. Этот окончательный вывод содержит исходное сообщение, хотя и в формате, который не может быть извлечен, если официальное лицо не знает правильных средств или не сможет взломать код.

**Шифрование.** Шифрование получает информацию и преобразует ее в нечитаемый формат, который можно перевернуть. Это процесс шифрования открытого текста, чтобы он мог предоставить зашифрованный текст. Шифрованию нужен алгоритм, называемый шифром и секретным ключом. Никто не может расшифровать важную информацию в зашифрованном сообщении, не зная секретного ключа. Открытый текст преобразуется в зашифрованный текст с использованием шифровального шифра.

**Расшифровка:** это обратный процесс шифрования, в котором он преобразует зашифрованный текст обратно в открытый текст, используя алгоритм дешифрования и секретный ключ. При симметричном шифровании ключ, используемый для расшифровки, совпадает с ключом, используемым для шифрования. С другой стороны, при асимметричном шифровании или шифровании с открытым ключом ключ, используемый для расшифровки, отличается от ключа, используемого для шифрования.

**Шифры.** Алгоритмы шифрования и дешифрования вместе называются шифрами. Возможно, самая хитрая, интересная и самая любопытная часть в процессе шифрования \- это алгоритм или шифр. Алгоритм или шифр \- это не более чем формула, которая включает в себя различные этапы, иллюстрирующие, как процесс шифрования / дешифрования реализуется в информации. Базовый шифр принимает биты и возвращает биты, и не имеет значения, представляют ли биты текстовую информацию, изображение или видео.

**Ключ:** Ключ \- это, как правило, число или набор чисел, с которыми работает шифр. В технических терминах ключ \- это отдельный фрагмент информации, который используется для управления выводом (зашифрованный и открытый текст) данного криптографического алгоритма. Алгоритмы шифрования и дешифрования нуждаются в этом ключе для шифрования или дешифрования сообщений соответственно. Отправитель использует алгоритм шифрования и секретный ключ для преобразования открытого текста в зашифрованный. С другой стороны, получатель использует тот же алгоритм дешифрования и секретный ключ для преобразования зашифрованного текста обратно в открытый текст. Чем длиннее секретный ключ, тем сложнее злоумышленнику расшифровать сообщение.

![Компоненты криптографии](https://www.golangprograms.com/media/wysiwyg/components.jpg)

---

## Пример криптографии (классический шифр)

Ниже приведен очень простой пример, мы создали простой шифр для шифрования и дешифрования открытого текста в зашифрованный текст и наоборот. Алгоритм cipherAlgorithm () одинаков для шифрования и дешифрования. Ключ, который мы использовали, это 01, 10 и 15 для шифрования и дешифрования сообщения. Вывод шифрования отличается каждый раз, когда ключ отличается. Этот шифр сдвигает букву на основе значения ключа, ключ играет важную роль в криптографии.


```golang
package main
 
import (
    "fmt"
    "unicode"
)
 
// Cipher encrypts and decrypts a string.
type Cipher interface {
    Encryption(string) string
    Decryption(string) string
}
 
// Cipher holds the key used to encrypts and decrypts messages.
type cipher []int
 
// cipherAlgorithm encodes a letter based on some function.
func (c cipher) cipherAlgorithm(letters string, shift func(int, int) int) string {
    shiftedText := ""
    for _, letter := range letters {
        if !unicode.IsLetter(letter) {
            continue
        }
        shiftDist := c[len(shiftedText)%len(c)]
        s := shift(int(unicode.ToLower(letter)), shiftDist)
        switch {
        case s < 'a':
            s += 'z' - 'a' + 1
        case 'z' < s:
            s -= 'z' - 'a' + 1
        }
        shiftedText += string(s)
    }
    return shiftedText
}
 
// Encryption encrypts a message.
func (c *cipher) Encryption(plainText string) string {
    return c.cipherAlgorithm(plainText, func(a, b int) int { return a + b })
}
 
// Decryption decrypts a message.
func (c *cipher) Decryption(cipherText string) string {
    return c.cipherAlgorithm(cipherText, func(a, b int) int { return a - b })
}
 
// NewCaesar creates a new Caesar shift cipher.
func NewCaesar(key int) Cipher {
    return NewShift(key)
}
 
// NewShift creates a new Shift cipher.
func NewShift(shift int) Cipher {
    if shift < -25 || 25 < shift || shift == 0 {
        return nil
    }
    c := cipher([]int{shift})
    return &c
}
 
func main() {
    c := NewCaesar(1)
    fmt.Println("Encrypt Key(01) abcd =>", c.Encryption("abcd"))
    fmt.Println("Decrypt Key(01) bcde =>", c.Decryption("bcde"))
    fmt.Println()
 
    c = NewCaesar(10)
    fmt.Println("Encrypt Key(10) abcd =>", c.Encryption("abcd"))
    fmt.Println("Decrypt Key(10) klmn =>", c.Decryption("klmn"))
    fmt.Println()
 
    c = NewCaesar(15)
    fmt.Println("Encrypt Key(15) abcd =>", c.Encryption("abcd"))
    fmt.Println("Decrypt Key(15) pqrs =>", c.Decryption("pqrs"))
}
```
