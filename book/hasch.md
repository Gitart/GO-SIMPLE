# Что такое хеширование?

Процесс взятия открытого текста и преобразования его в дайджест информации открытого текста таким образом, что она не предназначена для дешифрования, называется хешированием. Результат хеширования известен как хеш, хэш\-значение или дайджест сообщения. Хеширование является интригующей областью криптографии и отличается от алгоритмов шифрования. Хеширование создает закодированный вывод, который не может быть легко изменен. Технически, хеширование генерирует значение фиксированной длины, которое относительно легко вычислить в одном направлении, но практически невозможно изменить.

---

## Основы хеширования

Хеш, хеш\-значение или дайджест сообщения \- это значение, которое является выводом открытого текста или зашифрованного текста, передаваемого в алгоритм хеширования. Независимо от того, что вводится в алгоритм хеширования, хеш имеет фиксированную длину и всегда будет иметь определенную длину. Полученный хэш имеет длину, установленную самим алгоритмом. Мы также называем хэш сводкой файла или сообщения, часто в числовом формате. Хэши используются в цифровых подписях, в аутентификации файлов и сообщений, а также для защиты целостности конфиденциальных данных.

Хэш может иметь место в категории односторонней функции. Это показывает, что хеш может вычисляться, когда генерируется, но трудно (или невозможно) вычислить в обратном порядке. При использовании хэша первоначальное вычисление относительно легко создать сжатую версию сообщения, но исходное сообщение не должно быть воссоздано из хэша.

---

## Криптографические хэш\-функции

Простейший подход к хэшированию сообщения состоит в том, чтобы разделить его на куски и последовательно обработать каждый кусок, используя аналогичный алгоритм. Этот подход называется итеративным хешированием. Итеративное хеширование использует функцию сжатия, которая преобразует входные данные в меньшие выходные данные; и преобразует входной сигнал в выходной сигнал одинакового размера, так что любые два разных входных сигнала дают два разных выходных сигнала. Криптографические хеш\-функции \- это те хеш\-функции, которые основаны на блочных шифрах. Примеры криптографических хэш\-функций включают в себя алгоритм на основе дайджеста сообщений (MD), такой как MD2, MD4 и MD5, и алгоритм на основе защищенного хэша (SHA), такой как SHA\-1, SHA\-224, SHA\-256, SHA\-384 и SHA\-512.

---

### Message\-Digest алгоритм 5 (MD5)

Этот криптографический алгоритм хеширования был разработан Роном Ривестом в 1991 году. Этот алгоритм принимает сообщение переменной длины в качестве входных данных и генерирует дайджест сообщения фиксированной длины из 128 битов. Этот алгоритм использует схему с прямым порядком байтов, в которой младший значащий байт 32\-разрядного слова будет храниться в позиции младшего байта. Этот алгоритм проходит четыре раунда, каждый из которых имеет 16 итераций, поэтому они используют всего 64 итерации. Следовательно, требуется 128\-битный буфер. Это менее безопасно, но быстрее в работе по сравнению с SHA\-1. Этот алгоритм требует 21 28 операций для обнаружения исходного сообщения из данного дайджеста сообщения и 2 64 операций для обнаружения двух сообщений, генерирующих один и тот же дайджест сообщения.

### Безопасный алгоритм хеширования (SHA\-1)

Этот алгоритм принимает сообщение переменной длины в качестве входных данных и генерирует дайджест сообщения фиксированной длины в 160 бит. Этот алгоритм использует схему Little\-endian для интерпретации сообщения как последовательности 32\-битных слов. В этом алгоритме старший значащий байт 32\-битного слова сохраняется в позиции младшего байта. Этот алгоритм проходит четыре раунда, каждый из которых имеет 20 итераций, поэтому они используют в общей сложности 80 итераций. Следовательно, требуется 160\-битный буфер. Это более безопасно, но медленнее в работе по сравнению с MD5. Этот алгоритм требует 21 60 операций для обнаружения исходного сообщения из данного дайджеста сообщения и 2 80 операций для обнаружения двух сообщений, генерирующих один и тот же дайджест сообщения.

#### Краткий пример, иллюстрирующий использование криптографических хеш\-функций


```go
package main
 
import (
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"fmt"
)
 
func main() {
	fmt.Println("\n----------------Small Message----------------\n")
	message := []byte("Today web engineering has modern apps adhere to what is known as a single-page app (SPA) model.")
 
	fmt.Printf("Md5: %x\n\n", md5.Sum(message))
	fmt.Printf("Sha1: %x\n\n", sha1.Sum(message))
	fmt.Printf("Sha256: %x\n\n", sha256.Sum256(message))
	fmt.Printf("Sha512: %x\n\n", sha512.Sum512(message))
 
	fmt.Println("\n\n----------------Large Message----------------\n")
	message = []byte("Today web engineering has modern apps adhere to what is known as a single-page app (SPA) model. This model gives you an experience in which you never navigate to particular pages or even reload a page.  It loads and unloads the various views of our app into the same page itself. If you've ever run popular web apps like Gmail, Facebook, Instagram, or Twitter, you've used a single-page app. In all those apps, the content gets dynamically displayed without requiring you to refresh or navigate to a different page. React gives you a powerful subjective model to work with and supports you to build user interfaces in a declarative and component-driven way.")
 
	fmt.Printf("Md5: %x\n\n", md5.Sum(message))
	fmt.Printf("Sha1: %x\n\n", sha1.Sum(message))
	fmt.Printf("Sha256: %x\n\n", sha256.Sum256(message))
	fmt.Printf("Sha512: %x\n\n", sha512.Sum512(message))
}
 
```
