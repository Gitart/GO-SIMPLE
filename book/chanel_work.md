# Работа с каналами

Go предоставляет механизм, называемый каналом, который используется для обмена данными между программами. Когда вы выполняете параллельное действие в качестве программы, ресурс или данные должны быть разделены между программами, каналы действуют как канал (канал) между программами и предоставляют механизм, который гарантирует синхронный обмен.
Тип данных должен быть указан во время объявления канала. Мы можем делиться значениями и указателями встроенных, именованных, структурных и ссылочных типов. Данные передаются по каналам: только одна процедура имеет доступ к элементу данных в любой момент времени, поэтому не может происходить гонка данных.

Существует два типа каналов, основанных на их поведении обмена данными: небуферизованные каналы и буферизованные каналы. Небуферизованный канал используется для выполнения синхронной связи между программами, в то время как буферизованный канал используется для выполнения асинхронной связи. Небуферизованный канал обеспечивает гарантию того, что обмен между двумя программами будет выполнен в момент отправки и получения. Буферизованный канал не имеет такой гарантии.

**Канал создается функцией make, которая задает ключевое слово chan и тип элемента канала.**

### Вот блок кода, который создает небуферизованный и буферизованный канал:



`Unbuffered :=` `make``(``chan` `int)` `// Unbuffered channel of integer type`

`buffered :=` `make``(``chan` `int,` `10` `)` `// Buffered channel of integer type`


Использование встроенной функции *макияжа* , чтобы создать как небуферизованный и буферизованный канал. Первый аргумент *макияж* требует ключевого слова *чан* , а затем тип данных , канал позволит обмениваться.

### Вот блок кода для отправки значения в канал требует использования оператора <\-:

`goroutine1 :=` `make``(``chan` `string,` `5` `)` `// Buffered channel of strings.`

`goroutine1 <-` `"Australia"` `// Send a string through the channel.`


Канал goroutine1 типа string, содержащий буфер из 5 значений. Затем мы отправляем строку «Австралия» через канал.

### Вот кодовый блок, который получает значения из канала:
`data := <-goroutine1` `// Receive a string from the channel.`

 |

Оператор <\- присоединен к левой стороне переменной канала (goroutine1), чтобы получить значение из канала.

## Небуферизованные каналы

В небуферизованном канале нет возможности хранить какое\-либо значение до его получения. В каналах этого типа и отправляющая, и принимающая программы должны быть готовы в одно и то же время, прежде чем любая операция отправки или получения может быть завершена. Если две подпрограммы не готовы в одно и то же время, канал заставляет подпрограмму, выполняющую соответствующую операцию отправки или получения, сначала подождать. Синхронизация имеет основополагающее значение при взаимодействии между отправкой и получением на канале. Одно не может случиться без другого.

## Буферизованные каналы

В буферизованном канале есть возможность хранить одно или несколько значений до их получения. В каналах этого типа не заставляйте программы в одно и то же время быть готовыми к отправке и получению. Существуют также различные условия, когда отправка или получение блокируется. Прием будет блокироваться, только если в канале нет значения для приема. Отправка блокируется, только если нет доступного буфера для размещения отправляемого значения.


```golang
// Simple program to demonstrate use of Buffered Channel
 
package main
 
import (
    "fmt"  
    "math/rand"
    "sync"
    "time"
)
 
var goRoutine sync.WaitGroup
 
func main(){
    rand.Seed(time.Now().Unix())
 
    // Create a buffered channel to manage the employee vs project load.
    projects := make(chan string,10)
 
    // Launch 5 goroutines to handle the projects.
    goRoutine.Add(5)
    for i :=1; i <= 5; i++ {
        go employee(projects, i)
    }
 
    for j :=1; j <= 10; j++ {
        projects <- fmt.Sprintf("Project :%d", j)
    }
 
    // Close the channel so the goroutines will quit    
    close(projects)
    goRoutine.Wait()
}
 
func employee(projects chan string, employee int) {
    defer goRoutine.Done()
    for {
        // Wait for project to be assigned.
        project, result := <-projects
 
        if result==false {
            // This means the channel is empty and closed.
            fmt.Printf("Employee : %d : Exit\n", employee)
            return
        }
 
        fmt.Printf("Employee : %d : Started   %s\n", employee, project)
 
        // Randomly wait to simulate work time.
        sleep := rand.Int63n(50)
        time.Sleep(time.Duration(sleep) * time.Millisecond)
        // Display time to wait
        fmt.Println("\nTime to sleep",sleep,"ms\n")
 
        // Display project completed by employee.
        fmt.Printf("Employee : %d : Completed %s\n", employee, project)
    }
 
}
```

Каждый раз, когда вы запускаете эту программу, выходные данные для этой программы будут отличаться из-за случайного характера программы и планировщика Go.
В вышеприведенной программе буферизованный канал типа string создается с емкостью 10. WaitGroup присваивается число 5, по одному на каждую программу. 10 строк отправляются в канал, чтобы смоделировать или воспроизвести проект для goroutines. Как только последняя строка будет отправлена ​​в канал, канал будет закрыт, и основная функция ожидает завершения всего проекта.

