# Распространенные ошибки параллельного программирования

Go — это язык, поддерживающий встроенное параллельное программирование. Используя `go` ключевое слово для создания горутин (облегченных потоков), а также [используя](https://go101.org/article/channel-use-cases.html) [каналы](https://go101.org/article/channel.html) и [другие](https://go101.org/article/concurrent-atomic-operation.html) [методы параллельной синхронизации,](https://go101.org/article/concurrent-synchronization-more.html) предоставляемые в Go, параллельное программирование становится простым, гибким и приятным.

С другой стороны, Go не мешает программистам Go совершать некоторые параллельные ошибки программирования, вызванные либо небрежностью, либо отсутствием опыта. В оставшейся части текущей статьи будут показаны некоторые распространенные ошибки в параллельном программировании Go, чтобы помочь программистам Go избежать таких ошибок.

### Никаких синхронизаций, когда они необходимы

Строки кода могут выполняться [не в порядке их появления](https://go101.org/article/memory-model.html) .

В следующей программе есть две ошибки.

*   Во-первых, чтение `b` в основной горутине и запись `b` в новой горутине могут вызвать гонки данных.
*   Во-вторых, условие `b == true` не может гарантировать это `a != nil` в основной горутине. Компиляторы и ЦП могут выполнять оптимизацию, [переупорядочивая инструкции](https://go101.org/article/memory-model.html) в новой горутине, поэтому назначение `b` может произойти до назначения `a` во время выполнения, что делает этот срез `a` неподвижным, `nil` когда элементы `a` изменяются в основной горутине.

```go
package main

import (
	"time"
	"runtime"
)

func main() {
	var a []int // nil
	var b bool  // false

	// a new goroutine
	go func () {
		a = make([]int, 3)
		b = true // write b
	}()

	for !b { // read b
		time.Sleep(time.Second)
		runtime.Gosched()
	}
	a[0], a[1], a[2] = 0, 1, 2 // might panic
}

```

Вышеупомянутая программа может хорошо работать на одном компьютере, но может вызывать панику на другом, или она работает хорошо, когда компилируется одним компилятором, но вызывает панику при использовании другого компилятора.

Мы должны использовать каналы или методы синхронизации, предусмотренные в `sync` стандартном пакете, чтобы обеспечить порядок памяти. Например,

```go
package main

func main() {
	var a []int = nil
	c := make(chan struct{})

	go func () {
		a = make([]int, 3)
		c <- struct{}{}
	}()

	<-c
	// The next line will not panic for sure.
	a[0], a[1], a[2] = 0, 1, 2
}

```

### Используйте `time.Sleep` вызовы для синхронизации

Давайте рассмотрим простой пример.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	var x = 123

	go func() {
		x = 789 // write x
	}()

	time.Sleep(time.Second)
	fmt.Println(x) // read x
}

```

Мы ожидаем, что эта программа напечатает `789` . На самом деле, это действительно печатает `789` , почти всегда, в беге. Но это программа с хорошей синхронизацией? Нет! Причина в том, что среда выполнения Go не гарантирует, что запись `x` произойдет раньше, чем чтение `x` . При определенных условиях, например, когда большая часть ресурсов ЦП потребляется некоторыми другими ресурсоемкими программами, работающими в той же ОС, запись `x` может происходить после чтения `x` . Вот почему мы никогда не должны использовать `time.Sleep` вызовы для синхронизации в формальных проектах.

Давайте рассмотрим другой пример.

```go
package main

import (
	"fmt"
	"time"
)

var x = 0

func main() {
	var num = 123
	var p = &num

	c := make(chan int)

	go func() {
		c <- *p + x
	}()

	time.Sleep(time.Second)
	num = 789
	fmt.Println(<-c)
}

```

Что вы ожидаете от программы? `123` , или `789` ? Фактически вывод зависит от компилятора. Для стандартного компилятора Go 1.19 вполне возможно, что программа выведет файлы `123` . Но теоретически он также может выводить `789` .

Теперь давайте изменим и `c <- *p + x` снова `c <- *p` запустим программу, вы обнаружите, что вывод становится `789` (для стандартного компилятора Go 1.19). Опять же, вывод зависит от компилятора.

Да, в вышеуказанной программе есть гонки данных. Выражение `*p` может оцениваться до, после или во время `num = 789` обработки присваивания. Вызов `time.Sleep` не может гарантировать, что оценка `*p` произойдет до обработки назначения.

В этом указанном примере мы должны сохранить значение, которое будет отправлено, во временном значении перед созданием новой горутины и вместо этого отправить временное значение в новой горутине, чтобы удалить гонки данных.

```go
...
	tmp := *p
	go func() {
		c <- tmp
	}()
...

```

### Оставьте горутины висящими

Висячие горутины — это горутины, навсегда остающиеся в заблокированном состоянии. Есть много причин, по которым горутины зависают. Например,

*   горутина пытается получить значение из канала, на который больше никакие другие горутины не будут отправлять значения.
*   горутина пытается отправить значение в нулевой канал или в канал, из которого больше никакие другие горутины не будут получать значения.
*   горутина заблокирована сама по себе.
*   группа горутин заблокирована друг другом.
*   горутина блокируется при выполнении `select` блока кода без `default` ветвления, и все операции канала, следующие за `case` ключевыми словами в `select` блоке кода, блокируются навсегда.

За исключением случаев, когда мы намеренно допускаем зависание основной горутины в программе, чтобы избежать выхода программы, большинство других случаев зависания горутины являются неожиданными. Среде выполнения Go трудно определить, зависла ли горутина в состоянии блокировки или временно остается в заблокированном состоянии, поэтому среда выполнения Go никогда не освободит ресурсы, потребляемые зависшей горутиной.

В случае использования канала с [первым ответом](https://go101.org/article/channel-use-cases.html#first-response-wins) , если пропускная способность канала, который используется в будущем, недостаточно велика, некоторые более медленные горутины ответа будут зависать при попытке отправить результат в будущий канал. Например, если будет вызвана следующая функция, 4 горутины навсегда останутся в состоянии блокировки.

```go
func request() int {
	c := make(chan int)
	for i := 0; i < 5; i++ {
		i := i
		go func() {
			c <- i // 4 goroutines will hang here.
		}()
	}
	return <-c
}

```

Чтобы избежать зависания четырех горутин, пропускная способность канала `c` должна быть не менее `4` .

Во [втором способе реализации варианта использования канала с первым ответом](https://go101.org/article/channel-use-cases.html#first-response-wins-2) , если канал, который используется в качестве будущего/обещания, является небуферизованным каналом, как показано в следующем коде, возможно, что получатель канала пропустит все ответы и вешать.

```go
func request() int {
	c := make(chan int)
	for i := 0; i < 5; i++ {
		i := i
		go func() {
			select {
			case c <- i:
			default:
			}
		}()
	}
	return <-c // might hang here
}

```

Причина, по которой горутина-получатель может зависнуть, заключается в том, что если все пять операций попытки-отправки происходят до того, как операция приема `<-c` будет готова, то все пять операций попытки-отправки не смогут отправить значения, так что вызывающая горутина никогда не получит значение.

Изменение канала `c` в качестве буферизованного гарантирует, что по крайней мере одна из пяти операций try-send будет выполнена успешно, так что горутина вызывающего абонента никогда не зависнет в указанной выше функции.

### Скопируйте значения типов в `sync` стандартный пакет

На практике значения типов (кроме `Locker` значений интерфейса) в `sync` стандартном пакете никогда не должны копироваться. Мы должны копировать только указатели таких значений.

Ниже приведен плохой пример параллельного программирования. В этом примере при `Counter.Value` вызове метода `Counter` будет скопировано значение получателя. В качестве поля значения получателя будет также скопировано соответствующее `Mutex` поле значения получателя. `Counter` Копия не синхронизирована, поэтому скопированное `Mutex` значение может быть повреждено. Даже если он не поврежден, он защищает использование скопированного поля `n` , что в общем случае бессмысленно.

```go
import "sync"

type Counter struct {
	sync.Mutex
	n int64
}

// This method is okay.
func (c *Counter) Increase(d int64) (r int64) {
	c.Lock()
	c.n += d
	r = c.n
	c.Unlock()
	return
}

// The method is bad. When it is called,
// the Counter receiver value will be copied.
func (c Counter) Value() (r int64) {
	c.Lock()
	r = c.n
	c.Unlock()
	return
}

```

Мы должны изменить тип получателя `Value` метода на тип указателя, `*Counter` чтобы избежать копирования `sync.Mutex` значений.

Команда `go vet` , предоставленная в Go Toolchain, сообщит о потенциально неверных копиях значений.

### Вызывайте `sync.WaitGroup.Add` метод не в том месте

Каждое `sync.WaitGroup` значение содержит внутренний счетчик. Начальное значение счетчика равно нулю. Если счетчик `WaitGroup` значения равен нулю, вызов `Wait` метода `WaitGroup` значения не будет блокироваться, в противном случае вызов блокируется до тех пор, пока значение счетчика не станет равным нулю.

Чтобы использование `WaitGroup` значения имело смысл, когда счетчик `WaitGroup` значения равен нулю, следующий вызов `Add` метода `WaitGroup` значения должен произойти до следующего вызова `Wait` метода `WaitGroup` значения.

Например, в следующей программе `Add` метод вызывается не в том месте, из-за чего окончательное напечатанное число не всегда равно `100` . На самом деле итоговое напечатанное число программы может быть произвольным числом в диапазоне `[0, 100)` . Причина в том, что ни один из `Add` вызовов метода не гарантированно произойдет до `Wait` вызова метода, что приводит к тому, что ни один из `Done` вызовов метода не гарантированно произойдет до `Wait` возврата вызова метода.

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var wg sync.WaitGroup
	var x int32 = 0
	for i := 0; i < 100; i++ {
		go func() {
			wg.Add(1)
			atomic.AddInt32(&x, 1)
			wg.Done()
		}()
	}

	fmt.Println("Wait ...")
	wg.Wait()
	fmt.Println(atomic.LoadInt32(&x))
}

```

Чтобы программа работала так, как ожидается, мы должны переместить `Add` вызовы методов из новых горутин, созданных в `for` цикле, как показано в следующем коде.

```go
...
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			atomic.AddInt32(&x, 1)
			wg.Done()
		}()
	}
...

```

### Используйте каналы как фьючерсы/обещания неправильно

[Из примеров использования канала](https://go101.org/article/channel-use-cases.html) в статье мы знаем, что некоторые функции будут возвращать [каналы как фьючерсы](https://go101.org/article/channel-use-cases.html#future-promise) . Предположим , что `fa` и `fb` две такие функции, тогда следующий вызов неправильно использует будущие аргументы.

```go
doSomethingWithFutureArguments(<-fa(), <-fb())

```

В приведенной выше строке кода поколения двух аргументов обрабатываются последовательно, а не одновременно.

Мы должны изменить его следующим образом, чтобы обрабатывать их одновременно.

```go
ca, cb := fa(), fb()
doSomethingWithFutureArguments(<-ca, <-cb)

```

### Закрыть каналы не из горутины последнего активного отправителя

Распространенной ошибкой программистов Go является закрытие канала, когда есть еще какие-то другие горутины, которые потенциально могут отправлять значения в канал позже. Когда такой потенциальный посыл (в закрытый канал) действительно происходит, может возникнуть паника.

Эта ошибка когда-либо была допущена в некоторых известных проектах Go, таких как [эта ошибка](https://github.com/kubernetes/kubernetes/pull/45291/files?diff=split) и [эта ошибка](https://github.com/kubernetes/kubernetes/pull/39479/files?diff=split) в проекте kubernetes.

Прочтите [эту статью](https://go101.org/article/channel-closing.html) , чтобы узнать, как безопасно и изящно закрывать каналы.

### Выполнять 64-разрядные атомарные операции над значениями, для которых не гарантируется выравнивание по 8 байтам

Адрес значения, участвующего в 64-битной атомарной операции без метода, должен быть выровнен по 8 байтам. Если этого не сделать, текущая горутина может запаниковать. Для стандартного компилятора Go такой сбой может [случиться только на 32-битных архитектурах](https://golang.org/pkg/sync/atomic/#pkg-note-BUG) . Начиная с Go 1.19, мы можем использовать метод 64-битных атомарных операций, чтобы избежать этого недостатка. Пожалуйста, прочтите [схемы памяти](https://go101.org/article/memory-layout.html) , чтобы узнать, как гарантировать выравнивание адресов 64-битного слова по 8 байтов в 32-битных ОС.

### Не обращайте внимания на слишком много ресурсов, потребляемых вызовами `time.After` функции

Функция `After` в `time` стандартном пакете возвращает [канал для уведомления о задержке](https://go101.org/article/channel-use-cases.html#timer) . Функция удобна, однако каждый ее вызов будет создавать новое значение `time.Timer` типа. Новое созданное `Timer` значение будет сохраняться в течение времени, указанного аргументом, переданным `After` функции. Если функция вызывается много раз за определенный период, будет `Timer` накоплено много живых значений, так что будет потребляться много памяти и вычислений.

Например, если вызывается следующая `longRunning` функция и за одну минуту приходят миллионы сообщений, то `Timer` за определенный небольшой период (несколько секунд) будут жить миллионы значений, даже если большая часть этих `Timer` значений уже стала бесполезной.

```go
import (
	"fmt"
	"time"
)

// The function will return if a message
// arrival interval is larger than one minute.
func longRunning(messages <-chan string) {
	for {
		select {
		case <-time.After(time.Minute):
			return
		case msg := <-messages:
			fmt.Println(msg)
		}
	}
}

```

Чтобы избежать `Timer` создания слишком большого количества значений в приведенном выше коде, мы должны использовать (и повторно использовать) одно `Timer` значение для выполнения одной и той же работы.

```go
func longRunning(messages <-chan string) {
	timer := time.NewTimer(time.Minute)
	defer timer.Stop()

	for {
		select {
		case <-timer.C: // expires (timeout)
			return
		case msg := <-messages:
			fmt.Println(msg)

			// This "if" block is important.
			if !timer.Stop() {
				<-timer.C
			}
		}

		// Reset to reuse.
		timer.Reset(time.Minute)
	}
}

```

Обратите внимание, что `if` кодовый блок используется для отбрасывания/слива возможного уведомления таймера, которое отправляется в маленьком периоде при выполнении второго блока кода ветвления.

### Используйте `time.Timer` значения неправильно

Пример идиоматического использования `time.Timer` значений был показан в последнем разделе. Некоторые пояснения:

*   метод `Stop` значения `*Timer` возвращается `false` , если соответствующее `Timer` значение уже истекло или было остановлено. Если `Stop` метод возвращает `false` , и мы знаем, что `Timer` значение еще не остановлено, значит `Timer` , срок действия значения уже истек.
*   после того, как `Timer` значение остановлено, его `C` поле канала может содержать только одно уведомление об истечении времени ожидания.
*   мы должны удалить уведомление о тайм-ауте, если оно не было удалено, из `Timer` значения тайм-аута после того, как `Timer` значение остановлено, и перед сбросом и повторным использованием `Timer` значения. В этом смысл `if` блока кода в примере из последнего раздела.

Метод `Reset` значения `*Timer` должен быть вызван, когда срок действия соответствующего `Timer` значения уже истек или был остановлен, в противном случае может произойти гонка данных между `Reset` вызовом и возможным уведомлением, отправленным в `C` поле канала `Timer` значения.

Если выбрана первая `case` ветвь `select` блока, значит `Timer` , срок действия уже истек, поэтому нам не нужно его останавливать, так как отправленное уведомление уже вынесено. Однако мы должны остановить таймер во второй ветви, чтобы проверить, существует ли уведомление об истечении времени ожидания. Если оно существует, мы должны слить его перед повторным использованием таймера, иначе уведомление будет запущено немедленно на следующем шаге цикла.

Например, следующая программа вполне может завершиться примерно за одну секунду вместо десяти секунд. И что еще более важно, программа не свободна от гонки данных.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	start := time.Now()
	timer := time.NewTimer(time.Second/2)
	select {
	case <-timer.C:
	default:
		// Most likely go here.
		time.Sleep(time.Second)
	}
	// Potential data race in the next line.
	timer.Reset(time.Second * 10)
	<-timer.C
	fmt.Println(time.Since(start)) // about 1s
}

```

Значение `time.Timer` можно оставить в неостановочном состоянии, если оно больше не используется, но в конце рекомендуется остановить его.

Это подвержено ошибкам и не рекомендуется использовать `time.Timer` значение одновременно среди нескольких горутин.

Мы не должны полагаться на возвращаемое значение `Reset` вызова метода. Возвращаемый результат `Reset` метода существует только для целей совместимости.
