# Методы параллельной синхронизации, предоставляемые в `sync` стандартном пакете

В статье [о вариантах использования канала](https://go101.org/article/channel-use-cases.html) представлено множество вариантов использования, в которых каналы используются для синхронизации данных между горутинами. На самом деле каналы — не единственные методы синхронизации, предоставляемые в Go. Существуют и другие методы синхронизации, поддерживаемые Go. В некоторых определенных обстоятельствах использование методов синхронизации, отличных от канала, более эффективно и читабельно, чем использование каналов. Ниже будут представлены методы синхронизации, предоставляемые в `sync` стандартном пакете.

Стандартный `sync` пакет предоставляет несколько типов, которые можно использовать для синхронизации в некоторых особых случаях и гарантировать определенные специальные порядки памяти. В особых случаях эти методы более эффективны и выглядят чище, чем канальные способы.

*(Обратите внимание, чтобы избежать ненормального поведения, лучше никогда не копировать значения типов из `sync` стандартного пакета.)*

### `sync.WaitGroup` Тип \_

Каждое `sync.WaitGroup` значение содержит внутренний счетчик. Начальное значение счетчика равно нулю.

Тип `*WaitGroup` имеет [три метода](https://golang.org/pkg/sync/#WaitGroup) : `Add(delta int)` , `Done()` и `Wait()` .

Для адресуемого `WaitGroup` значения `wg` ,

*   мы можем вызвать `wg.Add(delta)` метод для изменения значения счетчика, поддерживаемого `wg` .
*   вызов метода `wg.Done()` полностью эквивалентен вызову метода `wg.Add(-1)` .
*   если вызов `wg.Add(delta)` (или `wg.Done()` ) изменяет значение счетчика `wg` на отрицательное, произойдет паника.
*   когда звонит горутина `wg.Wait()` ,
    *   если счетчик, поддерживаемый `wg` уже равен нулю, то вызов `wg.Wait()` можно рассматривать как неработающий.
    *   в противном случае (счетчик положительный) горутина перейдет в состояние блокировки. Он снова войдет в рабочее состояние (также известный как `wg.Wait()` возврат вызова), когда другая горутина изменит счетчик на ноль, как правило, путем вызова `wg.Done()` .

Обратите внимание, что `wg.Add(delta)` , `wg.Done()` и `wg.Wait()` являются сокращениями `(&wg).Add(delta)` , `(&wg).Done()` и `(&wg).Wait()` , соответственно.

Как правило, `WaitGroup` значение используется для сценария, когда одна горутина ждет, пока все несколько других горутин не закончат свои соответствующие задания. Пример:

```go
package main

import (
	"log"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	const N = 5
	var values [N]int32

	var wg sync.WaitGroup
	wg.Add(N)
	for i := 0; i < N; i++ {
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			log.Println("Done:", i)
			wg.Done() // <=> wg.Add(-1)
		}()
	}

	wg.Wait()
	// All elements are guaranteed to be
	// initialized now.
	log.Println("values:", values)
}

```

В приведенном выше примере основная горутина ждет, пока все остальные `N` горутины не заполнят соответствующее значение элемента в `values` массиве. Вот один из возможных результатов вывода:

```
Done: 4
Done: 1
Done: 3
Done: 0
Done: 2
values: [71 89 50 62 60]

```

Мы можем разделить единственный `Add` вызов метода в приведенном выше примере на несколько.

```go
...
	var wg sync.WaitGroup
	for i := 0; i < N; i++ {
		wg.Add(1) // will be invoked N times
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			wg.Done()
		}()
	}
...

```

Метод `Wait` можно вызывать в нескольких горутинах. Когда счетчик станет равным нулю, все они будут уведомлены широковещательным способом.

```go
func main() {
	rand.Seed(time.Now().UnixNano())

	const N = 5
	var values [N]int32

	var wgA, wgB sync.WaitGroup
	wgA.Add(N)
	wgB.Add(1)

	for i := 0; i < N; i++ {
		i := i
		go func() {
			wgB.Wait() // wait a notification
			log.Printf("values[%v]=%v \n", i, values[i])
			wgA.Done()
		}()
	}

	// The loop is guaranteed to finish before
	// any above wg.Wait calls returns.
	for i := 0; i < N; i++ {
		values[i] = 50 + rand.Int31n(50)
	}
	// Make a broadcast notification.
	wgB.Done()
	wgA.Wait()
}

```

Значение `WaitGroup` можно использовать повторно после `Wait` возврата одного вызова его метода. Но обратите внимание, что каждый `Add` вызов метода с положительной дельтой, который происходит, когда счетчик равен нулю, должен произойти до начала любого `Wait` вызова, иначе может произойти гонка данных.

### `sync.Once` Тип \_

У `*sync.Once` значения есть `Do(f func())` метод, который принимает параметр соло с типом `func()` .

Для адресуемого `Once` значения `o` вызов метода `o.Do()` , который является сокращением от `(&o).Do()` , может выполняться одновременно несколько раз в нескольких горутинах. Аргументы этих `o.Do()` вызовов должны (но не обязаны) быть одним и тем же значением функции.

Среди этих `o.Do` вызовов методов будет вызываться только одна функция-аргумент. Вызванная функция аргумента гарантированно завершится до `o.Do` завершения вызова любого метода. Другими словами, код в вызванной функции-аргументе гарантированно будет выполнен до завершения вызова любого `o.Do` метода.

Как правило, `Once` значение используется для гарантии того, что часть кода будет выполнена ровно один раз в параллельном программировании.

Пример:

```go
package main

import (
	"log"
	"sync"
)

func main() {
	log.SetFlags(0)

	x := 0
	doSomething := func() {
		x++
		log.Println("Hello")
	}

	var wg sync.WaitGroup
	var once sync.Once
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			once.Do(doSomething)
			log.Println("world!")
		}()
	}

	wg.Wait()
	log.Println("x =", x) // x = 1
}

```

В приведенном выше примере `Hello` будет напечатано один раз, но `world!` будет напечатано пять раз. И `Hello` гарантированно будет напечатан раньше всех пяти `world!` .

### `sync.Mutex` и `sync.RWMutex` типы \_

Оба [типа](https://golang.org/pkg/sync/#Locker) `*sync.Mutex` и `*sync.RWMutex` реализуют [интерфейс `sync.Locker`](https://golang.org/pkg/sync/#Locker) . Таким образом, они оба имеют два метода `Lock` и `Unlock` , чтобы предотвратить одновременное использование части данных несколькими пользователями.

Помимо методов `Lock` и , у этого типа есть два других метода, и , чтобы избежать одновременного использования фрагмента данных некоторыми пользователями данных (писателями или читателями) и одним модулем записи данных, но разрешить некоторым читателям данных доступ к фрагменту данных в момент времени. в то же время. `Unlock` `*RWMutex` `RLock` `RUnlock`

*(Обратите внимание, что здесь термины ***чтения*** данных и ***записи данных*** не следует интерпретировать как буквальные. Они используются только для целей объяснения. Читатель данных может изменять данные, а писатель данных может только читать данные.)*

Значение `Mutex` часто называют блокировкой взаимного исключения. Нулевое `Mutex` значение — разблокированный мьютекс. Значение `Mutex` может быть заблокировано только тогда, когда оно находится в разблокированном состоянии. Другими словами, как только адресуемое `Mutex` значение `m` успешно заблокировано (иначе `m.Lock()` вызов метода возвращается), новая попытка горутины заблокировать `Mutex` значение заставит горутину войти в состояние блокировки до тех пор, пока `Mutex` значение не будет разблокировано (через более поздний `m.Unlock()` вызов).

Обратите внимание, что `m.Lock()` и `m.Unlock()` являются сокращениями `(&m).Lock()` и `(&m).Unlock()` соответственно.

Пример использования `sync.Mutex` :

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

type Counter struct {
	m sync.Mutex
	n uint64
}

func (c *Counter) Value() uint64 {
	c.m.Lock()
	defer c.m.Unlock()
	return c.n
}

func (c *Counter) Increase(delta uint64) {
	c.m.Lock()
	c.n += delta
	c.m.Unlock()
}

func main() {
	var c Counter
	for i := 0; i < 100; i++ {
		go func() {
			for k := 0; k < 100; k++ {
				c.Increase(1)
			}
		}()
	}

	// The loop is just for demo purpose.
	for c.Value() < 10000 {
		runtime.Gosched()
	}
	fmt.Println(c.Value()) // 10000
}

```

В приведенном выше примере `Counter` значение использует `Mutex` поле, чтобы гарантировать, что `n` поле `Counter` значения никогда не будет использоваться несколькими горутинами одновременно.

Значение `RWMutex` часто называют взаимоисключающей блокировкой чтения и записи. Он имеет две блокировки, блокировку записи и блокировку чтения. Оба замка с нулевым `RWMutex` значением разблокированы. Для адресуемого `RWMutex` значения модули `rwm` записи данных могут блокировать блокировку записи `rwm` сквозных `rwm.Lock()` вызовов методов, а считыватели данных могут блокировать блокировку чтения `rwm` сквозных `rwm.RLock()` вызовов методов. Вызовы методов `rwm.Unlock()` и `rwm.RUnlock()` используются для разблокировки блокировок записи и чтения файлов `rwm` . Блокировка чтения `rwm` поддерживает счетчик блокировок, который увеличивается на единицу при `rwm.Lock()` успешном вызове и уменьшается на единицу при успешном вызове. `rwm.Unlock()` вызывается успешно. Нулевой счетчик блокировки означает, что блокировка чтения находится в разблокированном состоянии, а ненулевое значение (должно быть больше единицы) означает, что блокировка чтения заблокирована.

Обратите внимание, что `rwm.Lock()` , `rwm.Unlock()` , `rwm.RLock()` и `rwm.RUnlock()` являются сокращениями `(&m).Lock()` , `(&m).Unlock()` , `(&m).RLock()` и `(&m).RUnlock()` , соответственно.

Для адресуемого `RWMutex` значения `rwm` существуют следующие правила.

*   Блокировка записи `rwm` может быть заблокирована, только если ни блокировка чтения, ни блокировка записи не `rwm` находятся в заблокированном состоянии. Другими словами, блокировка записи `rwm` может удерживаться не более чем одним модулем записи в любой момент времени, а блокировка чтения и блокировка записи `rwm` не могут удерживаться одновременно.
*   Когда блокировка записи `rwm` находится в заблокированном состоянии, любые новые попытки заблокировать блокировку записи или блокировку чтения `rwm` будут заблокированы до тех пор, пока не будет снята первоначальная блокировка записи.
*   Когда блокировка чтения `rwm` находится в заблокированном состоянии, любые новые попытки заблокировать блокировку записи будут заблокированы до тех пор, пока блокировка чтения не будет разблокирована. Однако более новые попытки заблокировать блокировку чтения будут успешными, если они будут выполнены до любых заблокированных попыток заблокировать блокировку записи (подробности см. в следующем правиле). Другими словами, блокировка чтения может удерживаться более чем одним читателем одновременно. Блокировка чтения вернется в разблокированное состояние, когда ее счетчик блокировок станет равным нулю.
*   Предположим, что блокировка чтения значения `rwm` сейчас находится в заблокированном состоянии, чтобы избежать бесконечной блокировки чтения, любые новые попытки заблокировать блокировку чтения после заблокированной попытки заблокировать блокировку записи будут заблокированы.
*   Предположим, что блокировка записи значения `rwm` сейчас находится в заблокированном состоянии, для официального стандартного компилятора Go, чтобы избежать бесконечной блокировки записи, попытки заблокировать блокировку чтения перед снятием блокировки записи будут успешными, как только блокировка записи будет разблокирована, даже если какая-то из попыток сделана после какой-то еще заблокированной попытки заблокировать блокировку записи.

Последние два правила гарантируют, что и читатели, и писатели имеют шансы получить блокировки.

Обратите внимание, что блокировки не привязаны к горутинам. Блокировка может быть заблокирована в одной горутине, а позже разблокирована в другой. Другими словами, блокировка не знает, какая горутина успешно заблокировала или разблокировала ее.

Тип `m` поля `Counter` типа в последнем примере можно изменить на `sync.RWMutex` , как показано в следующем коде, чтобы получить лучшую производительность, когда `Value` метод вызывается очень часто, но `Increase` метод вызывается редко.

```go
...
type Counter struct {
	//m sync.Mutex
	m sync.RWMutex
	n uint64
}

func (c *Counter) Value() uint64 {
	//c.m.Lock()
	//defer c.m.Unlock()
	c.m.RLock()
	defer c.m.RUnlock()
	return c.n
}
...

```

Другой сценарий использования `sync.RWMutex` значений — разбить задание записи на несколько небольших. Пожалуйста, прочтите следующий раздел для примера.

В соответствии с последними двумя правилами, упомянутыми выше, следующая программа вполне может вывести `abdc` .

```go
package main

import (
	"fmt"
	"time"
	"sync"
)

func main() {
	var m sync.RWMutex
	go func() {
		m.RLock()
		fmt.Print("a")
		time.Sleep(time.Second)
		m.RUnlock()
	}()
	go func() {
		time.Sleep(time.Second * 1 / 4)
		m.Lock()
		fmt.Print("b")
		time.Sleep(time.Second)
		m.Unlock()
	}()
	go func() {
		time.Sleep(time.Second * 2 / 4)
		m.Lock()
		fmt.Print("c")
		m.Unlock()
	}()
	go func () {
		time.Sleep(time.Second * 3 / 4)
		m.RLock()
		fmt.Print("d")
		m.RUnlock()
	}()
	time.Sleep(time.Second * 3)
	fmt.Println()
}

```

Обратите внимание, приведенный выше пример приведен только для пояснения. Он использует `time.Sleep` вызовы для параллельной синхронизации, что является [плохой практикой для производственного кода](https://go101.org/article/concurrent-common-mistakes.html#sleep) .

`sync.Mutex` и `sync.RWMutex` значения также можно использовать для создания уведомлений, хотя есть много других способов сделать ту же работу лучше. Вот пример, который делает уведомление, используя `sync.Mutex` значение.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var m sync.Mutex
	m.Lock()
	go func() {
		time.Sleep(time.Second)
		fmt.Println("Hi")
		m.Unlock() // make a notification
	}()
	m.Lock() // wait to be notified
	fmt.Println("Bye")
}

```

В приведенном выше примере текст `Hi` гарантированно будет напечатан перед текстом `Bye` . О гарантиях порядка памяти, сделанных `sync.Mutex` и `sync.RWMutex` значениях, читайте в статье о [гарантиях порядка памяти в Go](https://go101.org/article/memory-model.html#mutex) .

### `sync.Cond` Тип \_

Тип `sync.Cond` обеспечивает эффективный способ отправки уведомлений среди горутин.

Каждое `sync.Cond` значение содержит `sync.Locker` поле с именем `L` . Значение поля часто является значением типа `*sync.Mutex` или `*sync.RWMutex` .

Тип `*sync.Cond` имеет три [метода](https://golang.org/pkg/sync/#Cond) , `Wait()` и `Signal()` . `Broadcast()`

Каждое `sync.Cond` значение также поддерживает очередь ожидающих горутин FIFO (первым поступил – первым обслужен). Для адресуемого `sync.Cond` значения `c` ,

*   `c.Wait()` должен быть вызван, когда `c.L` заблокирован, иначе a `c.Wait()` вызовет панику. Звонок `c.Wait()` будет
    1.  сначала поместите текущую горутину вызывающего абонента в очередь ожидающих горутин, поддерживаемую `c` ,
    2.  затем позвоните `c.L.Unlock()` , чтобы разблокировать / снять замок `c.L` .
    3.  затем заставьте текущую горутину вызывающего абонента войти в состояние блокировки.

        *(Горутина вызывающего абонента будет разблокирована другой горутиной посредством вызова `c.Signal()` или `c.Broadcast()` позже.)*

        Как только горутина вызывающего абонента будет разблокирована и снова войдет в рабочее состояние, `c.L.Lock()` будет вызвана (в возобновленном `c.Wait()` вызове), чтобы попытаться снова заблокировать и удерживать блокировку `c.L` . `c.Wait()` Вызов завершится после `c.L.Lock()` возврата вызова.
*   вызов `c.Signal()` разблокирует первую горутину (и удалит ее) из очереди ожидающих горутин, поддерживаемой `c` , если очередь не пуста.
*   вызов `c.Broadcast()` разблокирует все горутины (и удалит их) из ожидающей очереди горутин, поддерживаемой `c` , если очередь не пуста.

Обратите внимание, что `c.Wait()` , `c.Signal()` и `c.Broadcast()` являются сокращениями `(&c).Wait()` , `(&c).Signal()` и `(&c).Broadcast()` , соответственно.

`c.Signal()` и `c.Broadcast()` часто используются для уведомления об изменении состояния условия. Как правило, `c.Wait()` их следует вызывать в цикле проверки выполнения условия.

В идиоматическом `sync.Cond` случае использования, как правило, одна горутина ожидает изменения определенного условия, а некоторые другие горутины изменяют условие и отправляют уведомления. Вот пример:

```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	const N = 10
	var values [N]string

	cond := sync.NewCond(&sync.Mutex{})

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d) // simulate a workload

			// Changes must be made when
			// cond.L is locked.
			cond.L.Lock()
			values[i] = string('a' + i)

			// Notify when cond.L lock is locked.
			cond.Broadcast()
			cond.L.Unlock()

			// "cond.Broadcast()" can also be put
			// here, when cond.L lock is unlocked.
			//cond.Broadcast()
		}(i)
	}

	// This function must be called when
	// cond.L is locked.
	checkCondition := func() bool {
		fmt.Println(values)
		for i := 0; i < N; i++ {
			if values[i] == "" {
				return false
			}
		}
		return true
	}

	cond.L.Lock()
	defer cond.L.Unlock()
	for !checkCondition() {
		// Must be called when cond.L is locked.
		cond.Wait()
	}
}

```

Один из возможных выходов:

```
[         ]
[     f    ]
[  c   f    ]
[  c   f  h  ]
[ b c   f  h  ]
[a b c   f  h  j]
[a b c   f g h i j]
[a b c  e f g h i j]
[a b c d e f g h i j]

```

Поскольку в этом примере только одна горутина (основная горутина) ожидает разблокировки, `cond.Broadcast()` вызов можно заменить на `cond.Signal()` . Как предполагают комментарии, `cond.Broadcast()` и `cond.Signal()` не требуется вызывать, когда `cond.L` он заблокирован.

Чтобы избежать гонки данных, каждую из десяти частей пользовательского условия следует изменять только в том случае, если `cond.L` она заблокирована. Функция `checkCondition` и `cond.Wait` метод также должны вызываться при `cond.L` блокировке.

На самом деле, для приведенного выше примера `cond.L` поле также может быть `*sync.RWMutex` значением, и каждая из десяти частей пользовательского условия может быть изменена, когда `cond.L` удерживается блокировка чтения, как показано в следующем коде:

```go
...
	cond := sync.NewCond(&sync.RWMutex{})
	cond.L.Lock()

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d)
			cond.L.(*sync.RWMutex).RLock()
			values[i] = string('a' + i)
			cond.L.(*sync.RWMutex).RUnlock()
			cond.Signal()
		}(i)
	}
...

```

В приведенном выше примере `sync.RWMutex` значение используется необычно. Его блокировка чтения удерживается некоторыми горутинами, которые изменяют элементы массива, а его блокировка записи используется основной горутиной для чтения элементов массива.

Определенное пользователем условие, отслеживаемое `Cond` значением, может быть пустым. В таких случаях `Cond` значение используется исключительно для уведомлений. Например, следующая программа напечатает `abc` или `bac` .

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}
	wg.Add(1)
	cond := sync.NewCond(&sync.Mutex{})
	cond.L.Lock()
	go func() {
		cond.L.Lock()
		go func() {
			cond.L.Lock()
			cond.Broadcast()
			cond.L.Unlock()
		}()
		cond.Wait()
		fmt.Print("a")
		cond.L.Unlock()
		wg.Done()
	}()
	cond.Wait()
	fmt.Print("b")
	cond.L.Unlock()
	wg.Wait()
	fmt.Println("c")
}

```

При необходимости несколько `sync.Cond` значений могут использовать один и тот же файл `sync.Locker` . Однако такие случаи на практике встречаются редко.
