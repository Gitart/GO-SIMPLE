# Горутины, отложенные вызовы функций и паника/восстановление

В этой статье будут представлены горутины и отложенные вызовы функций. Горутина и отложенный вызов функции — две уникальные функции в Go. В этой статье также объясняется механизм паники и восстановления. В этой статье описаны не все сведения об этих функциях, в следующих статьях будет представлена ​​дополнительная информация.

### Горутины

Современные ЦП часто имеют несколько ядер, а некоторые ядра ЦП поддерживают гиперпоточность. Другими словами, современные процессоры могут одновременно обрабатывать несколько конвейеров команд. Чтобы в полной мере использовать возможности современных процессоров, нам необходимо выполнять параллельное программирование при кодировании наших программ.

Параллельные вычисления — это форма вычислений, при которой несколько вычислений выполняются в течение перекрывающихся периодов времени. На следующем рисунке показаны два случая параллельных вычислений. На рисунке A и B представляют собой два отдельных вычисления. Второй случай также называется параллельными вычислениями, то есть специальными одновременными вычислениями. В первом случае А и В параллельны только в течение небольшого промежутка времени.

![одновременный и параллельный](https://go101.org/article/res/concurrent-vs-parallel.png)

Параллельные вычисления могут происходить в программе, на компьютере или в сети. В Go 101 мы говорим только о параллельных вычислениях в рамках программы. Goroutine — это способ Go для создания параллельных вычислений в программировании Go.

Горутины также часто называют зелеными потоками. Зеленые потоки поддерживаются и планируются средой выполнения языка, а не операционными системами. Стоимость потребления памяти и переключения контекста для горутины намного меньше, чем для потока ОС. Таким образом, для программы Go не проблема одновременно поддерживать десятки тысяч горутин, если достаточно системной памяти.

Go не поддерживает создание системных потоков в пользовательском коде. Таким образом, использование горутин — единственный способ выполнять (в рамках программы) параллельное программирование в Go.

Каждая программа Go начинается только с одной горутины, мы называем ее основной горутиной. Горутина может создавать новые горутины. В Go очень легко создать новую горутину, просто используйте ключевое слово `go` , за которым следует вызов функции. Затем вызов функции будет выполнен во вновь созданной горутине. Вновь созданная горутина завершится вместе с выходом из вызванной функции.

Все значения результата вызова функции горутины (если вызываемая функция возвращает значения) должны быть отброшены в операторе вызова функции. Ниже приведен пример создания двух новых горутин в основной горутине. В примере `time.Duration` это пользовательский тип, определенный в `time` стандартном пакете. Его базовым типом является встроенный тип `int64` . Базовые типы будут объяснены в [следующей статье](https://go101.org/article/type-system-overview.html#underlying-type) .

```go
package main

import (
	"log"
	"math/rand"
	"time"
)

func SayGreetings(greeting string, times int) {
	for i := 0; i < times; i++ {
		log.Println(greeting)
		d := time.Second * time.Duration(rand.Intn(5)) / 2
		time.Sleep(d) // sleep for 0 to 2.5 seconds
	}
}

func main() {
	rand.Seed(time.Now().UnixNano())
	log.SetFlags(0)
	go SayGreetings("hi!", 10)
	go SayGreetings("hello!", 10)
	time.Sleep(2 * time.Second)
}

```

Довольно легко. Верно? Мы занимаемся параллельным программированием прямо сейчас! Вышеупомянутая программа может иметь три созданные пользователем горутины, работающие одновременно на пике во время выполнения. Давайте запустим его. Один из возможных выходных результатов:

```
hi!
hello!
hello!
hello!
hello!
hi!

```

Когда основная горутина завершается, вся программа также завершается, даже если есть еще какие-то другие горутины, которые еще не завершились.

В отличие от предыдущих статей, эта программа использует `Println` функцию из `log` стандартного пакета вместо соответствующей функции из `fmt` стандартного пакета. Причина в том, что функции печати в `log` стандартном пакете синхронизированы (в следующем разделе будет объяснено, что такое синхронизация), поэтому тексты, напечатанные двумя горутинами, не будут перепутаны в одну строку (хотя вероятность того, что напечатанные тексты будут перепутаны с использованием функций печати в `fmt` стандартном пакете очень мало для этой конкретной программы).

### Параллельная синхронизация

Параллельные вычисления могут совместно использовать ресурсы, как правило, ресурсы памяти. Ниже приведены некоторые обстоятельства, которые могут возникнуть во время параллельных вычислений:

*   В тот же период времени, когда одно вычисление записывает данные в сегмент памяти, другое вычисление считывает данные из того же сегмента памяти. Тогда целостность данных, считанных другим вычислением, может не сохраниться.
*   В тот же период времени, когда одно вычисление записывает данные в сегмент памяти, другое вычисление также записывает данные в тот же сегмент памяти. Тогда целостность данных, хранящихся в сегменте памяти, может не сохраниться.

Эти обстоятельства называются гонками данных. Одной из обязанностей параллельного программирования является контроль за совместным использованием ресурсов параллельными вычислениями, чтобы никогда не возникало гонок данных. Способы реализации этой обязанности называются параллельными синхронизациями или синхронизациями данных, которые будут представлены один за другим в последующих статьях Go 101.

Другие обязанности в параллельном программировании включают

*   определить необходимое количество вычислений.
*   определить, когда начинать, блокировать, разблокировать и заканчивать вычисление.
*   определить, как распределить рабочую нагрузку между параллельными вычислениями.

Программа, показанная в последнем разделе, не идеальна. Две новые горутины предназначены для печати десяти приветствий каждая. Однако основная горутина завершится через две секунды, поэтому у многих приветствий нет шансов быть напечатанными. Как сообщить основной горутине, когда две новые горутины завершили свои задачи? Мы должны использовать так называемые методы параллельной синхронизации.

Go поддерживает несколько [методов параллельной синхронизации](https://go101.org/article/concurrent-synchronization-overview.html) . Среди них [канальная техника](https://go101.org/article/channel.html) является самой уникальной и широко используемой. Однако для простоты здесь мы будем использовать другой метод, `WaitGroup` тип в `sync` стандартном пакете, для синхронизации выполнения между двумя новыми горутинами и основной горутиной.

Тип `WaitGroup` имеет три метода (специальные функции, которые будут объяснены позже): `Add` , `Done` и `Wait` . Этот тип будет подробно объяснен позже в другой статье. Здесь мы можем просто подумать

*   метод `Add` используется для регистрации количества новых задач.
*   метод `Done` используется для уведомления о завершении задачи.
*   и этот `Wait` метод заставляет вызывающую горутину блокироваться до тех пор, пока все зарегистрированные задачи не будут завершены.

Пример:

```go
package main

import (
	"log"
	"math/rand"
	"time"
	"sync"
)

var wg sync.WaitGroup

func SayGreetings(greeting string, times int) {
	for i := 0; i < times; i++ {
		log.Println(greeting)
		d := time.Second * time.Duration(rand.Intn(5)) / 2
		time.Sleep(d)
	}
	// Notify a task is finished.
	wg.Done() // <=> wg.Add(-1)
}

func main() {
	rand.Seed(time.Now().UnixNano())
	log.SetFlags(0)
	wg.Add(2) // register two tasks.
	go SayGreetings("hi!", 10)
	go SayGreetings("hello!", 10)
	wg.Wait() // block until all tasks are finished.
}

```

Запустив его, мы можем обнаружить, что перед выходом из программы каждая из двух новых горутин выводит десять приветствий.

### Горутиновые состояния

Последний пример показывает, что живая горутина может оставаться (и переключаться между) в двух состояниях: **работает** и **блокируется** . В этом примере основная горутина переходит в состояние блокировки при `wg.Wait` вызове метода и снова переходит в рабочее состояние, когда две другие горутины завершают свои соответствующие задачи.

На следующем рисунке показан возможный жизненный цикл горутины.

![состояния горутины](https://go101.org/article/res/goroutine-states.png)

Обратите внимание, что горутина по-прежнему считается «работающей», если она находится в спящем режиме (после вызова `time.Sleep` функции) или ожидает ответа системного вызова или сетевого подключения.

Когда создается новая горутина, она автоматически переходит в состояние «работает». Горутины могут выйти только из рабочего состояния и никогда из состояния блокировки. Если по какой-либо причине горутина навсегда останется в заблокированном состоянии, она никогда не выйдет. Таких случаев, за исключением некоторых редких, следует избегать в параллельном программировании.

Блокирующая горутина может быть разблокирована только операцией, выполненной в другой горутине. Если все горутины в программе Go находятся в состоянии блокировки, то все они останутся в состоянии блокировки навсегда. Это можно рассматривать как общий тупик. Когда это происходит в программе, стандартная среда выполнения Go попытается сломать программу.

Следующая программа рухнет через две секунды:

```go
package main

import (
	"sync"
	"time"
)

var wg sync.WaitGroup

func main() {
	wg.Add(1)
	go func() {
		time.Sleep(time.Second * 2)
		wg.Wait()
	}()
	wg.Wait()
}

```

Выход:

```
fatal error: all goroutines are asleep - deadlock!

...

```

Позже мы узнаем больше об операциях, которые переводят горутины в состояние блокировки.

### Расписание горутины

Не все горутины в рабочем состоянии выполняются в данный момент времени. В любой момент времени максимальное количество выполняемых горутин не будет превышать количество логических процессоров, доступных для текущей программы. Мы можем вызвать [`runtime.NumCPU`](https://golang.org/pkg/runtime/#NumCPU) функцию, чтобы получить количество логических процессоров, доступных для текущей программы. Каждый логический ЦП может выполнять только одну горутину в любой момент времени. Среда выполнения Go должна часто переключать контексты выполнения между горутинами, чтобы каждая запущенная горутина могла выполниться. Это похоже на то, как операционные системы переключают контексты выполнения между потоками ОС.

На следующем рисунке показан более подробный возможный жизненный цикл горутины. На картинке рабочее состояние разделено еще на несколько подсостояний. Горутина в подсостоянии очереди ожидает выполнения. Горутина в подсостоянии выполнения может снова войти в подсостояние очереди, если она выполнялась какое-то время (очень небольшой отрезок времени).

![подсостояния горутины](https://go101.org/article/res/goroutine-schedule.png)

Обратите внимание: для простоты подсостояния, показанные на рисунке выше, не будут упоминаться в других статьях в Go 101. И снова, в Go 101 подсостояния сна и системного вызова не рассматриваются как подсостояния блокирующее состояние.

Стандартная среда выполнения Go использует [модель MPG](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw) для выполнения задания планирования горутин, где **M** представляет потоки ОС, **P** представляет логические/виртуальные процессоры (не логические ЦП), а **G** представляет горутины. Большая часть запланированной работы выполняется логическими процессорами ( **Ps** ), которые действуют как посредники, присоединяя горутины ( **Gs** ) к потокам ОС ( **M** с). Каждый поток ОС может быть присоединен не более чем к одной горутине в любой момент времени, и каждая горутина может быть присоединена не более чем к одному потоку ОС в любой момент времени. Горутина может выполняться только тогда, когда она присоединена к потоку ОС. Горутина, которая выполнялась какое-то время, попытается отсоединиться от соответствующего потока ОС, чтобы другие запущенные горутины могли присоединиться и выполниться.

Во время выполнения. мы можем вызвать [`runtime.GOMAXPROCS`](https://golang.org/pkg/runtime/#GOMAXPROCS) функцию для получения и установки числа логических процессоров ( **Ps** ). Для стандартной среды выполнения Go до Go 1.5 начальное значение этого числа по умолчанию равно `1` , но начиная с Go 1.5 начальное значение этого числа по умолчанию равно количеству логических процессоров, доступных для текущей запущенной программы. Начальное значение по умолчанию (количество логических процессоров) лучше всего подходит для большинства программ. Но для некоторых программ с тяжелым файловым вводом-выводом `GOMAXPROCS` значение больше `runtime.NumCPU()` может быть полезным.

Начальное значение по умолчанию `runtime.GOMAXPROCS` также может быть установлено через `GOMAXPROCS` переменную окружения.

В любой момент количество горутин в выполняющемся подсостоянии не больше, чем меньшее из `runtime.NumCPU` и `runtime.GOMAXPROCS` .

### Отложенные вызовы функций

Отложенный вызов функции — это вызов функции, который следует за `defer` ключевым словом. Ключевое `defer` слово и вызов отложенной функции вместе образуют оператор отсрочки. Как и вызовы функций горутины, все результаты вызова функции (если вызываемая функция имеет возвращаемые результаты) должны быть отброшены в операторе вызова функции.

При выполнении инструкции отсрочки отложенный вызов функции не выполняется немедленно. Вместо этого он помещается в очередь отложенных вызовов, поддерживаемую вызывающей горутиной. После того, как вызов функции `fc(...)` возвращается (но еще не полностью существует) и переходит в [фазу выхода](https://go101.org/article/function-declarations-and-calls.html#exiting-phase) , все отложенные вызовы функций, помещенные в очередь отложенных вызовов во время выполнения вызова функции, будут удалены из очереди отложенных вызовов и выполнены в порядке очереди. , в порядке, обратном порядку, в котором они были помещены в очередь отложенных вызовов. Как только все эти отложенные вызовы выполнены, вызов функции `fc(...)` полностью завершается.

Вот простой пример, показывающий, как использовать отложенные вызовы функций.

```go
package main

import "fmt"

func main() {
	defer fmt.Println("The third line.")
	defer fmt.Println("The second line.")
	fmt.Println("The first line.")
}

```

Выход:

```
The first line.
The second line.
The third line.

```

Вот еще один пример, немного более сложный. Пример будет печатать `0` до `9` , каждый в строке, в их естественном порядке.

```go
package main

import "fmt"

func main() {
	defer fmt.Println("9")
	fmt.Println("0")
	defer fmt.Println("8")
	fmt.Println("1")
	if false {
		defer fmt.Println("not reachable")
	}
	defer func() {
		defer fmt.Println("7")
		fmt.Println("3")
		defer func() {
			fmt.Println("5")
			fmt.Println("6")
		}()
		fmt.Println("4")
	}()
	fmt.Println("2")
	return
	defer fmt.Println("not reachable")
}

```

### Отложенные вызовы функций могут изменить именованные результаты возврата вложенных функций

Например,

```go
package main

import "fmt"

func Triple(n int) (r int) {
	defer func() {
		r += n // modify the return value
	}()

	return n + n // <=> r = n + n; return
}

func main() {
	fmt.Println(Triple(5)) // 15
}

```

### Момент оценки аргументов отложенных вызовов функций

Все аргументы отложенного вызова функции оцениваются в момент выполнения соответствующего оператора отложенного вызова (т. е. когда отложенный вызов помещается в очередь отложенных вызовов). Результаты оценки используются, когда отложенный вызов выполняется позже во время существующей фазы окружающего вызова (вызывающий отложенный вызов).

Выражения в теле вызова анонимной функции, независимо от того, является ли вызов общим или отложенным/вызовом подпрограммы, оцениваются во время выполнения вызова анонимной функции.

Вот пример.

```go
package main

import "fmt"

func main() {
	func() {
		for i := 0; i < 3; i++ {
			defer fmt.Println("a:", i)
		}
	}()
	fmt.Println()
	func() {
		for i := 0; i < 3; i++ {
			defer func() {
				fmt.Println("b:", i)
			}()
		}
	}()
}

```

Запустить его. Выход:

```
a: 2
a: 1
a: 0

b: 3
b: 3
b: 3

```

Первый цикл печатается `i` как `2` и `1` как `0` последовательность. Второй цикл всегда печатается `i` как `3` , поскольку при вызове трех `fmt.Println` вызовов анонимной функции значение переменной цикла `i` изменилось на `3` .

Чтобы второй цикл печатал тот же результат, что и первый, мы можем изменить второй цикл следующим образом:

```go
		for i := 0; i < 3; i++ {
			defer func(i int) {
				// The "i" is the input parameter.
				fmt.Println("b:", i)
			}(i)
		}

```

или же

```go
		for i := 0; i < 3; i++ {
			i := i // <=> var i = i
			defer func() {
				// The "i" is not the loop variable.
				fmt.Println("b:", i)
			}()
		}

```

Те же самые правила оценки момента аргумента также применяются к вызовам функций горутины. Следующая программа выведет `123 789` .

```go
package main

import "fmt"
import "time"

func main() {
	var a = 123
	go func(x int) {
		time.Sleep(time.Second)
		fmt.Println(x, a) // 123 789
	}(a)

	a = 789

	time.Sleep(2 * time.Second)
}

```

`time.Sleep` Кстати, синхронизацию с помощью вызовов в формальных проектах делать не стоит . Если программа запускается на компьютере, центральные процессоры которого заняты множеством других программ, работающих на этом компьютере, вновь созданная горутина может никогда не получить возможности выполниться до выхода программы. Мы должны использовать методы синхронизации параллелизма, представленные в [обзоре синхронизации параллелизма](https://go101.org/article/concurrent-synchronization-overview.html) статьи , чтобы выполнять синхронизацию в формальных проектах.

### Необходимость отложенной функции

В приведенных выше примерах отложенные вызовы функций не являются абсолютно необходимыми. Однако функция отложенного вызова функции является необходимой функцией для механизма паники и восстановления, который будет представлен ниже.

Отложенные вызовы функций также могут помочь нам написать более чистый и надежный код. Мы можем прочитать больше примеров кода, использующих отложенные вызовы функций, и узнать больше об отложенных вызовах функций в статье [об отложенных функциях](https://go101.org/article/defer-more.html) позже. А пока мы изучим важность отложенных функций для паники и восстановления.

### Паника и восстановление

Go не поддерживает создание и перехват исключений, вместо этого в программировании на Go предпочтительнее использовать явную обработку ошибок. На самом деле, Go поддерживает механизм, аналогичный броску/перехвату исключений. Механизм называется паника/восстановление.

Мы можем вызвать встроенную `panic` функцию для создания паники, чтобы текущая горутина перешла в состояние паники.

Паника — это еще один способ вернуть функцию. Как только в вызове функции возникает паника, вызов функции немедленно возвращается и переходит в фазу выхода.

Вызывая встроенную `recover` функцию в отложенном вызове, живую панику в текущей горутине можно удалить, чтобы текущая горутина снова перешла в нормальное спокойное состояние.

Если паникующая горутина завершится без восстановления, это приведет к сбою всей программы.

Встроенные функции и объявлены `panic` как `recover`

```go
func panic(v interface{})
func recover() interface{}

```

Типы и значения интерфейсов будут объяснены в статье [интерфейсы в Go](https://go101.org/article/interface.html) позже. Здесь нам просто нужно знать, что пустой тип интерфейса `interface{}` можно рассматривать как `any` тип или `Object` тип во многих других языках. Другими словами, мы можем передать значение любого типа в `panic` вызов функции.

Значение, возвращаемое `recover` вызовом функции, является значением, `panic` потребляемым вызовом функции.

В приведенном ниже примере показано, как создать панику и как от нее избавиться.

```go
package main

import "fmt"

func main() {
	defer func() {
		fmt.Println("exit normally.")
	}()
	fmt.Println("hi!")
	defer func() {
		v := recover()
		fmt.Println("recovered:", v)
	}()
	panic("bye!")
	fmt.Println("unreachable")
}

```

Выход:

```
hi!
recovered: bye!
exit normally.

```

Вот еще один пример, который показывает, что горутина в панике завершает работу без восстановления. Так что вся программа вылетает.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("hi!")

	go func() {
		time.Sleep(time.Second)
		panic(123)
	}()

	for {
		time.Sleep(time.Second)
	}
}

```

Выход:

```
hi!
panic: 123

goroutine 5 [running]:
...

```

Среда выполнения Go создаст панику при некоторых обстоятельствах, например при делении целого числа на ноль. Например,

```go
package main

func main() {
	a, b := 1, 0
	_ = a/b
}

```

Выход:

```
panic: runtime error: integer divide by zero

goroutine 1 [running]:
...

```

Другие обстоятельства паники во время выполнения будут упомянуты в последующих статьях Go 101.

Как правило, паники используются для логических ошибок, таких как ошибки человека по невнимательности. Логические ошибки никогда не должны возникать во время выполнения. Если они случаются, в коде должны быть ошибки. С другой стороны, нелогических ошибок трудно полностью избежать во время выполнения. Другими словами, нелогические ошибки — это ошибки, происходящие в реальности. Такие ошибки не должны вызывать паники и должны быть явно возвращены и должным образом обработаны.

Мы можем узнать о [некоторых случаях использования паники/восстановления](https://go101.org/article/panic-and-recover-use-cases.html) и [больше о механизме паники/восстановления](https://go101.org/article/panic-and-recover-more.html) позже.

### Некоторые фатальные ошибки не являются паникой и неисправимы

Для стандартного компилятора Go некоторые фатальные ошибки, такие как переполнение стека и нехватка памяти, не подлежат восстановлению. Как только они произойдут, программа рухнет.
