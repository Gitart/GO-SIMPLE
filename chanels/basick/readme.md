# Каналы в Go

Канал — важная встроенная функция Go. Это одна из особенностей, которая делает Go уникальным. Наряду с другой уникальной функцией, [горутиной](https://go101.org/article/control-flows-more.html#goroutine) , канал делает параллельное программирование удобным, увлекательным и снижает трудности параллельного программирования.

Канал в основном действует как метод [параллельной синхронизации .](https://go101.org/article/control-flows-more.html#synchronization) В этой статье будут перечислены все концепции, синтаксис и правила, связанные с каналом. Чтобы лучше понять каналы, также просто описаны внутренняя структура каналов и некоторые детали реализации стандартным компилятором/средой выполнения Go.

Информация в этой статье может быть немного сложной для начинающих гоферов. Некоторые части этой статьи, возможно, придется прочитать несколько раз, чтобы полностью понять.

### Введение канала

Одно предложение (сделанное *Робом Пайком* ) для параллельного программирования: **не (разрешайте вычислениям) обмениваться данными, разделяя память, (пусть они) разделяют память, общаясь (по каналам)** . (Мы можем рассматривать каждое вычисление как горутину в программировании на Go.)

Общение путем совместного использования памяти и совместное использование памяти путем общения — это два способа программирования в параллельном программировании. Когда горутины обмениваются данными, разделяя память, мы используем традиционные методы параллельной синхронизации, такие как блокировка мьютексов, для защиты общей памяти и предотвращения гонок данных. Мы можем использовать каналы для реализации совместного использования памяти путем общения.

Go предоставляет уникальную технику параллельной синхронизации, канал. Каналы заставляют горутины совместно использовать память, обмениваясь данными. Мы можем рассматривать канал как внутреннюю очередь FIFO (первым пришел, первым вышел) внутри программы. Некоторые горутины отправляют значения в очередь (канал), а некоторые другие горутины получают значения из очереди.

Наряду с передачей значений (по каналам) между горутинами также может передаваться владение некоторыми значениями. Когда горутина отправляет значение в канал, мы можем увидеть, как горутина освобождает право собственности на некоторые значения (доступ к которым можно получить через отправленное значение). Когда горутина получает значение из канала, мы можем видеть, что горутина получает право собственности на некоторые значения (к которым можно получить доступ через полученное значение).

Конечно, вместе с коммуникациями канала может и не передаваться право собственности.

Значения (права собственности на которые передаются) часто упоминаются (но не являются обязательными) в переданном значении. Обратите внимание, здесь, когда мы говорим о владении, мы имеем в виду владение с точки зрения логики. Каналы Go могут помочь программистам легко писать свободный код для гонок данных, но каналы Go не могут помешать программистам писать плохой параллельный код на уровне синтаксиса.

Хотя Go также поддерживает традиционные методы параллельной синхронизации. единственный канал является первоклассным гражданином в Go. Канал — это один из типов в Go, поэтому мы можем использовать каналы без импорта каких-либо пакетов. С другой стороны, эти традиционные методы параллельной синхронизации предоставляются в стандартных пакетах `sync` и ​​. `sync/atomic`

Честно говоря, у каждого метода параллельной синхронизации есть свои лучшие сценарии использования. Но канал имеет [более широкий спектр применения и больше разнообразия в использовании](https://go101.org/article/channel-use-cases.html) . Одна из проблем с каналами заключается в том, что опыт программирования с каналами настолько приятен и забавен, что программисты часто даже предпочитают использовать каналы для сценариев, для которых каналы не подходят.

### Типы каналов и значения

Подобно массиву, срезу и карте, каждый тип канала имеет тип элемента. Канал может передавать только значения типа элемента канала.

Типы каналов могут быть двунаправленными или однонаправленными. Предположим `T` , что это произвольный тип,

*   `chan T` обозначает двунаправленный тип канала. Компиляторы позволяют как получать значения, так и отправлять значения в двунаправленные каналы.
*   `chan<- T` обозначает тип канала только для отправки. Компиляторы не позволяют получать значения из каналов только для отправки.
*   `<-chan T` обозначает тип канала только для приема. Компиляторы не позволяют отправлять значения в каналы только для приема.

`T` называется типом элемента этих типов каналов.

Значения типа двунаправленного канала `chan T` могут быть неявно преобразованы как в тип только для отправки, так и в тип только для `chan<- T` приема `<-chan T` , но не наоборот (даже если явно). Значения типа только для отправки `chan<- T` нельзя преобразовать в тип только для получения `<-chan T` и наоборот. Обратите внимание, что `<-` знаки в литералах типа канала являются модификаторами.

Каждое значение канала имеет емкость, которая будет объяснена в следующем разделе. Значение канала с нулевой пропускной способностью называется небуферизованным каналом, а значение канала с ненулевой пропускной способностью называется буферизованным каналом.

Нулевые значения типов каналов представлены предварительно объявленным идентификатором `nil` . Значение канала, отличное от нуля, должно быть создано с помощью встроенной `make` функции. Например, `make(chan int, 10)` создаст канал с типом элемента `int` . Второй аргумент `make` вызова функции указывает пропускную способность вновь созданного канала. Второй параметр является необязательным, и его значение по умолчанию равно нулю.

### Сравнение ценности каналов

Все типы каналов являются сравнимыми типами.

[Из частей значения](https://go101.org/article/value-part.html) статьи мы знаем, что ненулевые значения канала являются составными значениями. Если одно значение канала назначается другому, два канала совместно используют одну и ту же базовую часть (части). Другими словами, эти два канала представляют один и тот же объект внутреннего канала. Результат их сравнения `true` .

### Операции с каналами

Существует пять определенных операций канала. Предположим, что это канал `ch` , их синтаксис и вызовы функций этих операций перечислены здесь.

1.  Закройте канал, используя следующий вызов функции

    ```go
    close(ch)

    ```

    где `close` встроенная функция. Аргумент `close` вызова функции должен быть значением канала, и канал `ch` не должен быть каналом только для приема.

2.  Отправьте значение , `v` в канал, используя следующий синтаксис

    ```go
    ch <- v

    ```

    где `v` должно быть значение, которое можно присвоить типу элемента канала `ch` , и канал `ch` не должен быть каналом только для приема. Обратите внимание, что здесь `<-` оператор отправки канала.

3.  Получите значение из канала, используя следующий синтаксис

    ```go
    <-ch

    ```

    Операция приема канала всегда возвращает по крайней мере один результат, который является значением типа элемента канала, и канал `ch` не должен быть каналом только для отправки. Обратите внимание, что здесь `<-` оператор приема канала. Да, его представление такое же, как у оператора отправки канала.

    В большинстве сценариев операция получения канала рассматривается как выражение с одним значением. Однако, когда операция канала используется как единственное выражение исходного значения в назначении, она может привести ко второму необязательному нетипизированному логическому значению и стать многозначным выражением. Нетипизированное логическое значение указывает, будет ли отправлен первый результат до закрытия канала. (Ниже мы узнаем, что мы можем получать неограниченное количество значений из закрытого канала.)

    Две операции приема канала, которые используются в качестве исходных значений в назначениях:

    ```go
    v = <-ch
    v, sentBeforeClosed = <-ch

    ```

4.  Запросите емкость буфера значений канала, используя следующий вызов функции

    ```go
    cap(ch)

    ```

    где `cap` встроенная функция, которая когда-либо была представлена ​​в [контейнерах в Go](https://go101.org/article/container.html#cap-len) . Возвращаемым результатом `cap` вызова функции является `int` значение.

5.  Запросите текущее количество значений в буфере значений (или длину) канала, используя следующий вызов функции

    ```go
    len(ch)

    ```

    где `len` встроенная функция, которая также когда-либо вводилась ранее. Возвращаемое значение `len` вызова функции является `int` значением. Длина результата — это количество элементов, которые уже были успешно отправлены в запрошенный канал, но еще не были получены (извлечены).

Большинство основных операций в Go не синхронизированы. Другими словами, они не являются безопасными для параллелизма. Эти операции включают присвоение значений, передачу аргументов и манипулирование элементами контейнера и т. д. Однако все только что представленные операции с каналами уже синхронизированы, поэтому для безопасного выполнения этих операций дальнейшая синхронизация не требуется.

Как и большинство других операций в Go, присвоение значений канала не синхронизировано. Точно так же присвоение полученного значения другому значению также не синхронизируется, хотя синхронизируется любая операция приема канала.

Если запрошенный канал является нулевым каналом, встроенная функция `cap` и `len` функция возвращают ноль. Две операции запроса настолько просты, что в дальнейшем они не будут объяснены. На самом деле эти две операции редко используются на практике.

Операции отправки, получения и закрытия канала будут подробно описаны в следующем разделе.

### Подробные пояснения по операциям с каналами

Чтобы сделать объяснения операций с каналами простыми и ясными, в оставшейся части этой статьи каналы будут разделены на три категории:

1.  нулевые каналы.
2.  ненулевые, но закрытые каналы.
3.  незакрытые ненулевые каналы.

В следующей таблице просто суммировано поведение всех видов операций, применяемых к нулевым, закрытым и незакрытым ненулевым каналам.

| Операция | Нулевой канал | Закрытый канал | Незакрытый ненулевой канал |
| :-: | :-: | :-: | :-: |
| Закрывать | паника | паника | удалось закрыть (С) |
| Отправить значение | заблокировать навсегда | паника | заблокировать или успешно отправить (B) |
| Получить значение от | заблокировать навсегда | никогда не блокировать (D) | заблокировать или получить (A) |

Для пяти случаев, показанных без надстрочных индексов, поведение очень ясно.

*   Закрытие нулевого или уже закрытого канала вызывает панику в текущей горутине.
*   Отправка значения в закрытый канал также вызывает панику в текущей горутине.
*   Отправка значения или получение значения из канала nil приводит к тому, что текущая горутина переходит в состояние блокировки и навсегда остается в нем.

Далее будут даны дополнительные пояснения для четырех случаев, показанных с надстрочными индексами (A, B, C и D).

Для лучшего понимания типов и значений каналов, а также для облегчения некоторых объяснений очень полезно просмотреть необработанные внутренние структуры объектов внутренних каналов.

Мы можем думать о каждом канале, состоящем из трех очередей (все можно рассматривать как очереди FIFO) внутри:

1.  приемная очередь горутины (обычно FIFO). Очередь представляет собой связанный список без ограничения размера. Горутины в этой очереди находятся в состоянии блокировки и ожидают получения значений из этого канала.
2.  очередь отправки goroutine (обычно FIFO). Очередь также представляет собой связанный список без ограничения размера. Горутины в этой очереди находятся в состоянии блокировки и ожидают отправки значений в этот канал. Значение (или адрес значения, в зависимости от реализации компилятора), которое каждая горутина пытается отправить, также сохраняется в очереди вместе с этой горутиной.
3.  очередь буфера значений (абсолютно FIFO). Это круговая очередь. Его размер равен пропускной способности канала. Все типы значений, хранящихся в этой буферной очереди, являются типом элемента этого канала. Если текущее количество значений, хранящихся в очереди буфера значений канала, достигает емкости канала, канал вызывается в полном состоянии. Если в настоящее время в очереди буфера значений канала нет значений, канал вызывается в пустом состоянии. Для канала с нулевой пропускной способностью (небуферизованного) он всегда находится как в полном, так и в пустом состоянии.

Каждый канал внутренне содержит блокировку мьютекса, которая используется для предотвращения гонок данных во всех видах операций.

**Случай операции с каналом A** : когда горутина `R` пытается получить значение из незакрытого канала, отличного от nil , горутина `R` сначала получит блокировку, связанную с каналом, а затем выполнит следующие шаги, пока не будет выполнено одно условие.

1.  Если очередь буфера значений канала не пуста, и в этом случае очередь принимающей горутины канала должна быть пустой, горутина `R` получит (путем сдвига) значение из очереди буфера значений. Если очередь отправляющей горутины канала также не пуста, отправляющая горутина будет перемещена из очереди отправляющей горутины и снова вернется в рабочее состояние. Значение, которое только что сдвинутая отправляющая горутина пытается отправить, будет помещено в очередь буфера значений канала. Принимающая горутина `R` продолжает работать. В этом сценарии операция получения канала называется **неблокирующей операцией** .
2.  В противном случае (очередь буфера значений канала пуста), если очередь отправляющей горутины канала не пуста, и в этом случае канал должен быть небуферизованным каналом, принимающая горутина `R` переместит отправляющую горутину из очереди отправляющей горутины канал и получить значение, которое пытается отправить только что сдвинутая отправляющая горутина. Только что сдвинутая отправляющая горутина будет разблокирована и снова вернется в рабочее состояние. Принимающая горутина `R` продолжает работать. В этом сценарии операция получения канала называется **неблокирующей операцией** .
3.  Если очередь буфера значений и очередь отправляющей горутины канала пусты, горутина `R` будет помещена в приемную очередь горутины канала и войдет (и останется в) в состоянии блокировки. Он может быть возобновлен в рабочем состоянии, когда позже другая горутина отправит значение в канал. В этом сценарии операция получения канала называется **операцией блокировки** .

**Случай правила канала B** : когда горутина `S` пытается отправить значение в незакрытый канал , отличный от nil, горутина `S` сначала получит блокировку, связанную с каналом, а затем выполнит следующие шаги, пока не будет выполнено условие одного шага.

1.  Если очередь принимающей горутины канала не пуста, и в этом случае очередь буфера значений канала должна быть пустой, отправляющая горутина `S` переместит принимающую горутину из очереди принимающей горутины канала и отправит значение в только что перемещенный получение горутины. Только что сдвинутая принимающая горутина будет разблокирована и снова вернется в рабочее состояние. Отправляющая горутина `S` продолжает работать. В этом сценарии операция отправки канала называется **неблокирующей операцией** .
2.  В противном случае (очередь принимающей горутины пуста), если очередь буфера значений канала не заполнена, и в этом случае очередь отправляющей горутины также должна быть пустой, значение, которое `S` пытается отправить отправляющая горутина, будет помещено в очередь буфера значений. , а отправляющая горутина `S` продолжает работать. В этом сценарии операция отправки канала называется **неблокирующей операцией** .
3.  Если очередь приемной горутины пуста, а очередь буфера значений канала уже заполнена, отправляющая горутина `S` будет помещена в очередь отправляющей горутины канала и войдет (и останется в) в состоянии блокировки. Он может быть возобновлен в рабочем состоянии, когда позже другая горутина получит значение из канала. В этом сценарии операция отправки канала называется **операцией блокировки** .

Выше упоминалось, что после закрытия канала, отличного от nil, отправка значения в канал вызовет панику во время выполнения в текущей горутине. Обратите внимание, отправка данных в закрытый канал рассматривается как **неблокирующая операция** .

**Случай операции с каналом C** : когда горутина пытается закрыть незакрытый канал , отличный от nil, после того, как горутина получила блокировку канала, оба следующих двух шага будут выполняться в следующем порядке.

1.  Если приемная очередь горутин канала не пуста, и в этом случае буфер значений канала должен быть пустым, все горутины в приемной очереди горутин канала будут сдвигаться одна за другой, каждая из них получит нулевой значение типа элемента канала и возобновить работу в рабочем состоянии.
2.  Если очередь горутин на отправку канала не пуста, то все горутины в очереди горутин на отправку канала будут сдвигаться одна за другой и каждая из них будет производить панику для отправки на закрытом канале. По этой причине нам следует избегать одновременных операций отправки и закрытия на одном и том же канале. На самом деле, когда включена [опция детектора гонок данных команды go](https://golang.org/doc/articles/race_detector.html) ( `-race` ), одновременные операции отправки и закрытия могут быть обнаружены во время выполнения, и будет вызвана паника во время выполнения.

Примечание: после закрытия канала значения, которые уже были помещены в буфер значений канала, все еще там. Пожалуйста, внимательно прочитайте следующие пояснения к случаю D для получения подробной информации.

**Случай работы канала D** : после закрытия канала, отличного от nil, операции приема канала никогда не будут блокироваться . Значения в буфере значений канала все еще могут быть получены. Сопутствующие вторые необязательные возвращаемые значения bool по-прежнему `true` . Как только все значения в буфере значений будут извлечены и получены, бесконечные нулевые значения типа элемента канала будут получены любой из следующих операций приема на канале. Как упоминалось выше, необязательный второй возвращаемый результат операции приема канала представляет собой нетипизированное логическое значение, которое указывает, был ли отправлен первый результат (полученное значение) до закрытия канала. Если второй возвращаемый результат `false` , то первым возвращаемым результатом (полученным значением) должно быть нулевое значение типа элемента канала.

Знание того, что такое блокирующие и неблокирующие операции отправки или получения канала, важно для понимания механизма `select` блокировки потока управления, который будет представлен в следующем разделе.

В приведенных выше пояснениях, если горутина перемещается из очереди (отправляющей или принимающей очереди горутины) канала, и горутина была заблокирована из-за помещения в очередь в [`select` блоке кода потока управления](https://go101.org/article/channel.html#select) , тогда горутина будет быть возобновлен в рабочее состояние на шаге *9* выполнения [`select` блока кода потока управления](https://go101.org/article/channel.html#select-implementation) . Он может быть исключен из соответствующей очереди горутины нескольких каналов, участвующих в `select` блоке кода потока управления.

Согласно приведенным выше пояснениям, мы можем получить некоторые факты о внутренних очередях канала.

*   Если канал закрыт, его очередь отправляющей и принимающей горутин должна быть пустой, но очередь буфера значений может быть непустой.
*   В любое время, если буфер значений не пуст, то его приемная очередь горутины должна быть пустой.
*   В любое время, если буфер значений не заполнен, то его очередь отправки goroutine должна быть пустой.
*   Если канал буферизован, то в любое время по крайней мере одна из очередей goroutine канала должна быть пустой (отправка, получение или обе).
*   Если канал не буферизован, большую часть времени одна из его очереди отправляющей и принимающей горутин должна быть пустой, за одним исключением. Исключением является то, что горутина может быть помещена в обе очереди при выполнении [`select` блока кода потока управления](https://go101.org/article/channel.html#select) .

### Некоторые примеры использования канала

Теперь, когда вы прочитали предыдущий раздел, давайте рассмотрим несколько примеров, в которых каналы используются для улучшения вашего понимания.

Простой пример запроса/ответа. Две горутины в этом примере взаимодействуют друг с другом через небуферизованный канал.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan int) // an unbuffered channel
	go func(ch chan<- int, x int) {
		time.Sleep(time.Second)
		// <-ch    // fails to compile
		// Send the value and block until the result is received.
		ch <- x*x // 9 is sent
	}(c, 3)
	done := make(chan struct{})
	go func(ch <-chan int) {
		// Block until 9 is received.
		n := <-ch
		fmt.Println(n) // 9
		// ch <- 123   // fails to compile
		time.Sleep(time.Second)
		done <- struct{}{}
	}(c)
	// Block here until a value is received by
	// the channel "done".
	<-done
	fmt.Println("bye")
}

```

Выход:

```
9
bye

```

Демонстрация использования буферизованного канала. Эта программа не параллельная, она просто показывает, как использовать буферизованные каналы.

```go
package main

import "fmt"

func main() {
	c := make(chan int, 2) // a buffered channel
	c <- 3
	c <- 5
	close(c)
	fmt.Println(len(c), cap(c)) // 2 2
	x, ok := <-c
	fmt.Println(x, ok) // 3 true
	fmt.Println(len(c), cap(c)) // 1 2
	x, ok = <-c
	fmt.Println(x, ok) // 5 true
	fmt.Println(len(c), cap(c)) // 0 2
	x, ok = <-c
	fmt.Println(x, ok) // 0 false
	x, ok = <-c
	fmt.Println(x, ok) // 0 false
	fmt.Println(len(c), cap(c)) // 0 2
	close(c) // panic!
	// The send will also panic if the above
	// close call is removed.
	c <- 7
}

```

Бесконечный футбольный матч.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	var ball = make(chan string)
	kickBall := func(playerName string) {
		for {
			fmt.Println(<-ball, "kicked the ball.")
			time.Sleep(time.Second)
			ball <- playerName
		}
	}
	go kickBall("John")
	go kickBall("Alice")
	go kickBall("Bob")
	go kickBall("Emily")
	ball <- "referee" // kick off
	var c chan bool   // nil
	<-c               // blocking here for ever
}

```

Пожалуйста, ознакомьтесь с [вариантами использования канала,](https://go101.org/article/channel-use-cases.html) чтобы узнать больше примеров использования канала.

### Значения элементов канала передаются путем копирования

Когда значение передается из одной горутины в другую, это значение будет скопировано хотя бы один раз. Если переданное значение когда-либо оставалось в буфере значений канала, то в процессе передачи произойдет две копии. Одна копия происходит, когда значение копируется из горутины-отправителя в буфер значений, другое происходит, когда значение копируется из буфера значений в горутину-получатель. Подобно присвоению значения и передаче аргумента функции, при передаче значения [копируется только его непосредственная часть](https://go101.org/article/value-part.html#about-value-copy) .

Для стандартного компилятора Go размер типов элементов канала должен быть меньше `65536` . Однако, как правило, мы не должны создавать каналы с типами элементов большого размера, чтобы избежать слишком больших затрат на копирование в процессе передачи значений между горутинами. Поэтому, если размер переданного значения слишком велик, лучше использовать вместо этого тип элемента указателя, чтобы избежать больших затрат на копирование значения.

### О сборках мусора Channel и Goroutine

Обратите внимание, что на канал ссылаются все горутины либо в отправляющей, либо в принимающей очереди горутин канала, поэтому, если ни одна из очередей канала не пуста, канал не может быть удален сборщиком мусора. С другой стороны, если горутина заблокирована и остается либо в отправляющей, либо в принимающей очереди горутины канала, то эта горутина также не может быть удалена сборщиком мусора, даже если на канал ссылается только эта горутина. На самом деле горутина может быть удалена сборщиком мусора только тогда, когда она уже завершила работу.

### Операции отправки и получения канала — это простые операторы

Операции отправки канала и операции приема являются [простыми операторами](https://go101.org/article/expressions-and-statements.html#simple-statements) . Операция приема канала всегда может использоваться как выражение с одним значением. Простые операторы и выражения могут использоваться в определенных частях [основных блоков потока управления](https://go101.org/article/control-flows.html) .

Пример, в котором операции отправки и получения канала отображаются как простые операторы в двух `for` блоках потока управления.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fibonacci := func() chan uint64 {
		c := make(chan uint64)
		go func() {
			var x, y uint64 = 0, 1
			for ; y < (1 << 63); c <- y { // here
				x, y = y, x+y
			}
			close(c)
		}()
		return c
	}
	c := fibonacci()
	for x, ok := <-c; ok; x, ok = <-c { // here
		time.Sleep(time.Second)
		fmt.Println(x)
	}
}

```

### `for-range` на каналах

Блок `for-range` кода потока управления применяется к каналам. Цикл будет пытаться итеративно получать значения, отправленные в канал, пока канал не будет закрыт и его очередь буфера значений не станет пустой. Синтаксис `for-range` массивов, срезов и карт позволяет использовать несколько переменных итерации. Однако для `for-range` блоков, применяемых к каналам, можно использовать не более одной переменной итерации, которая используется для хранения полученных значений.

```go
for v := range aChannel {
	// use v
}

```

эквивалентно

```go
for {
	v, ok = <-aChannel
	if !ok {
		break
	}
	// use v
}

```

Конечно, здесь `aChannel` значение не должно быть каналом только для отправки. Если это нулевой канал, петля заблокируется там навсегда.

Например, второй `for` блок цикла в примере, показанном в последнем разделе, можно упростить до

```go
	for x := range c {
		time.Sleep(time.Second)
		fmt.Println(x)
	}

```

### `select-case` Блоки кода потока управления

Существует `select-case` синтаксис кодового блока, специально разработанный для каналов. Синтаксис очень похож на `switch-case` синтаксис блока. Например, в блоке кода может быть несколько `case` ветвей и не более одной `default` ветви . `select-case` Но есть и очевидные различия между ними.

*   `select` За ключевым словом (до `{` ) не допускаются никакие выражения и операторы .
*   В ветвях `fallthrough` нельзя использовать операторы `case` .
*   Каждый оператор, следующий за `case` ключевым словом в `select-case` кодовом блоке, должен быть оператором операции приема или отправки канала. Операция приема канала может появиться как исходное значение простого оператора присваивания. Позже операция канала, следующая за `case` ключевым словом, будет называться `case` операцией.
*   Если есть одна или несколько неблокирующих `case` операций, среда выполнения Go **случайным образом выберет одну из этих неблокирующих операций для выполнения** , а затем продолжит выполнение соответствующей `case` ветки.
*   Если все `case` операции в `select-case` кодовом блоке являются блокирующими операциями, `default` будет выбрана ветвь для выполнения, если `default` ветвь присутствует. Если `default` ветвь отсутствует, текущая горутина будет помещена в соответствующую очередь отправляющей или принимающей горутины каждого канала, участвующего во всех `case` операциях, а затем переходит в состояние блокировки.

По правилам, `select-case` блок кода без каких-либо ветвей `select{}` заставит текущую горутину оставаться в заблокированном состоянии навсегда.

Следующая программа обязательно войдет в `default` ветку.

```go
package main

import "fmt"

func main() {
	var c chan struct{} // nil
	select {
	case <-c:             // blocking operation
	case c <- struct{}{}: // blocking operation
	default:
		fmt.Println("Go here.")
	}
}

```

Пример, показывающий, как использовать try-send и try-receive:

```go
package main

import "fmt"

func main() {
	c := make(chan string, 2)
	trySend := func(v string) {
		select {
		case c <- v:
		default: // go here if c is full.
		}
	}
	tryReceive := func() string {
		select {
		case v := <-c: return v
		default: return "-" // go here if c is empty
		}
	}
	trySend("Hello!") // succeed to send
	trySend("Hi!")    // succeed to send
	// Fail to send, but will not block.
	trySend("Bye!")
	// The following two lines will
	// both succeed to receive.
	fmt.Println(tryReceive()) // Hello!
	fmt.Println(tryReceive()) // Hi!
	// The following line fails to receive.
	fmt.Println(tryReceive()) // -
}

```

В следующем примере вероятность паники составляет 50%. В этом примере обе `case` операции являются неблокирующими.

```go
package main

func main() {
	c := make(chan struct{})
	close(c)
	select {
	case c <- struct{}{}:
		// Panic if the first case is selected.
	case <-c:
	}
}

```

### Реализация механизма выбора

Механизм выбора в Go — важная и уникальная функция. Здесь перечислены этапы [реализации механизма select официальной средой выполнения Go](https://github.com/golang/go/blob/master/src/runtime/select.go) .

Есть несколько шагов для выполнения `select-case` блока:

1.  оценивайте все задействованные выражения канала и выражения значений, которые потенциально могут быть отправлены в `case` операциях, сверху вниз и слева направо. Целевые значения для операций получения (как исходные значения) в назначениях в настоящее время не нужно оценивать.
2.  рандомизируйте порядок ветвления для опроса на шаге *5* . Ветвь `default` всегда помещается на последнюю позицию в порядке результатов. Каналы могут дублироваться в `case` операциях.
3.  отсортируйте все задействованные каналы в `case` операциях, чтобы избежать взаимоблокировок (с другими горутинами) на следующем шаге. В первых `N` каналах отсортированного результата не остается дубликатов каналов, где `N` \- количество задействованных каналов в `case` операциях. Ниже ***порядок блокировки каналов*** является концепцией для первых `N` каналов в отсортированном результате.
4.  заблокировать (т. е. получить блокировки) все вовлеченные каналы в соответствии с порядком блокировки каналов, созданным на последнем шаге.
5.  опросить каждую ветвь в блоке выбора в случайном порядке, полученном на шаге *2* :

    1.  если это `case` ветвь и соответствующая операция канала является операцией отправки значения в закрытый канал, разблокировать все каналы обратным порядком блокировки канала и вызвать панику текущей горутины. Перейдите к шагу *12* .
    2.  если это `case` ветвь и соответствующая операция канала не блокируется, выполните операцию канала и разблокируйте все каналы обратным порядком блокировки канала, затем выполните `case` тело соответствующей ветви. Операция канала может разбудить другую горутину в заблокированном состоянии. Перейдите к шагу *12* .
    3.  если это `default` ветка, то разблокировать все каналы обратным порядком блокировки каналов и выполнить `default` тело ветки. Перейдите к шагу *12* .

    (До сих пор `default` ветвь отсутствует и все `case` операции являются блокирующими.)
6.  поместите (поставьте в очередь) текущую горутину (вместе с информацией о соответствующей `case` ветке) в очередь получающих или отправляющих горутин задействованного канала в каждой `case` операции. Текущая горутина может быть помещена в очереди канала несколько раз, поскольку задействованные каналы во многих случаях могут быть одним и тем же.
7.  перевести текущую горутину в состояние блокировки и разблокировать все каналы в обратном порядке блокировки каналов.
8.  ждать в заблокированном состоянии, пока другие операции канала не разбудят текущую горутину, ...
9.  текущая горутина пробуждается другой операцией канала в другой горутине. Другой операцией может быть операция закрытия канала или операция отправки/приема канала. Если это операция отправки/приема канала, должна быть `case` операция приема/отправки канала (в текущем поясняемом `select-case` блоке), взаимодействующая с ней (путем передачи значения). При сотрудничестве текущая горутина будет исключена из очереди получающей/отправляющей горутины канала.
10.  заблокировать все задействованные каналы в соответствии с порядком блокировки каналов.
11.  удалять текущую горутин из очереди принимающих или отправляющих горутин задействованного канала в каждой `case` операции,
    1.  если текущая горутина пробуждается операцией закрытия канала, перейдите к шагу *5* .
    2.  если текущая горутина пробуждается операцией отправки/получения канала, соответствующая `case` ветвь взаимодействующей операции приема/отправки уже была найдена в процессе удаления из очереди, поэтому просто разблокируйте все каналы обратным порядком блокировки канала и выполните соответствующую `case` ветвь .
12.  Выполнено.

Из реализации мы знаем, что

*   горутина может оставаться в очередях отправляющей и принимающей горутин нескольких каналов одновременно. Он может даже оставаться в очереди отправляющей и принимающей горутин одного и того же канала одновременно.
*   когда горутина, которая в настоящее время заблокирована в `select-case` блоке кода, возобновляется позже, она будет удалена из всех очередей отправляющей горутины и очередей принимающей горутины всех каналов, участвующих в операциях канала, следующих за `case` ключевыми словами в `select-case` блоке кода.
