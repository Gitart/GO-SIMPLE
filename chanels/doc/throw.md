
# Замки против каналов в параллельном режиме Go

Сравните два способа обмена информацией с goroutines, используя синхронизированную общую память, а другую - используя каналы.

Go популяризировал мантру , не обмениваясь памятью; обмениваться памятью путем общения. У языка есть традиционная мьютекса (конструкция взаимного исключения) для координации доступа к общей памяти, но она способствует использованию каналов для обмена информацией между гортанами.

В этой статье короткий взгляд на goroutines, нити и условия гонки устанавливает сцену для просмотра двух программ Go. В первой программе goroutines взаимодействуют через синхронизированную общую память, а вторая использует каналы для той же цели. Код доступен с моего  сайта  в ZIP-файле с README.

## Темы и условия гонки
Поток представляет собой последовательность исполняемых инструкций, а также потоки в пределах одной и той же доли процесса адресное пространство: Каждый поток в многопоточном процессе доступа / записи прочитал в тех же самых местах памяти. Условие гонки на основе памяти возникает, если два или более потоков (по крайней мере один из которых выполняет операцию записи ) имеют некоординированный доступ к одному и тому же месту памяти.

Рассмотрим это описание целочисленной переменной n, значение которой составляет 777, и две нити, пытающиеся изменить ее содержимое:

```
     n = n + 10  +-----+  n = n - 10
Thread1------------>| 777 |<------------Thread2
                    +-----+
                       n
```

На многопроцессорной машине два потока могут выполняться буквально в одно и то же время. Воздействие на переменную nтогда неопределенно. Очень важно отметить, что каждое попытка обновления состоит из двух операций на уровне машины: арифметической операции nс текущим значением (или добавлением или вычитанием 10), а также последующей операцией присваивания, которая устанавливает nновое значение (либо 787, либо 767).

Сопряженные операции, выполняемые в двух потоках, могут чередоваться различными неподходящими способами. Рассмотрим следующий сценарий: каждый нумерованный элемент является единственной операцией на уровне машины. Для простоты предположим, что каждая операция занимает один тик системных часов:

Thread1 делает дополнение к вычислению 787, которое сохраняется во временном месте (в стеке или в регистре CPU).   
Thread2 делает вычитание для вычисления 767, также сохраняется во временном местоположении.    
Thread2 выполняет присвоение; значение nтеперь составляет 767.    
Thread1 выполняет назначение; значение nтеперь составляет 787.    

Придя последним, Thread1 выиграл гонку против Thread2. Понятно, что произошло неправильное чередование. Thread1 выполняет операцию добавления, задерживается на два тика, а затем выполняет назначение. Напротив, Thread2 выполняет операции вычитания и последующего присваивания без прерывания. Исправление является ясным: операции арифметики и присваивания должны выполняться так, как если бы они были единой атомной операцией. Конструкция, такая как мьютекс, обеспечивает требуемое исправление, а Go имеет мьютекс.

Программы Go, как правило, многопоточны, хотя нарезка происходит под поверхностью. На поверхности есть гортаны. Горутин - это зеленая нить - поток под контролем выполнения Go. Напротив, собственный поток находится непосредственно под управлением ОС. Но goroutines мультиплексируют на собственные потоки, которые планируют ОС, а это означает, что условия гонки на основе памяти возможны в Go. Это иллюстрирует первая из двух примеров программ.


## MiserSpendthrift1
Программа MiserSpendthrift1 имитирует общий доступ к банковскому счету. Кроме того main, есть еще два гортани:

Скряга goroutine неоднократно добавляет баланс, одна денежная единица за один раз.
Мот goroutine неоднократно вычитает из баланса, а также одну единицу валюты в то время.
Количество операций, выполняемых каждым goroutine, зависит от аргумента командной строки, который должен быть достаточно большим, чтобы быть интересным (например, от 100 000 до нескольких миллионов). Баланс счета инициализируется до нуля и должен заканчиваться как ноль, потому что депозиты и снятие средств на одну и ту же сумму и одинаковы по количеству.

### Пример 1. Использование мьютекса для координации доступа к общей памяти

```go
package main

import (
   "os"
   "fmt"
   "runtime"
   "strconv"
   "sync"
)

var accountBalance = 0    // balance for shared bank account
var mutex = &sync.Mutex{} // mutual-exclusion lock

// critical-section code with explicit locking/unlocking
func updateBalance(amt int) {
   mutex.Lock()
   accountBalance += amt  // two operations: update and assignment
   mutex.Unlock()
}

func reportAndExit(msg string) {
   fmt.Println(msg)
   os.Exit(-1) // all 1s in binary
}

func main() {
   if len(os.Args) < 2 {
      reportAndExit("\nUsage: go ms1.go <number of updates per thread>")
   }
   iterations, err := strconv.Atoi(os.Args[1])
   if err != nil {
      reportAndExit("Bad command-line argument: " + os.Args[1]);
   }

   var wg sync.WaitGroup  // wait group to ensure goroutine coordination

   // miser increments the balance
   wg.Add(1)           // increment WaitGroup counter
   go func() {
      defer wg.Done()  // invoke Done on the WaitGroup when finished
      for i := 0; i < iterations ; i++ {
         updateBalance(1)
         runtime.Gosched()  // yield to another goroutine
      }
   }()

   // spendthrift decrements the balance
   wg.Add(1)           // increment WaitGroup counter
   go func() {
      defer wg.Done()
      for i := 0; i < iterations; i++ {
         updateBalance(-1)
         runtime.Gosched()  // be nice--yield
      }
   }()

   wg.Wait()  // await completion of miser and spendthrift
   fmt.Println("Final balance: ", accountBalance)  // confirm final balance is zero
}
```

Поток управления в программе MiserSpendthrift1 (см. Выше) можно описать следующим образом:

Программа начинается с попытки прочитать и проверить аргумент командной строки, в котором указано, сколько раз (например, миллион) скряга и расточитель должны обновлять остаток на счете.

mainGoroutine запускает два других с вызовом:
```go
go func() { // either the miser or the spendthrift
```

```go
var accountBalance = 0    // баланс для общего банковского счета 
var mutex = & sync. Mutex {} // блокировка взаимного исключения
```

Код мьютекса используется в updateBalanceфункции для защиты критического раздела , который является сегментом кода, который должен выполняться однопоточным способом для правильной работы программы:

```go
func updateBalance ( amt int ) {
   мьютекс . Lock ()
   accountBalance + = amt   // критический раздел
   mutex . Разблокировать () 
}
```

* Первый из двух запущенных горуций представляет собой скрягу , а второй представляет собой расточительство .
* Программа использует, sync.WaitGroupчтобы гарантировать, что maingoroutine не распечатает окончательный баланс, пока скряга и трафик-трафик закончит свою работу и не прекратятся.
* Программа MiserSpendthrift1 объявляет две глобальные переменные: одну целочисленную переменную, представляющую общую банковскую учетную запись, а другую - мьютекс, чтобы обеспечить согласованный доступ к учетной записи goroutine:


Критический раздел - это оператор между вызовами Lock()и Unlock()вызовами. Хотя одна строка в исходном коде Go, этот оператор включает в себя две различные операции: арифметическую операцию, за которой следует назначение. Эти две операции должны выполняться вместе, по одному потоку за раз, что обеспечивает код мьютекса. При наличии кода блокировки в accountBalanceконце есть ноль, потому что количество добавлений на 1 и вычитание на единицу одинаковы.

Если код мьютекса удален, конечное значение accountBalanceнепредсказуемо. На двух пробах пробега с удаленным кодом блокировки окончательный баланс был 249 при первом запуске и -87 на втором, тем самым подтвердив, что произошло состояние гонки на основе памяти.

### Поведение кода мьютекса заслуживает пристального взгляда:

Чтобы выполнить код критического раздела, goroutine должен сначала захватить блокировку, выполнив mutex.Lock()вызов. Если замок уже удерживается, то goroutine блокируется до тех пор, пока блокировка не станет доступной; в противном случае goroutine выполняет критически важную часть, защищенную мьютексом.
Мьютекс гарантирует взаимное исключение в том, что только один горутин за один раз может выполнить сегмент заблокированного кода. Мьютекс обеспечивает однопоточное выполнение критического раздела: арифметическую операцию, за которой следует операция присваивания.
Призыв к Unlock()выпуску удерживаемого замка, чтобы какой-то горутин (возможно, тот, который только что выпустил замок) мог снова захватить замок.
В программе MiserSpendthrift1 три goroutines (скряга, трата и т. Д.) Обмениваются mainданными по названию разделяемой памяти accountBalance. Мьютекс координирует доступ к этой переменной скверным и расточительным делом и mainпытается получить доступ к переменной только после того, как обе скряга и расторжение прекратятся. Даже при относительно большом аргументе командной строки (например, от пяти до 10 миллионов) программа работает относительно быстро и дает ожидаемое конечное значение нуля для accountBalance.

Пакет sync/atomicимеет такие функции, как AddInt32с синхронизацией , запеченной в Например, если. accountBalanceТип был изменены от intдо int32, то updateBalanceфункция может быть упрощена следующим образом :

```go
func updateBalance ( amt int32 ) {          // аргумент должен быть int32 также
   атомарным . AddInt32 ( & accountBalance , amt ) // не требуется явная блокировка 
}
```


## MiserSpendthrift2
Программа MiserSpendthrift2 снова имеет глобальную переменную, accountBalanceинициализированную нулем, и снова есть жалкие и тратные трафик, требующие обновления баланса. Однако эта программа не использует мьютексы для предотвращения состояния гонки. Вместо этого теперь есть правитель банка, который обращается к ним accountBalanceв ответ на просьбы от скупых и расточителей. Эти два goroutines больше не обновляют accountBalanceнапрямую. Вот эскиз архитектуры:

```
                  requests         updates
miser/spendthrift---------->banker--------->balance
```

Эта архитектура с поддержкой потокобезопасного канала Go для сериализации запросов от скряги и расточительства предотвращает состояние гонки accountBalance.

## Пример 2. Использование поточно-безопасного канала для координации доступа к общей памяти

```go
package main

import (
   "os"
   "fmt"
   "runtime"
   "strconv"
   "sync"
)

type bankOp struct { // bank operation: deposit or withdraw
   howMuch int       // amount
   confirm chan int  // confirmation channel
}

var accountBalance = 0          // shared account
var bankRequests chan *bankOp   // channel to banker

func updateBalance(amt int) int {
   update := &bankOp{howMuch: amt, confirm: make(chan int)}
   bankRequests <- update
   newBalance := <-update.confirm
   return newBalance
}

// For now a no-op, but could save balance to a file with a timestamp.
func logBalance(current int) { }

func reportAndExit(msg string) {
   fmt.Println(msg)
   os.Exit(-1) // all 1s in binary
}

func main() {
   if len(os.Args) < 2 {
      reportAndExit("\nUsage: go ms1.go <number of updates per thread>")
   }
   iterations, err := strconv.Atoi(os.Args[1])
   if err != nil {
      reportAndExit("Bad command-line argument: " + os.Args[1]);
   }

   bankRequests = make(chan *bankOp, 8) // 8 is channel buffer size

   var wg sync.WaitGroup
   // The banker: handles all requests for deposits and withdrawals through a channel.
   go func() {
      for {
         /* The select construct is non-blocking:
            -- if there's something to read from a channel, do so
            -- otherwise, fall through to the next case, if any */
         select {
         case request := <-bankRequests:
            accountBalance += request.howMuch   // update account
            request.confirm <- accountBalance   // confirm with current balance
         }
      }
   }()

   // miser increments the balance
   wg.Add(1)           // increment WaitGroup counter
   go func() {
      defer wg.Done()  // invoke Done on the WaitGroup when finished
      for i := 0; i < iterations ; i++ {
         newBalance := updateBalance(1)
         logBalance(newBalance)
         runtime.Gosched()  // yield to another goroutine
      }
   }()

   // spendthrift decrements the balance
   wg.Add(1)           // increment WaitGroup counter
   go func() {
      defer wg.Done()
      for i := 0; i < iterations; i++ {
         newBalance := updateBalance(-1)
         logBalance(newBalance)
         runtime.Gosched()  // be nice--yield
      }
   }()

   wg.Wait()  // await completion of miser and spendthrift
   fmt.Println("Final balance: ", accountBalance) // confirm the balance is zero
}

```

Изменения в программе MiserSpendthrift2 можно резюмировать следующим образом. Существует BankOpструктура:

```go
type bankOp struct { // bank operation: deposit or withdraw
   howMuch int       // amount
   confirm chan int  // confirmation channel
}
```
что скряга и тратящие деньги используют для выполнения запросов на обновление. howMuchПоле количество обновлений, либо 1 (скупец) или -1 (расточитель). confirmПоле представляет собой канал , который банкир goroutine использует в ответ на скупец или расточительный запрос; этот канал возвращает новый баланс обратно в запрос. Для эффективности адрес bankOpструктуры, а не ее копия, отправляется по bankRequestsканалу, который объявляется следующим образом:

```go
var bankRequests chan *bankOp // channel of pointers to a bankOp
```

Каналы синхронизированы, то есть поточно-безопасные по умолчанию.

```
func updateBalance(amt int) int {   // request structure
   update := &bankOp{howMuch: amt,
                     confirm: make(chan int)}
   bankRequests <- update           // send request
   newBalance := <-update.confirm   // await confirmation
   return newBalance                // perhaps to be logged
}
```
**bankRequests** Канал имеет размер буфера восьми свести к минимуму блокирование. Канал может содержать до восьми непрочитанных запросов, прежде чем bankOpблокировать дополнительные попытки добавления другого указателя. В то же время банкир-горутин должен обрабатывать запросы по мере их поступления; запрос автоматически удаляется из канала, когда банкир его считывает. Однако confirmканал не буферизуется. Запросчик блокирует до сообщения подтверждения - обновленный баланс, хранящийся локально в newBalanaceпеременной, поступает от банкира.

Локальные переменные и параметры в updateBalanceфункции ( update, newBalanceи amt) являются , таким образом , потокобезопасной , потому что каждый goroutine получает свои собственные копии. Каналы тоже потокобезопасны, так что тело updateBalanceфункции больше не требует явной блокировки. Какое облегчение для программиста!

Банкир горутин бесконечно петляет, ожидая просьб от скупых и расточительных гостей:

```go
for {
   select {
   case request := <-bankRequests:      // Is there a request?
      accountBalance += request.howMuch // If so, update balance and
      request.confirm <- accountBalance // confirm to requester
   }
   // other cases could be added (e.g., golf outings)
}
```

В то время как жалкие и расточительные goroutines по-прежнему активны, только гость банкира имеет доступ к этому accountBalance, что означает, что условие гонки в этой ячейке памяти не может возникнуть. Только после того, как скряга и расточительство закончат работу и mainпрекратят работу, goroutine напечатает окончательное значение accountBalanceи выход. Когда mainзаканчивается, так же и банкир горутин.

Замки или каналы?
Программа MiserSpendthrift2 придерживается мантры Go, предпочитая каналы по синхронной общей памяти. Конечно, заблокированная память может быть сложной. API-интерфейс мьютекса является низкоуровневым и, следовательно, подвержен ошибкам, таким как блокировка, но забывает разблокировать - с тупиком в качестве возможного результата. Более тонкие ошибки включают блокировку только части критического раздела (блокировки) и кода блокировки, который не относится к критическому разделу (overlocking). Функции защиты от резьбы, такие как atomic.AddInt32снижение этих рисков, поскольку блокировка и разблокировка происходят автоматически. Тем не менее остается проблема, как рассуждать о блокировке памяти низкого уровня в сложных программах.

Мантия Гора приносит свои проблемы. Если две программы miser / spendthrift запущены с достаточно большим аргументом командной строки, следует отметить контраст в производительности. Мьютекс может быть низкоуровневым, но он работает хорошо. Каналы Go привлекательны, потому что они обеспечивают встроенную безопасность потоков и способствуют однопоточному доступу к общим критическим ресурсам, таким как accountBalanceв двух примерах программ. Каналы, однако, несут штраф за производительность по сравнению с мьютексами.

Редко в программировании один инструмент подходит для всех задач. Соответственно, Go Go предлагает варианты безопасности потоков, начиная от блокировки низкого уровня через высокоуровневые каналы.



Скупой и трата времени снова вызывают updateBalanceфункцию, чтобы изменить баланс счета. Эта функция больше не имеет явной синхронизации потоков:


Программа MiserSpendthrift1 использует явное блокирование для выделения кода критического сечения и подчеркивает необходимость синхронизации потоков для предотвращения состояния гонки. В примере производственного класса критический раздел может содержать несколько строк исходного кода. В любом случае критический раздел должен быть как можно короче, чтобы программа была как можно более параллельной.
