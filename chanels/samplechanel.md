## Обычные каналы

```golang
package main

import (
   "fmt"
   "sync"
)

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

func main() {
 count := make(chan int)

// Add a count of two, one for each goroutine.
 wg.Add(2)
 fmt.Println("Start Goroutines")
 go printCounts("Goroutine-1", count)   // Launch a goroutine with label "Goroutine-1"
 go printCounts("Goroutine-2", count)  // Launch a goroutine with label "Goroutine-2"
 fmt.Println("Communication of channel begins")
 count <- 1
// Wait for the goroutines to finish.
fmt.Println("Waiting To Finish")
wg.Wait()
fmt.Println("\nTerminating the Program")
}

func printCounts(label string, count chan int) {
// Schedule the call to WaitGroup's Done to tell goroutine is completed.

defer wg.Done()

for {
   // Receives message from Channel
   val, ok := <-count
   if !ok {
   fmt.Println("Channel was closed")
   return
}

fmt.Printf("Count: %d received from %s \n", val, label)
if val == 10 {
   fmt.Printf("Channel Closed from %s \n", label)
   // Close the channel
   close(count)
   return
}

val++
// Send count back to the other goroutine.
count <- val
}
}
```


## Второй вариант
Example Program Demonstrates Unbuffered Channel and range Expression on Channel

```golang
package main

import (
"fmt"
"sync"
)

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

func main() {
count := make(chan int)
wg.Add(2)
fmt.Println("Start Goroutines")
go printCounts("Goroutine-1", count)
go printCounts("Goroutine-2", count)
fmt.Println("Communication of channel begins")

count <- 1
fmt.Println("Waiting To Finish")
wg.Wait()
fmt.Println("\nTerminating the Program")
}


func printCounts(label string, count chan int) {
// Schedule the call to WaitGroup's Done to tell goroutine is completed.
defer wg.Done()
for val := range count {
    fmt.Printf("Count: %d received from %s \n", val, label)

    if val == 10 {
       fmt.Printf("Channel Closed from %s \n", label)
       close(count)
       return
     }
val++
count <- val
}
}
```


## Fibonacci

```golang
Listing 4-7. A Three-Stage Pipeline with Three Goroutines Connected by Two Channels

package main
import (
      "fmt"
      "math"
      "math/rand"
      "sync"
)

type fibvalue struct {
   input, value int
}

var wg sync.WaitGroup

// Generates random values
func randomCounter(out chan int) {
defer wg.Done()
var random int

for x := 0; x < 10; x++ {
   random = rand.Intn(50)
   out <- random
}
close(out)
}

// Produces Fibonacci values of inputs provided by randomCounter
func generateFibonacci(out chan fibvalue, in chan int) {
defer wg.Done()
var input float64

for v := range in {
      input = float64(v)
      // Fibonacci using Binet's formula
      Phi := (1 + math.Sqrt(5)) / 2
      phi := (1 - math.Sqrt(5)) / 2
      result := (math.Pow(Phi, input) - math.Pow(phi, input)) / math.Sqrt(5)

      out <- fibvalue{
      input: v,
      value: int(result),
}
}
   close(out)
}

// Print Fibonacci values generated by generateFibonacci
func printFibonacci(in chan fibvalue) {
      defer wg.Done()
      for v := range in {
          fmt.Printf("Fibonacci value of %d is %d\n", v.input, v.value)
      }
}

func main() {
// Add 3 into WaitGroup Counter
wg.Add(3)
// Declare Channels
randoms := make(chan int)
fibs := make(chan fibvalue)
// Launching 3 goroutines
go randomCounter(randoms) // First stage of pipeline
go generateFibonacci(fibs, randoms) // Second stage of pipeline
go printFibonacci(fibs) // Third stage of pipeline
// Wait for completing all goroutines
wg.Wait()
}
```

