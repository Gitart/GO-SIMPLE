## Обычные каналы

```golang
package main

import (
   "fmt"
   "sync"
)

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

func main() {
 count := make(chan int)

// Add a count of two, one for each goroutine.
 wg.Add(2)
 fmt.Println("Start Goroutines")
 go printCounts("Goroutine-1", count)   // Launch a goroutine with label "Goroutine-1"
 go printCounts("Goroutine-2", count)  // Launch a goroutine with label "Goroutine-2"
 fmt.Println("Communication of channel begins")
 count <- 1
// Wait for the goroutines to finish.
fmt.Println("Waiting To Finish")
wg.Wait()
fmt.Println("\nTerminating the Program")
}

func printCounts(label string, count chan int) {
// Schedule the call to WaitGroup's Done to tell goroutine is completed.

defer wg.Done()

for {
   // Receives message from Channel
   val, ok := <-count
   if !ok {
   fmt.Println("Channel was closed")
   return
}

fmt.Printf("Count: %d received from %s \n", val, label)
if val == 10 {
   fmt.Printf("Channel Closed from %s \n", label)
   // Close the channel
   close(count)
   return
}

val++
// Send count back to the other goroutine.
count <- val
}
}
```


## Второй вариант
Example Program Demonstrates Unbuffered Channel and range Expression on Channel

```golang
package main

import (
"fmt"
"sync"
)

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

func main() {
count := make(chan int)
wg.Add(2)
fmt.Println("Start Goroutines")
go printCounts("Goroutine-1", count)
go printCounts("Goroutine-2", count)
fmt.Println("Communication of channel begins")

count <- 1
fmt.Println("Waiting To Finish")
wg.Wait()
fmt.Println("\nTerminating the Program")
}


func printCounts(label string, count chan int) {
// Schedule the call to WaitGroup's Done to tell goroutine is completed.
defer wg.Done()
for val := range count {
    fmt.Printf("Count: %d received from %s \n", val, label)

    if val == 10 {
       fmt.Printf("Channel Closed from %s \n", label)
       close(count)
       return
     }
val++
count <- val
}
}
```


## Fibonacci
A Three-Stage Pipeline with Three Goroutines Connected by Two Channels

```golang


package main
import (
      "fmt"
      "math"
      "math/rand"
      "sync"
)

type fibvalue struct {
   input, value int
}

var wg sync.WaitGroup

// Generates random values
func randomCounter(out chan int) {
defer wg.Done()
var random int

for x := 0; x < 10; x++ {
   random = rand.Intn(50)
   out <- random
}
close(out)
}

// Produces Fibonacci values of inputs provided by randomCounter
func generateFibonacci(out chan fibvalue, in chan int) {
defer wg.Done()
var input float64

for v := range in {
      input = float64(v)
      // Fibonacci using Binet's formula
      Phi := (1 + math.Sqrt(5)) / 2
      phi := (1 - math.Sqrt(5)) / 2
      result := (math.Pow(Phi, input) - math.Pow(phi, input)) / math.Sqrt(5)

      out <- fibvalue{
      input: v,
      value: int(result),
}
}
   close(out)
}

// Print Fibonacci values generated by generateFibonacci
func printFibonacci(in chan fibvalue) {
      defer wg.Done()
      for v := range in {
          fmt.Printf("Fibonacci value of %d is %d\n", v.input, v.value)
      }
}

func main() {
// Add 3 into WaitGroup Counter
wg.Add(3)
// Declare Channels
randoms := make(chan int)
fibs := make(chan fibvalue)
// Launching 3 goroutines
go randomCounter(randoms) // First stage of pipeline
go generateFibonacci(fibs, randoms) // Second stage of pipeline
go printFibonacci(fibs) // Third stage of pipeline
// Wait for completing all goroutines
wg.Wait()
}
```

## Example with Channel Direction
```golang
// rewrites the example code of Listing 4-7 by clearly specifying the channel direction.
// A Three-Stage Pipeline with Three Goroutines Connected by Two Channels

package main
import (
"fmt"
"math"
"math/rand"
"sync"
)

type fibvalue struct {
   input, value int
}

var wg sync.WaitGroup

func randomCounter(out chan<- int) {
defer wg.Done()
var random int

for x := 0; x < 10; x++ {
   random = rand.Intn(50)
   out <- random
}
close(out)
}

func generateFibonacci(out chan<- fibvalue, in <-chan int) {
      defer wg.Done()
      var input float64
      for v := range in {
            input = float64(v)
            // Fibonacci using Binet's formula
            Phi := (1 + math.Sqrt(5)) / 2
            phi := (1 - math.Sqrt(5)) / 2
            result := (math.Pow(Phi, input) - math.Pow(phi, input)) / math.Sqrt(5)
            out <- fibvalue{ input: v, value: int(result)}
      }
      close(out)
}

func printFibonacci(in <-chan fibvalue) {
      defer wg.Done()
      for v := range in {
            fmt.Printf("Fibonacci value of %d is %d\n", v.input, v.value)
      }
}

func main() {
      wg.Add(3)                          // Add 3 into WaitGroup Counter
      randoms := make(chan int)          // Declare Channels
      fibs := make(chan fibvalue)
      go randomCounter(randoms)          // Launching 3 goroutines 
      go generateFibonacci(fibs, randoms)
      go printFibonacci(fibs)
      wg.Wait()                         // Wait for completing all goroutines
}
```



```golang
package main

import "fmt"

func main() {
    // Make a channel that returns an int.
    c := make(chan int)

    // Call this func.
    go func() {
        // This does a long-running numerical computation.
        // ... It increments a number, then decrements it.
        res := 0
        for i := 0; i < 100; i++ {
            for x := 0; x < 10000; x++ {
                for z := 0; z < 10000; z++ {
                    res++
                }
                for z := 0; z < 10000; z++ {
                    res--
                }
            }
        }
        // Return the counter on the channel.
        c <- res
    }()

    fmt.Println("HERE")

    // Wait for result of func, store value in local.
    res := <-c
    fmt.Println("DONE")
    fmt.Println("RESULT =", res)
}
```

## Chanel with select

```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	c1 := make(chan string, 1)
	c2 := make(chan string, 1)
	
	go func() {
		for {
			c1 <- "from 1"
			time.Sleep(time.Second *2)
		}
	} ()
	go func() {
		for {
			c2 <- "from 2"
			time.Sleep(time.Second * 3)
		}
	} ()
	go func() {
		for {
			select {
			case msg1 := <- c1:
				fmt.Println("Message 1", msg1)
			case msg2 := <- c2:
				fmt.Println("Message 2", msg2)
			case <- time.After(time.Second):
				fmt.Println("timeout")
			}
		}
	} ()
 
	var input string
	fmt.Scanln(&input)
}
```

### Unbuffered and buffered channels
https://nanxiao.gitbooks.io/golang-101-hacks/content/posts/unbuffered-and-buffered-channels.html   
http://www.tapirgames.com/blog/golang-channel    


The channel is divided into two categories: unbuffered and buffered.  
(1) Unbuffered channel   
For unbuffered channel, the sender will block on the channel until the receiver receives the data from the channel, whilst the receiver will also block on the channel until sender sends data into the channel. Check the following example:

```golang
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int)

    go func(ch chan int) {
        fmt.Println("Func goroutine begins sending data")
        ch <- 1
        fmt.Println("Func goroutine ends sending data")
     }(ch)

    fmt.Println("Main goroutine sleeps 2 seconds")
    time.Sleep(time.Second * 2)

    fmt.Println("Main goroutine begins receiving data")
    d := <- ch
    fmt.Println("Main goroutine received data:", d)

    time.Sleep(time.Second)
}
```


The running result likes this:
```
Main goroutine sleeps 2 seconds
Func goroutine begins sending data
Main goroutine begins receiving data
Main goroutine received data: 1
Func goroutine ends sending data
```

After the main goroutine is launched, it will sleep immediately("Main goroutine sleeps 2 seconds" is printed), and this will cause main goroutine relinquishes the CPU to the func goroutine("Func goroutine begins sending data" is printed). But since the main goroutine is sleeping and can't receive data from the channel, so ch <- 1 operation in func goroutine can't complete until d := <- ch in main goroutine is executed(The final 3 logs are printed).
(2) Buffered channel

Compared with unbuffered counterpart, the sender of buffered channel will block when there is no empty slot of the channel, while the receiver will block on the channel when it is empty. Modify the above example:

```golang
package main

import (
    "fmt"
    "time"
)

func main() {
    ch := make(chan int, 2)

    go func(ch chan int) {
        for i := 1; i <= 5; i++ {
            ch <- i
            fmt.Println("Func goroutine sends data: ", i)
        }
        close(ch)
    }(ch)

    fmt.Println("Main goroutine sleeps 2 seconds")
    time.Sleep(time.Second * 2)

    fmt.Println("Main goroutine begins receiving data")
    for d := range ch {
        fmt.Println("Main goroutine received data:", d)
    }
}
```
