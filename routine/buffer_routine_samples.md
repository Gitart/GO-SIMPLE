# Буферизованные каналы и рабочие пулы

## Что такое буферизованные каналы?
Все каналы, которые мы обсуждали в [предыдущем уроке](https://golangbot.com/channels/) , были в основном небуферизованными. Как мы подробно обсуждали в руководстве по [каналам](https://golangbot.com/channels/) , отправка и получение на небуферизованный канал блокируются.
Можно создать канал с буфером. Посылки на буферизованный канал блокируются только тогда, когда буфер заполнен. Точно так же прием из буферизованного канала блокируется только тогда, когда буфер пуст.
Буферизованные каналы можно создать, передав в функцию дополнительный параметр емкости, `make` который задает размер буфера.

```
ch := make(chan type, capacity)

```

*емкость* в приведенном выше синтаксисе должна быть больше 0, чтобы канал имел буфер. Емкость для небуферизованного канала по умолчанию равна 0, поэтому мы пропустили параметр емкости при создании каналов в [предыдущем руководстве](https://golangbot.com/channels/) .

Давайте напишем код и создадим буферизованный канал.

### Пример

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan string, 2)
    ch <- "naveen"
    ch <- "paul"
    fmt.Println(<- ch)
    fmt.Println(<- ch)
}

```

[Запустить программу на детской площадке](https://play.golang.org/p/It-em11etK)

В программе выше в строке №. 9 мы создаем буферизованный канал емкостью 2. Поскольку емкость канала равна 2, в канал можно записать 2 строки без блокировки. Мы записываем 2 строки в канал в строке №. 10 и 11 и канал не блокируется. Мы читаем 2 строки, записанные в строке №. 12 и 13 соответственно. Эта программа печатает,

```
naveen
paul

```

### Другой пример

Давайте рассмотрим еще один пример буферизованного канала, в котором значения канала записываются в параллельную горутину и считываются из основной горутины. Этот пример поможет нам лучше понять, когда выполняется запись в блок буферизованного канала.

```go
package main

import (
    "fmt"
    "time"
)

func write(ch chan int) {
    for i := 0; i < 5; i++ {
        ch <- i
        fmt.Println("successfully wrote", i, "to ch")
    }
    close(ch)
}
func main() {
    ch := make(chan int, 2)
    go write(ch)
    time.Sleep(2 * time.Second)
    for v := range ch {
        fmt.Println("read value", v,"from ch")
        time.Sleep(2 * time.Second)

    }
}

```

[Запустить программу на детской площадке](https://play.golang.org/p/bKe5GdgMK9)

В приведенной выше программе буферизованный канал `ch` емкости `2` создается в строке №. 16 `main` горутина и передается `write` горутине в строке №. 17\. Затем основная горутина спит на 2 секунды. В это время `write` горутина работает одновременно. Горутина `write` имеет цикл, который записывает в канал `for` числа от 0 до 4 . `ch` Емкость этого буферизованного канала равна, `2` и, следовательно, функция записи `Goroutine` сможет немедленно записывать значения `0` и `1` в `ch` канал, а затем она блокируется до тех пор, пока хотя бы одно значение не будет прочитано из `ch` канала. Таким образом, эта программа сразу напечатает следующие 2 строки.

```
successfully wrote 0 to ch
successfully wrote 1 to ch

```

После печати двух вышеприведенных строк запись в `ch` канал в `write` горутине блокируется до тех пор, пока кто-нибудь не прочитает из `ch` канала. Поскольку основная горутина спит 2 секунды, прежде чем начать чтение из канала, программа не будет ничего печатать в течение следующих 2 секунд. Горутина `main` просыпается через 2 секунды и начинает чтение из `ch` канала, используя `for range` цикл в строке №. 19, печатает считанное значение, а затем снова засыпает на 2 секунды, и этот цикл продолжается до тех пор, пока `ch` не будет закрыт. Таким образом, программа напечатает следующие строки через 2 секунды:

```
read value 0 from ch
successfully wrote 2 to ch

```

Это будет продолжаться до тех пор, пока все значения не будут записаны в канал и он не будет закрыт в `write` горутине. Конечным результатом будет,

```
successfully wrote 0 to ch
successfully wrote 1 to ch
read value 0 from ch
successfully wrote 2 to ch
read value 1 from ch
successfully wrote 3 to ch
read value 2 from ch
successfully wrote 4 to ch
read value 3 from ch
read value 4 from ch

```

### Тупик

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan string, 2)
    ch <- "naveen"
    ch <- "paul"
    ch <- "steve"
    fmt.Println(<-ch)
    fmt.Println(<-ch)
}

```

[Запустить программу на детской площадке](https://play.golang.org/p/FW-LHeH7oD)

В приведенной выше программе мы записываем 3 строки в буферизованный канал емкостью 2. Когда управление достигает третьей строки, записываем в строку №. 11, запись заблокирована, так как канал превысил свою пропускную способность. Теперь какая-то горутина должна читать из канала, чтобы запись продолжалась, но в этом случае нет параллельного чтения из этого канала. Следовательно, возникнет **взаимоблокировка** , и программа во время выполнения запаникует со следующим сообщением:

```
fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan send]:
main.main()
    /tmp/sandbox091448810/prog.go:11 +0x8d

```

### Закрытие буферизованных каналов

Мы уже обсуждали закрытие каналов в [предыдущем уроке](https://golangbot.com/channels/#closingchannelsandforrangeloopsonchannels) . В дополнение к тому, что мы узнали в предыдущем уроке, есть еще одна тонкость, которую следует учитывать при закрытии буферизованных каналов.

Возможно чтение данных из уже закрытого буферизованного канала. Канал вернет данные, которые уже были записаны в канал, и как только все данные будут прочитаны, он вернет нулевое значение канала.

Давайте напишем программу, чтобы понять это.

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int, 5)
    ch <- 5
    ch <- 6
    close(ch)
    n, open := <-ch
    fmt.Printf("Received: %d, open: %t\n", n, open)
    n, open = <-ch
    fmt.Printf("Received: %d, open: %t\n", n, open)
    n, open = <-ch
    fmt.Printf("Received: %d, open: %t\n", n, open)
}

```

[Запустить программу на детской площадке](https://play.golang.org/p/19cZrsy2X4v)

В приведенной выше программе мы создали буферизованный канал емкости `5` в строке №. 8\. Потом пишем `5` и `6` на канал. После этого канал закрывается в строке №. 11\. Несмотря на то, что канал закрыт, мы можем прочитать значения, уже записанные в канал. Это делается в строке №. 12 и 14. Значение `n` будет `5` и открыто будет `true` в строке №. 12\. Значение `n` будет `6` и снова будет открыто `true` в строке № 14. Теперь мы закончили чтение `5` и `6` из канала, и больше нет данных для чтения. Теперь, когда канал снова читается в строке №. 16, значение `n` будет `0` равно нулю `int` и `open` будет `false` указывает на то, что канал закрыт.

Эта программа будет печатать

```
Received: 5, open: true
Received: 6, open: true
Received: 0, open: false

```

Эту же программу можно написать и с использованием цикла for range.

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int, 5)
    ch <- 5
    ch <- 6
    close(ch)
    for n := range ch {
        fmt.Println("Received:", n)
    }
}

```

[Запустить программу на детской площадке](https://play.golang.org/p/xVgkn64Jado)

Петля `for range` в строке №. 12 вышеприведенной программы прочитает все значения, записанные в канал, и завершит работу, когда больше не будет значений для чтения, поскольку канал уже закрыт.

Эта программа будет печатать,

```
Received: 5
Received: 6

```

### Длина против емкости

Емкость буферизованного канала — это количество значений, которые может хранить канал. Это значение мы указываем при создании буферизованного канала с помощью `make` функции.

Длина буферизованного канала — это количество элементов, находящихся в данный момент в очереди.

Программа все прояснит 😀

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan string, 3)
    ch <- "naveen"
    ch <- "paul"
    fmt.Println("capacity is", cap(ch))
    fmt.Println("length is", len(ch))
    fmt.Println("read value", <-ch)
    fmt.Println("new length is", len(ch))
}

```

[Запустить программу на детской площадке](https://play.golang.org/p/2ggC64yyvr)

В приведенной выше программе канал создан с пропускной способностью `3` , то есть он может вместить 3 строки. Затем мы записываем 2 строки в канал в строке №. 9 и 10 соответственно. Теперь в канале стоят 2 строки, и, следовательно, его длина равна `2` . В строке нет. 13, мы читаем строку из канала. Теперь в канале стоит только одна строка, и, следовательно, его длина становится равной `1` . Эта программа будет печатать,

```
capacity is 3
length is 2
read value naveen
new length is 1

```

### группа ожидания

Следующий раздел этого руководства посвящен *пулам рабочих процессов* . Чтобы понять рабочие пулы, нам нужно сначала узнать, `WaitGroup` как они будут использоваться при реализации рабочего пула.

Группа ожидания используется для ожидания завершения выполнения набора горутин. Элемент управления блокируется до тех пор, пока все горутины не закончат выполнение. Допустим, у нас есть 3 одновременно выполняемых горутины, порожденные самой `main` горутиной. Goroutines `main` должны дождаться завершения 3 других Goroutines, прежде чем завершаться. Это можно сделать с помощью WaitGroup.

Давайте остановим теорию и сразу напишем немного кода 😀

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func process(i int, wg *sync.WaitGroup) {
    fmt.Println("started Goroutine ", i)
    time.Sleep(2 * time.Second)
    fmt.Printf("Goroutine %d ended\n", i)
    wg.Done()
}

func main() {
    no := 3
    var wg sync.WaitGroup
    for i := 0; i < no; i++ {
        wg.Add(1)
        go process(i, &wg)
    }
    wg.Wait()
    fmt.Println("All go routines finished executing")
}

```

[Бегать на детской площадке](https://play.golang.org/p/CZNtu8ktQh)

[WaitGroup](https://golang.org/pkg/sync/#WaitGroup) — это тип структуры, и мы создаем переменную типа с нулевым значением `WaitGroup` в строке № 18. Способ `WaitGroup` работы заключается в использовании счетчика. Когда мы вызываем `Add` метод `WaitGroup` и передаем ему значение `int` , `WaitGroup` счетчик увеличивается на значение, переданное в `Add` . Уменьшить значение счетчика можно, вызвав `Done()` метод группы ожидания. Метод `Wait()` блокирует объект, `Goroutine` в котором он вызывается, пока счетчик не станет равным нулю.

В приведенной выше программе мы вызываем `wg.Add(1)` строку №. 20 внутри `for` цикла, который повторяется 3 раза. Таким образом, счетчик теперь становится равным 3. `for` Цикл также порождает 3 `process` горутины, а затем вызывается `wg.Wait()` в строке №. 23 заставляет `main` горутину ждать, пока счетчик не станет равным нулю. Счетчик уменьшается вызовом `wg.Done` в `process` горутине в строке №. 13\. Как только все 3 порожденных горутины закончат свое выполнение, то есть когда `wg.Done()` они будут вызваны три раза, счетчик обнулится, а основная горутина будет разблокирована.

**Важно передать указатель `wg` в строке №. 21\. Если указатель не передан, то каждая горутина будет иметь свою собственную копию `WaitGroup` и `main` не будет уведомлена об окончании выполнения.**

Эта программа выводит.

```
started Goroutine  2
started Goroutine  0
started Goroutine  1
Goroutine 0 ended
Goroutine 2 ended
Goroutine 1 ended
All go routines finished executing

```

Ваш вывод может отличаться от моего, поскольку порядок выполнения горутин может различаться :).

### Реализация пула рабочих

Одним из важных применений буферизованного канала является реализация [рабочего пула](https://en.wikipedia.org/wiki/Thread_pool) .

В общем, рабочий пул — это набор потоков, ожидающих назначения им задач. Как только они завершат назначенную задачу, они снова становятся доступными для следующей задачи.

Мы реализуем рабочий пул, используя буферизованные каналы. Наш рабочий пул будет выполнять задачу по нахождению суммы цифр входного числа. Например, если передано 234, вывод будет 9 (2 + 3 + 4). Входными данными для рабочего пула будет список псевдослучайных целых чисел.

Ниже приведены основные функции нашего пула рабочих.

*   Создание пула горутин, которые прослушивают входной буферизованный канал, ожидая назначения заданий.
*   Добавление заданий во входной буферизованный канал
*   Запись результатов в выходной буферизованный канал после завершения задания
*   Чтение и печать результатов из выходного буферизованного канала

Мы напишем эту программу шаг за шагом, чтобы ее было легче понять.

Первым шагом будет создание структур, представляющих задание и результат.

```go
type Job struct {
    id       int
    randomno int
}
type Result struct {
    job         Job
    sumofdigits int
}

```

Каждая `Job` структура имеет a `id` и a, `randomno` для которых необходимо вычислить сумму отдельных цифр.

Структура `Result` имеет `job` поле, которое является заданием, для которого она содержит результат (сумму отдельных цифр) в `sumofdigits` поле.

Следующим шагом является создание буферизованных каналов для приема заданий и записи вывода.

```go
var jobs = make(chan Job, 10)
var results = make(chan Result, 10)

```

Worker Goroutines прослушивают новые задачи на `jobs` буферизованном канале. После завершения задачи результат записывается в `results` буферизованный канал.

Приведенная `digits` ниже функция выполняет фактическую работу по нахождению суммы отдельных цифр целого числа и возвращает ее. Мы добавим этой функции спящий режим на 2 секунды, чтобы имитировать тот факт, что этой функции требуется некоторое время для вычисления результата.

```go
func digits(number int) int {
    sum := 0
    no := number
    for no != 0 {
        digit := no % 10
        sum += digit
        no /= 10
    }
    time.Sleep(2 * time.Second)
    return sum
}

```

Далее мы напишем функцию, которая создает рабочую горутину.

```go
func worker(wg *sync.WaitGroup) {
    for job := range jobs {
        output := Result{job, digits(job.randomno)}
        results <- output
    }
    wg.Done()
}

```

Приведенная выше функция создает рабочий процесс, который читает из `jobs` канала, создает `Result` структуру, используя текущее `job` и возвращаемое значение `digits` функции, а затем записывает результат в `results` буферизованный канал. Эта функция принимает группу ожидания `wg` в качестве параметра, для которого она будет вызывать `Done()` метод, когда все `jobs` будет завершено.

Функция `createWorkerPool` создаст пул рабочих горутин.

```go
func createWorkerPool(noOfWorkers int) {
    var wg sync.WaitGroup
    for i := 0; i < noOfWorkers; i++ {
        wg.Add(1)
        go worker(&wg)
    }
    wg.Wait()
    close(results)
}

```

Вышеприведенная функция принимает в качестве параметра количество рабочих, которые должны быть созданы. Он вызывается `wg.Add(1)` перед созданием горутины для увеличения счетчика WaitGroup. Затем он создает рабочие горутины, передавая указатель группы ожидания `wg` на `worker` функцию. После создания необходимых рабочих горутин он ждет, пока все горутины закончат свое выполнение, вызывая `wg.Wait()` . После завершения выполнения всех горутин `results` канал закрывается, так как все горутины завершили свое выполнение и больше никто не будет писать в `results` канал.

Теперь, когда у нас есть готовый пул воркеров, давайте напишем функцию, которая будет распределять задания между воркерами.

```go
func allocate(noOfJobs int) {
    for i := 0; i < noOfJobs; i++ {
        randomno := rand.Intn(999)
        job := Job{i, randomno}
        jobs <- job
    }
    close(jobs)
}

```

Приведенная `allocate` выше функция принимает в качестве входного параметра количество создаваемых заданий, генерирует псевдослучайные числа с максимальным значением `998` , создает `Job` структуру, используя случайное число и счетчик цикла for `i` в качестве идентификатора, а затем записывает их в `jobs` канал. Он закрывает `jobs` канал после записи всех заданий.

Следующим шагом будет создание функции, которая считывает `results` канал и печатает вывод.

```go
func result(done chan bool) {
    for result := range results {
        fmt.Printf("Job id %d, input random no %d , sum of digits %d\n", result.job.id, result.job.randomno, result.sumofdigits)
    }
    done <- true
}

```

Функция `result` считывает `results` канал и печатает идентификатор задания, вводит случайный номер и сумму цифр случайного номера. Функция результата также принимает `done` канал в качестве параметра, в который она записывает после того, как распечатает все результаты.

Теперь у нас все готово. Давайте продолжим и закончим последний шаг вызова всех этих функций из `main()` функции.

```go
func main() {
    startTime := time.Now()
    noOfJobs := 100
    go allocate(noOfJobs)
    done := make(chan bool)
    go result(done)
    noOfWorkers := 10
    createWorkerPool(noOfWorkers)
    <-done
    endTime := time.Now()
    diff := endTime.Sub(startTime)
    fmt.Println("total time taken ", diff.Seconds(), "seconds")
}

```

Сначала мы сохраняем время начала выполнения программы в строке № 2 основной функции, а в последней строке (строка № 12) мы вычисляем разницу во времени между endTime и startTime и отображаем общее время, которое потребовалось для программы. бежать. Это необходимо, потому что мы проведем некоторые тесты, изменив количество горутин.

Значение `noOfJobs` устанавливается равным 100, а затем `allocate` вызывается для добавления заданий в `jobs` канал.

Затем `done` создается канал и передается `result` горутине, чтобы она могла начать печатать вывод и уведомлять, как только все будет напечатано.

Наконец `10` , вызовом `createWorkerPool` функции создается пул рабочих горутин, а затем main ожидает на `done` канале вывода всех результатов.

Вот полная программа для справки. Я также импортировал необходимые пакеты.

```go
package main

import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)

type Job struct {
    id       int
    randomno int
}
type Result struct {
    job         Job
    sumofdigits int
}

var jobs = make(chan Job, 10)
var results = make(chan Result, 10)

func digits(number int) int {
    sum := 0
    no := number
    for no != 0 {
        digit := no % 10
        sum += digit
        no /= 10
    }
    time.Sleep(2 * time.Second)
    return sum
}
func worker(wg *sync.WaitGroup) {
    for job := range jobs {
        output := Result{job, digits(job.randomno)}
        results <- output
    }
    wg.Done()
}
func createWorkerPool(noOfWorkers int) {
    var wg sync.WaitGroup
    for i := 0; i < noOfWorkers; i++ {
        wg.Add(1)
        go worker(&wg)
    }
    wg.Wait()
    close(results)
}
func allocate(noOfJobs int) {
    for i := 0; i < noOfJobs; i++ {
        randomno := rand.Intn(999)
        job := Job{i, randomno}
        jobs <- job
    }
    close(jobs)
}
func result(done chan bool) {
    for result := range results {
        fmt.Printf("Job id %d, input random no %d , sum of digits %d\n", result.job.id, result.job.randomno, result.sumofdigits)
    }
    done <- true
}
func main() {
    startTime := time.Now()
    noOfJobs := 100
    go allocate(noOfJobs)
    done := make(chan bool)
    go result(done)
    noOfWorkers := 10
    createWorkerPool(noOfWorkers)
    <-done
    endTime := time.Now()
    diff := endTime.Sub(startTime)
    fmt.Println("total time taken ", diff.Seconds(), "seconds")
}

```

[Бегать на детской площадке](https://play.golang.org/p/au5islUIbx)

Пожалуйста, запустите эту программу на вашем локальном компьютере для более точного расчета общего времени.

Эта программа будет печатать,

```
Job id 1, input random no 636, sum of digits 15
Job id 0, input random no 878, sum of digits 23
Job id 9, input random no 150, sum of digits 6
...
total time taken  20.01081009 seconds

```

Всего будет напечатано 100 строк, соответствующих 100 заданиям, а затем, наконец, в последней строке будет напечатано общее время, необходимое для запуска программы. Ваш вывод будет отличаться от моего, так как Горутины могут работать в любом порядке, а общее время также зависит от аппаратного обеспечения. В моем случае для завершения программы требуется около 20 секунд.

Теперь давайте увеличим `noOfWorkers` в `main` функции до `20` . Мы удвоили количество рабочих. Поскольку количество рабочих горутин увеличилось (точнее, вдвое), общее время, необходимое для завершения программы, должно уменьшиться (точнее, вдвое). В моем случае это стало 10,004364685 секунд, и программа напечатала,

```
...
total time taken  10.004364685 seconds

```

Теперь мы можем понять, что по мере увеличения количества рабочих горутин общее время, необходимое для выполнения заданий, уменьшается. Я оставляю вам в качестве упражнения поиграться с функцией `noOfJobs` и с различными значениями и проанализировать результаты. `noOfWorkers` `main`
