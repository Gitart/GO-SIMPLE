# Гарантии порядка памяти в Go

### Об упорядочении памяти

Многие компиляторы (во время компиляции) и процессоры ЦП (во время выполнения) часто проводят некоторую оптимизацию, корректируя порядок выполнения инструкций, так что порядок выполнения инструкций может отличаться от порядка, представленного в коде. Упорядочивание инструкций также часто называют [упорядочением памяти](https://en.wikipedia.org/wiki/Memory_ordering) .

Разумеется, переупорядочивание инструкций не может быть произвольным. Основным требованием для переупорядочения внутри указанной горутины является то, что переупорядочение не должно обнаруживаться самой горутиной, если горутина не делится данными с другими горутинами. Другими словами, с точки зрения такой горутины, она может думать, что порядок выполнения ее инструкций всегда совпадает с порядком, указанным в коде, даже если внутри нее действительно происходит переупорядочение инструкций.

Однако, если некоторые горутины совместно используют некоторые данные, то переупорядочение инструкций происходит внутри одной из этих горутин, может наблюдаться другими горутинами и влиять на поведение всех этих горутин. Совместное использование данных между горутинами распространено в параллельном программировании. Если мы проигнорируем результаты, вызванные переупорядочением инструкций, поведение наших параллельных программ может зависеть от компилятора и процессора и часто будет ненормальным.

Вот непрофессиональная программа Go, которая не учитывает переупорядочивание инструкций. программа расширена из примера в официальной документации [Go 1 модель памяти](https://golang.org/ref/mem) .

```go
package main

import "log"
import "runtime"

var a string
var done bool

func setup() {
	a = "hello, world"
	done = true
	if done {
		log.Println(len(a)) // always 12 once printed
	}
}

func main() {
	go setup()

	for !done {
		runtime.Gosched()
	}
	log.Println(a) // expected to print: hello, world
}

```

Поведение этой программы вполне возможно, как мы и ожидали, `hello, world` будет напечатан текст. Однако поведение этой программы зависит от компилятора и процессора. Если программа скомпилирована с помощью другого компилятора или более поздней версии компилятора или работает на другой архитектуре, `hello, world` текст может быть не напечатан или `hello, world` может быть напечатан текст, отличный от . Причина в том, что компиляторы и ЦП могут поменяться порядком выполнения первых двух строк в `setup` функции, поэтому окончательный эффект `setup` функции может стать

```go
func setup() {
	done = true
	a = "hello, world"
	if done {
		log.Println(len(a))
	}
}

```

Горутина `setup` в приведенной выше программе не может наблюдать за изменением порядка, поэтому `log.Println(len(a))` строка всегда будет печататься `12` (если эта строка будет выполнена до выхода из программы). Однако главная горутина может наблюдать за изменением порядка, поэтому напечатанный текст может быть не `hello, world` .

Помимо проблемы с игнорированием переупорядочивания памяти, в программе есть гонки данных. При использовании переменной `a` и `done` . Таким образом, приведенная выше программа представляет собой витрину, полную параллельных ошибок программирования. Профессиональный программист на Go не должен совершать этих ошибок.

Мы можем использовать `go build -race` команду, предоставленную в Go Toolchain, для создания программы, затем мы можем запустить полученный исполняемый файл, чтобы проверить, есть ли в программе гонки данных.

### Перейти к модели памяти

Иногда нам нужно убедиться, что выполнение некоторых строк кода в горутине должно происходить до (или после) выполнения некоторых строк кода в другой горутине (с точки зрения любой из двух горутин), чтобы сохранить правильность программа. В таких случаях изменение порядка инструкций может вызвать некоторые проблемы. Что мы должны сделать, чтобы предотвратить возможное изменение порядка инструкций?

Различные архитектуры ЦП предоставляют разные инструкции ограждения, чтобы предотвратить различные виды переупорядочения инструкций. Некоторые языки программирования предоставляют соответствующие функции для вставки этих инструкций ограждения в код. Однако понимание и правильное использование инструкций забора поднимает планку параллельного программирования.

Философия дизайна Go состоит в том, чтобы использовать как можно меньше функций для поддержки как можно большего количества вариантов использования, в то же время обеспечивая достаточно хорошую общую эффективность выполнения кода. Таким образом, встроенные и стандартные пакеты Go не предоставляют прямых способов использования инструкций ограничения ЦП. На самом деле инструкции ограничения ЦП используются для реализации всех видов методов синхронизации, поддерживаемых в Go. Таким образом, мы должны использовать эти методы синхронизации, чтобы обеспечить ожидаемый порядок выполнения кода.

В оставшейся части текущей статьи будут перечислены некоторые гарантированные (и негарантированные) порядки выполнения кода в Go, которые упоминаются или не упоминаются в [модели памяти Go 1](https://golang.org/ref/mem) и другой официальной документации Go.

В следующих описаниях, если мы говорим, что event `A` гарантированно произойдет до event `B` , это означает, что любая из горутин, участвующих в двух событиях, заметит, что любое из операторов, представленных перед событием `A` в исходном коде, будет выполнено до любого из операторов, представленных после. событие `B` в исходном коде. Для других нерелевантных горутин наблюдаемые порядки могут отличаться от только что описанных.

#### Создание горутины происходит до выполнения горутины.

В следующей функции присваивание `x, y = 123, 789` будет выполнено до вызова `fmt.Println(x)` , а вызов `fmt.Println(x)` будет выполнен до вызова `fmt.Println(y)` .

```go
var x, y int
func f1() {
	x, y = 123, 789
	go func() {
		fmt.Println(x)
		go func() {
			fmt.Println(y)
		}()
	}()
}

```

Однако порядок выполнения трех следующих функций не является детерминированным. В этой функции есть гонки данных.

```go
var x, y int
func f2() {
	go func() {
		// Might print 0, 123, or some others.
		fmt.Println(x)
	}()
	go func() {
		// Might print 0, 789, or some others.
		fmt.Println(y)
	}()
	x, y = 123, 789
}

```

#### Гарантии заказа, связанные с операциями канала

В модели памяти Go 1 перечислены следующие три гарантии порядка, связанные с каналами.

1.  ***N*** \- я успешная отправка в канал происходит до того , как завершится ***n*** \-й успешный прием из этого канала, независимо от того, буферизован этот канал или небуферизован.
2.  ***N*** \- й успешный прием из канала с пропускной способностью ***m*** происходит до завершения ( ***n+m*** )-й успешной отправки в этот канал. В частности, если этот канал не буферизован ( `m == 0` ), ***n*** \-й успешный прием с этого канала происходит до завершения ***n*** \-й успешной отправки по этому каналу.
3.  Закрытие канала происходит до завершения приема, если прием возвращает нулевое значение, поскольку канал закрыт.

На самом деле завершение ***n*** \-й успешной отправки в канал и завершение ***n*** \-го успешного приема из того же канала являются одним и тем же событием.

Вот пример, показывающий некоторые гарантированные порядки выполнения кода при использовании небуферизованного канала.

```go
func f3() {
	var a, b int
	var c = make(chan bool)

	go func() {
		a = 1
		c <- true
		if b != 1 { // impossible
			panic("b != 1") // will never happen
		}
	}()

	go func() {
		b = 1
		<-c
		if a != 1  { // impossible
			panic("a != 1") // will never happen
		}
	}()
}

```

Здесь для двух вновь созданных горутин гарантированы следующие порядки:

*   выполнение присваивания `b = 1` полностью заканчивается до оценки условия `b != 1` .
*   выполнение присваивания `a = 1` полностью заканчивается до оценки условия `a != 1` .

Таким образом, два вызова `panic` в приведенном выше примере никогда не будут выполнены. Однако `panic` вызовы в следующем примере могут выполняться.

```go
func f4() {
	var a, b, x, y int
	c := make(chan bool)

	go func() {
		a = 1
		c <- true
		x = 1
	}()

	go func() {
		b = 1
		<-c
		y = 1
	}()

	// Many data races are in this goroutine.
	// Don't write code as such.
	go func() {
		if x == 1 {
			if a != 1 { // possible
				panic("a != 1") // may happen
			}
			if b != 1 { // possible
				panic("b != 1") // may happen
			}
		}

		if y == 1 {
			if a != 1 { // possible
				panic("a != 1") // may happen
			}
			if b != 1 { // possible
				panic("b != 1") // may happen
			}
		}
	}()
}

```

Здесь для третьей горутины, которая не имеет отношения к операциям на канале `c` . Не будет гарантировано соблюдение порядка, наблюдаемого первыми двумя вновь созданными горутинами. Таким образом, любой из четырех `panic` вызовов может быть выполнен.

Фактически, большинство реализаций компилятора гарантируют, что четыре `panic` вызова в приведенном выше примере никогда не будут выполнены, однако официальная документация Go никогда не дает таких гарантий. Таким образом, код в приведенном выше примере несовместим с кросс-компилятором или кросс-компилятором. Мы должны придерживаться официальной документации Go, чтобы писать профессиональный код Go.

Вот пример использования буферизованного канала.

```go
func f5() {
	var k, l, m, n, x, y int
	c := make(chan bool, 2)

	go func() {
		k = 1
		c <- true
		l = 1
		c <- true
		m = 1
		c <- true
		n = 1
	}()

	go func() {
		x = 1
		<-c
		y = 1
	}()
}

```

Следующие заказы гарантированы:

*   исполнение `k = 1` заканчивается до исполнения `y = 1` .
*   исполнение `x = 1` заканчивается до исполнения `n = 1` .

Однако `x = 1` не гарантируется, что выполнение и произойдет до выполнения `l = 1` и `m = 1` , а выполнение `l = 1` и `m = 1` не обязательно произойдет до выполнения `y = 1` .

Ниже приведен пример закрытия канала. В этом примере выполнение `k = 1` гарантированно завершится до выполнения `y = 1` , но не гарантированно завершится до выполнения `x = 1` ,

```go
func f6() {
	var k, x, y int
	c := make(chan bool, 1)

	go func() {
		c <- true
		k = 1
		close(c)
	}()

	go func() {
		<-c
		x = 1
		<-c
		y = 1
	}()
}

```

#### Гарантии порядка, связанные с Mutex

Ниже приведены гарантии порядка, связанные с мьютексами, в Go.

1.  Для адресуемого значения `m` типа `Mutex` или `RWMutex` в `sync` стандартном пакете ***n*** \-й успешный `m.Unlock()` вызов метода происходит до возврата ( ***n+1*** )-го вызова метода. `m.Lock()`
2.  Для адресуемого значения `rw` типа `RWMutex` , если его ***n*** \-й `rw.Lock()` вызов метода вернулся, то его ***n*** \-й успешный `rw.Unlock()` вызов метода происходит до возврата любого `rw.RLock()` вызова метода, который гарантированно произойдет после возврата ***n*** \-го `rw.Lock()` вызова метода.
3.  Для адресуемого значения `rw` типа `RWMutex` , если его ***n*** \-й `rw.RLock()` вызов метода возвратился, то его ***m*** \-й успешный `rw.RUnlock()` вызов метода, где `m <= n` , происходит до возврата любого `rw.Lock()` вызова метода, который гарантированно произойдет после возврата ***n*** \-го `rw.RLock()` вызова метода.

В следующем примере гарантированы следующие заказы:

*   исполнение `a = 1` заканчивается до исполнения `b = 1` .
*   исполнение `m = 1` заканчивается до исполнения `n = 1` .
*   исполнение `x = 1` заканчивается до исполнения `y = 1` .

```go
func fab() {
	var a, b int
	var l sync.Mutex // or sync.RWMutex

	l.Lock()
	go func() {
		l.Lock()
		b = 1
		l.Unlock()
	}()
	go func() {
		a = 1
		l.Unlock()
	}()
}

func fmn() {
	var m, n int
	var l sync.RWMutex

	l.RLock()
	go func() {
		l.Lock()
		n = 1
		l.Unlock()
	}()
	go func() {
		m = 1
		l.RUnlock()
	}()
}

func fxy() {
	var x, y int
	var l sync.RWMutex

	l.Lock()
	go func() {
		l.RLock()
		y = 1
		l.RUnlock()
	}()
	go func() {
		x = 1
		l.Unlock()
	}()
}

```

Обратите внимание, что в следующем коде, согласно официальной документации Go, выполнение `p = 1` не гарантируется до завершения выполнения `q = 1` , хотя большинство компиляторов делают такие гарантии.

```go
var p, q int
func fpq() {
	var l sync.Mutex
	p = 1
	l.Lock()
	l.Unlock()
	q = 1
}

```

#### Гарантии заказа, сделанные `sync.WaitGroup` ценностями

Предположим, что в данный момент счетчик, поддерживаемый адресуемым `sync.WaitGroup` значением `wg` , не равен нулю. Если есть группа `wg.Add(n)` вызовов методов, вызванных после заданного времени, и мы можем убедиться, что только последний возвращенный вызов из группы вызовов изменит счетчик, поддерживаемый `wg` на ноль, то каждый из группы вызовов гарантированно произойдет. до возврата `wg.Wait` вызова метода, который вызывается после заданного времени.

Обратите внимание, `wg.Done()` эквивалентно `wg.Add(-1)` .

Пожалуйста, прочтите [пояснения к `sync.WaitGroup` типу](https://go101.org/article/concurrent-synchronization-more.html#waitgroup) , чтобы понять, как использовать `sync.WaitGroup` значения.

#### Гарантии заказа, сделанные `sync.Once` ценностями

Пожалуйста, прочитайте [пояснения к `sync.Once` типу](https://go101.org/article/concurrent-synchronization-more.html#once) , чтобы получить гарантии заказа, сделанные `sync.Once` значениями, и как использовать `sync.Once` значения.

#### Гарантии заказа, сделанные `sync.Cond` ценностями

Трудно дать четкое описание гарантий порядка, сделанных `sync.Cond` значениями. Пожалуйста, прочтите [пояснения к `sync.Cond` типу](https://go101.org/article/concurrent-synchronization-more.html#cond) , чтобы понять, как использовать `sync.Cond` значения.

#### Гарантии заказа, связанные с атомарными операциями

Начиная с Go 1.19, документация модели памяти Go 1 формально определяет, что все атомарные операции, выполняемые в программах Go, ведут себя так, как если бы они выполнялись в некотором последовательно согласованном порядке. Если эффект атомарной операции A наблюдается атомарной операцией B, то A синхронизируется раньше B.

Согласно описаниям в следующем коде, атомарная операция записи переменной `b` гарантированно произойдет до атомарной операции чтения с результатом `1` той же переменной. Следовательно, операция записи переменной `a` также гарантированно произойдет до операции чтения той же переменной. Таким образом, следующая программа гарантированно напечатает `1` .

```go
package main

import (
	"fmt"
	"runtime"
	"sync/atomic"
)

func main() {
	var a, b int32 = 0, 0

	go func() {
		a = 2
		atomic.StoreInt32(&b, 1)
	}()

	for {
		if n := atomic.LoadInt32(&b); n == 1 {
			// The following line always prints 2.
			fmt.Println(a)
			break
		}
		runtime.Gosched()
	}
}

```

Прочтите [эту статью](https://go101.org/article/concurrent-atomic-operation.html) , чтобы узнать, как выполнять атомарные операции.

#### Гарантии заказа, связанные с финализаторами

Вызов `runtime.SetFinalizer(x, f)` происходит до вызова финализации `f(x)` .
