# Сценарии утечки памяти

При программировании на языке, поддерживающем автоматическую сборку мусора, обычно нам не нужно заботиться о проблемах с утечкой памяти, поскольку среда выполнения будет регулярно собирать неиспользуемую память. Однако нам нужно знать о некоторых особых сценариях, которые могут вызвать своего рода или реальную утечку памяти. В оставшейся части текущей статьи будет перечислено несколько таких сценариев.

### Тип утечки памяти, вызванной подстроками

Спецификация Go не указывает, должны ли результирующая строка и базовая строка, участвующие в выражении подстроки, совместно использовать один и тот же базовый [блок памяти](https://go101.org/article/memory-block.html) для размещения [базовых последовательностей байтов](https://go101.org/article/string.html) двух строк. Стандартный компилятор/среда выполнения Go позволяет им совместно использовать один и тот же базовый блок памяти. Это хороший дизайн, который потребляет как память, так и процессор. Но иногда это может вызвать утечку памяти.

Например, после вызова `demo` функции в следующем примере произойдет утечка памяти примерно на 1 Мбайт (вроде), пока переменная уровня пакета `s0` не будет снова изменена в другом месте.

```go
var s0 string // a package-level variable

// A demo purpose function.
func f(s1 string) {
	s0 = s1[:50]
	// Now, s0 shares the same underlying memory block
	// with s1. Although s1 is not alive now, but s0
	// is still alive, so the memory block they share
	// couldn't be collected, though there are only 50
	// bytes used in the block and all other bytes in
	// the block become unavailable.
}

func demo() {
	s := createStringWithLengthOnHeap(1 << 20) // 1M bytes
	f(s)
}

```

Чтобы избежать такой утечки памяти, мы можем преобразовать подстроку в `[]byte` значение, а затем преобразовать `[]byte` значение обратно в `string` .

```go
func f(s1 string) {
	s0 = string([]byte(s1[:50]))
}

```

Недостатком описанного выше способа избежать утечки памяти является наличие двух 50-байтовых дубликатов, которые возникают в процессе преобразования, один из которых не нужен.

Мы можем использовать одну из [оптимизаций](https://go101.org/article/string.html#conversion-optimizations) , сделанных стандартным компилятором Go, чтобы избежать ненужного дублирования с небольшими дополнительными затратами в виде потери памяти в один байт.

```go
func f(s1 string) {
	s0 = (" " + s1[:50])[1:]
}

```

Недостатком описанного выше способа является то, что оптимизация компилятора может впоследствии стать недействительной, а оптимизация может быть недоступна для других компиляторов.

Третий способ избежать утечки памяти — использовать `strings.Builder` поддержку, начиная с версии Go 1.10.

```go
import "strings"

func f(s1 string) {
	var b strings.Builder
	b.Grow(50)
	b.WriteString(s1[:50])
	s0 = b.String()
}

```

Недостаток третьего способа в том, что он немного многословен (по сравнению с первыми двумя способами). Хорошая новость заключается в том, что начиная с Go 1.12 мы можем вызывать `Repeat` функцию с `count` аргументом, как `1` в `strings` стандартном пакете, для клонирования строки. Начиная с Go 1.12, базовая реализация `strings.Repeat` будет использовать `strings.Builder` , чтобы избежать одного ненужного дубликата.

Начиная с версии Go 1.17 в стандартный пакет `Clone` добавлена ​​функция . `strings` Это становится лучшим способом сделать эту работу.

### Тип утечки памяти, вызванной субсрезами

Подобно подстрокам, подсрезы также могут вызывать утечку памяти. В следующем коде после вызова `g` функции большая часть памяти, занятая блоком памяти, в котором размещены элементы `s1` , будет потеряна (если на блок памяти больше не ссылаются значения).

```go
var s0 []int

func g(s1 []int) {
	// Assume the length of s1 is much larger than 30.
	s0 = s1[len(s1)-30:]
}

```

Если мы хотим избежать утечки памяти, мы должны продублировать 30 элементов для `s0` , чтобы живость не помешала собрать `s0` блок памяти, содержащий элементы . `s1`

```go
func g(s1 []int) {
	s0 = make([]int, 30)
	copy(s0, s1[len(s1)-30:])
	// Now, the memory block hosting the elements
	// of s1 can be collected if no other values
	// are referencing the memory block.
}

```

### Тип утечки памяти, вызванной невыполнением сброса указателей в потерянных элементах среза

В следующем коде после вызова `h` функции блок памяти, выделенный для первого и последнего элементов слайса `s` , будет потерян.

```go
func h() []*int {
	s := []*int{new(int), new(int), new(int), new(int)}
	// do something with s ...

	return s[1:3:3]
}

```

Пока возвращенный срез все еще жив, он будет препятствовать `s` сбору любых элементов , что, как следствие, предотвращает сбор двух блоков памяти, выделенных для двух `int` значений, на которые ссылаются первый и последний элементы `s` .

Если мы хотим избежать такой утечки памяти, мы должны сбросить указатели, хранящиеся в потерянных элементах.

```go
func h() []*int {
	s := []*int{new(int), new(int), new(int), new(int)}
	// do something with s ...

	// Reset pointer values.
	s[0], s[len(s)-1] = nil, nil
	return s[1:3:3]
}

```

Нам часто приходится сбрасывать указатели на некоторые старые элементы [среза в операциях удаления](https://go101.org/article/container.html#slice-manipulations) элемента среза .

### Настоящая утечка памяти из-за зависания горутин

Иногда некоторые горутины в программе Go могут оставаться в заблокированном состоянии навсегда. Такие горутины называются висячими горутинами. Go runtime не убьет зависшие горутины, поэтому ресурсы, выделенные для зависших горутин (и блоки памяти, на которые они ссылаются), никогда не будут собирать мусор.

Есть две причины, по которым среда выполнения Go не убивает зависшие горутины. Во-первых, иногда среде выполнения Go трудно определить, будет ли блокирующая горутина заблокирована навсегда. Другое дело, что иногда мы намеренно делаем горутину зависшей. Например, иногда мы можем позволить основной горутине программы Go зависнуть, чтобы избежать выхода из программы.

Мы должны избегать зависания горутин, вызванных некоторыми логическими ошибками в дизайне кода.

### Реальная утечка памяти, вызванная тем, что не останавливаются `time.Ticker` значения, которые больше не используются

Когда `time.Timer` значение больше не используется, через некоторое время оно будет удалено сборщиком мусора. Но это неверно для `time.Ticker` стоимости. Мы должны остановить `time.Ticker` значение, когда оно больше не используется.

### Настоящая утечка памяти, вызванная неправильным использованием финализаторов

Установка финализатора для значения, которое является членом группы циклических ссылок, может [помешать сбору всех блоков памяти, выделенных для группы циклических ссылок](https://golang.org/pkg/runtime/#SetFinalizer) . Это настоящая утечка памяти, а не какая-то.

Например, после того, как следующая функция вызывается и завершается, блоки памяти, выделенные для сборки мусора `x` , `y` не гарантируются при сборке мусора в будущем.

```go
func memoryLeaking() {
	type T struct {
		v [1<<20]int
		t *T
	}

	var finalizer = func(t *T) {
		 fmt.Println("finalizer called")
	}

	var x, y T

	// The SetFinalizer call makes x escape to heap.
	runtime.SetFinalizer(&x, finalizer)

	// The following line forms a cyclic reference
	// group with two members, x and y.
	// This causes x and y are not collectable.
	x.t, y.t = &y, &x // y also escapes to heap.
}

```

Поэтому избегайте установки финализаторов для значений в циклической ссылочной группе.

Кстати, мы [не должны использовать финализаторы в качестве деструкторов объектов](https://go101.org/article/unofficial-faq.html#finalizers) .

### Вид утечки ресурсов из-за отложенных вызовов функций

Пожалуйста, прочитайте [эту статью](https://go101.org/article/defer-more.html#kind-of-resource-leaking) для деталей.
