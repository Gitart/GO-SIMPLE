## go tool trace


```golang
package main

import (
    "os"
    "runtime/trace"
)

func main() {
    f, err := os.Create("trace.out")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    err = trace.Start(f)
    if err != nil {
        panic(err)
    }
    defer trace.Stop()

  // всея остальная логика вашей программы
}
```

## Это позволить сохранят все события, произошедшие в программе, в бинарный файл trace.out. 

После этого можно запускать go tool trace trace.out  
Какие проблемы можно решить с помощью go tool trace?  
Давайте поразмышляем над тем как можно решать типичные проблемы с использованием этого инструмента.  

## Дигностирование проблем с производительностью  
Проблемы производительности могут возникать, когда важная go-рутина блокируется до завершения операции. Это может произойти по целому ряду причин: блокировка на системном вызове; блокировка при работе с общей памятью (каналы, мютексы и т.д.); блокировка из-за различных событий рантайма(например, сборка мусора), кроме того, возможно что планировщик не переключает критически важные рутины с необходимой частотой

Все перечисленные выше проблемы могут быть обнаружены с при использовании go tool trace. Вы можете найти признаки таких проблем на тамлайне “PROCS”, достаточно проверить периоды времени когда когда критическая go-рутина необоснованно долго. Как только вы найдете такой период, просто посмотрите что было запущено в этот момент времени. Это, как минимум, подскажет вам в какую сторону копать.  

Для примера, посмотрите на проблемы с производительностью, описанные в прошлой статье, обратите внимание на долгие GC паузы:   

Красным цветом показан период, когда была запущена только одна go-рутина. При сборке мусора на всех четырех тредах go-рутины запускаются в параллель. Во время фазы сборки мусора “MARK блокируется главная go-рутина. Можете сказать как долго была заблокирована go-рутина runtime.main? На 12 миллисекунд с 626 миллисекунды до 638 миллисекунды.

У меня получилось обнаружить эту проблему вскоре после публикации от команды Go о GC паузах меньше 100 микросекунд. Обнаруженные мною более длинные паузы, которые я увидел с помощью go tool trace, естественно, показались мне странными. Я упомянул об этом в go-nuts рассылке, после чего был заведен баг, который пофиксили в Go 1.8. Правда, мои бенчмарки выявили еще одну проблему с GC паузами, которая остается актуальной на момент написания статьи. Все это было бы невозможно без использования go tool trace

## Диагностирование проблем с параллелизмом

Предположим, что вы пишите программу, которая должна максимально утилизировать все CPUs, но она оказывается медленней чем вы ожидали. Это вполне реально, если ваша программа распараллеливается не так как вы ожидали. Например, слишком много критических секций выполняется последовательно, хотя могли бы выполняться асинхронно (и параллельно).

Давайте посмотрим на примере. Скажем, у нас есть шина для pub/sub сообщений, которую мы хотим запустить в одной go-рутине, что позволит безопасно модифицировать мап подписчиков без использования мютексов. Обработчики запроса пишут входящие сообщения в очередь этой шины. Шина читает сообщения из очереди, проходит по мапе с подписчиками, определяет какому подписчику нужно отправить это сообщение, и пишет сообщение в его сокет. Давайте воспользуемся go tool trace чтобы посмотреть, как все выглядит внутри:

