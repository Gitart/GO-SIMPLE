# Семантика контекстных пакетов в Go

### Введение

Язык программирования Go имеет встроенное ключевое слово `go` для создания горутин, но не имеет ключевых слов или прямой поддержки завершения горутин. В реальной службе возможность тайм-аута и завершения горутин имеет решающее значение для поддержания работоспособности и работы службы. Ни один запрос или задача не может выполняться вечно, поэтому определение задержки и управление ею является обязанностью каждого программиста.

### Входящие запросы к серверу должны создавать контекст

Время создания Контекста всегда максимально раннее при обработке запроса или задачи. Работа с контекстом в начале цикла разработки заставит вас проектировать API так, чтобы он принимал контекст в качестве первого параметра. Даже если вы не уверены на 100 %, что функция нуждается в Контексте, проще удалить Контекст из нескольких функций, чем пытаться добавить Контекст позже.

**Листинг 1**

```
 75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
 76 // pair, this makes for really easy, convenient routing.
 77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
...
 85     // The function to execute for each request.
 86     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
 87         ctx, span := trace.StartSpan(r.Context(), "internal.platform.web")
 88         defer span.End()
...
106    // Add this handler for the specified verb and route.
107    a.TreeMux.Handle(verb, path, h)
108 }

```

В листинге 1 вы видите код, взятый из проекта [сервиса](https://github.com/ardanlabs/service) , который мы преподаем в Ardan Labs. В строке 86 определяется функция-обработчик, привязанная ко всем маршрутам, как показано в строке 107. Именно эта функция начинает обрабатывать любые входящие запросы. В строке 87 для запроса создается диапазон, который принимает контекст в качестве первого параметра [.](https://opencensus.io/) Это первый раз, когда в сервисном коде требуется Контекст.

Что здесь замечательно, так это то, что `http.Request` значение уже содержит контекст. Это было [добавлено](https://golang.org/doc/go1.7#context) в версии 1.7 Go. Это означает, что коду не нужно вручную создавать контекст верхнего уровня. Если бы мы использовали версию 1.8 Go, вам нужно было бы создать пустой контекст перед вызовом `StartSpan` с помощью `context.Background` функции.

**Листинг 2**
[https://golang.org/pkg/context/#Background](https://golang.org/pkg/context/#Background)

```
87         ctx := context.Background()
88         ctx, span := trace.StartSpan(ctx, "internal.platform.web")
89         defer span.End()

```

В листинге 2 показано, как должен выглядеть код в версии 1.8 Go. Как это описано в документации пакета,

*Фон возвращает ненулевой пустой контекст. Он никогда не отменяется, не имеет значения и не имеет срока. Обычно он используется основной функцией, инициализацией и тестами, а также в качестве контекста верхнего уровня для входящих запросов.*

В Go принято использовать имя переменной `ctx` для всех значений контекста. Поскольку Context является интерфейсом, не следует использовать семантику указателя.

**Листинг 3**
[https://golang.org/pkg/context/#Context](https://golang.org/pkg/context/#Context)

```
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}

```

Каждая функция, которая принимает контекст, должна получить свою собственную копию значения интерфейса.

### Исходящие вызовы на серверы должны принимать контекст

Идея этой семантики заключается в том, что вызовы более высокого уровня должны сообщать вызовам более низкого уровня, как долго они готовы ждать. Отличным примером этого является `http` пакет и изменения версии 1.7, внесенные в `Do` метод для учета тайм-аутов в запросе.

**Листинг 4**
[https://play.golang.org/p/9x4kBKO-Y6q](https://play.golang.org/p/9x4kBKO-Y6q)

```
06 package main
07
08 import (
09     "context"
10     "io"
11     "log"
12     "net/http"
13     "os"
14     "time"
15 )
16
17 func main() {
18
19     // Create a new request.
20     req, err := http.NewRequest("GET", "https://www.ardanlabs.com/blog/post/index.xml", nil)
21     if err != nil {
22         log.Println("ERROR:", err)
23         return
24     }
25
26     // Create a context with a timeout of 50 milliseconds.
27     ctx, cancel := context.WithTimeout(req.Context(), 50*time.Millisecond)
28     defer cancel()
29
30     // Bind the new context into the request.
31     req = req.WithContext(ctx)
32
33     // Make the web call and return any error. Do will handle the
34     // context level timeout.
35     resp, err := http.DefaultClient.Do(req)
36     if err != nil {
37       log.Println("ERROR:", err)
38       return
39     }
40
41     // Close the response body on the return.
42     defer resp.Body.Close()
43
44     // Write the response to stdout.
45     io.Copy(os.Stdout, resp.Body)
46 }

```

В листинге 4 программа выдает запрос на rss-ленту блога Ardan с тайм-аутом 50 миллисекунд. В строках 20-24 создается запрос на выполнение `GET` вызова по указанному URL-адресу. Строки 27-28 создают контекст с тайм-аутом 50 миллисекунд. Новый API, добавленный к `Request` значению еще в версии 1.7, — это `WithContext` метод. Этот метод позволяет `Request` обновлять поле контекста значения. В строке 31 это именно то, что делает код.

В строке 35 фактический запрос выполняется с использованием `Do` метода из значения `http` пакета `DefaultClient` . Метод `Do` будет учитывать значение тайм-аута в 50 миллисекунд, которое теперь установлено внутри контекста в `Request` значении. То, что вы видите, это мой код (функция более высокого уровня), сообщающий `Do` методу (функция более низкого уровня), как долго я готов ждать завершения `Do` операции.

### Не храните контексты внутри типа структуры; вместо этого явно передайте контекст каждой функции, которая в нем нуждается.

По сути, любая функция, выполняющая ввод-вывод, должна принимать значение Context в качестве своего первого параметра и учитывать любой тайм-аут или крайний срок, настроенный вызывающей стороной. В случае с `Request` , нужно было учитывать проблемы обратной совместимости. Таким образом, вместо изменения API была реализована механика, показанная в последнем разделе.

Из каждого правила есть исключения. Однако в рамках этого сообщения и любых API из стандартной библиотеки, которые принимают контекст, идиома состоит в том, чтобы первый параметр принимал значение контекста.

**фигура 1**
![](https://www.ardanlabs.com/images/goinggo/106_figure1.png)

На рис. 1 показан пример из `net` пакета, где первый параметр каждого метода принимает контекст в качестве первого параметра и использует `ctx` идиому имени переменной.

### Цепочка вызовов функций между ними должна распространять контекст

Это важное правило, поскольку контекст основан на запросе или задаче. Вы хотите, чтобы Контекст и любые изменения, внесенные в него во время обработки запроса или задачи, распространялись и учитывались.

**Листинг 5**

```
23 // List returns all the existing users in the system.
24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
26     defer span.End()
27
28     users, err := user.List(ctx, u.db)
29     if err != nil {
30         return err
31     }
32
33     return web.Respond(ctx, w, users, http.StatusOK)
34 }

```

В листинге 5 вы видите вызываемую функцию-обработчик, `List` которая выполняется, когда пользователь делает HTTP-запрос для этой конечной точки. Обработчик принимает в качестве своего первого параметра контекст, так как он является частью запроса и будет выполнять ввод-вывод. Вы можете видеть в строках 25, 28 и 33, что одно и то же значение контекста распространяется вниз по стеку вызовов.

Новое значение контекста не создается, так как эта функция не требует его изменения. Если этой функцией будет создано новое значение контекста верхнего уровня, любая существующая информация контекста из вызова более высокого уровня, связанного с этим запросом, будет потеряна. Это не то, что вы хотите.

**Листинг 6**

```
33 // List retrieves a list of existing users from the database.
34 func List(ctx context.Context, db *sqlx.DB) ([]User, error) {
35     ctx, span := trace.StartSpan(ctx, "internal.user.List")
36     defer span.End()
37
38     users := []User{}
39     const q = `SELECT * FROM users`
40
41     if err := db.SelectContext(ctx, &users, q); err != nil {
42         return nil, errors.Wrap(err, "selecting users")
43     }
44
45     return users, nil
46 }

```

В листинге 6 вы видите объявление `List` метода, который был вызван в строке 28 листинга 5. И снова этот метод принимает контекст в качестве своего первого параметра. Затем это значение снова распространяется вниз по стеку вызовов в строках 35 и 41. Поскольку строка 41 является вызовом базы данных, эта функция должна учитывать любую информацию о тайм-ауте, установленную в Context от любого вызывающего объекта выше.

### Замените контекст с помощью WithCancel, WithDeadline, WithTimeout или WithValue.

Поскольку каждая функция может добавлять/изменять контекст для своих конкретных нужд, и эти изменения не должны влиять ни на какую функцию, которая была вызвана до нее, контекст использует семантику значений. Это означает, что любое изменение значения контекста создает новое значение контекста, которое затем распространяется вперед.

**Листинг 7**
[https://play.golang.org/p/8RdBXtfDv1w](https://play.golang.org/p/8RdBXtfDv1w)

```
18 func main() {
19
20     // Set a duration.
21     duration := 150 * time.Millisecond
22
23     // Create a context that is both manually cancellable and will signal
24     // cancel at the specified duration.
25     ctx, cancel := context.WithTimeout(context.Background(), duration)
26     defer cancel()
27
28     // Create a channel to receive a signal that work is done.
29     ch := make(chan data, 1)
30
31     // Ask the goroutine to do some work for us.
32     go func() {
33
34         // Simulate work.
35         time.Sleep(50 * time.Millisecond)
36
37         // Report the work is done.
38         ch <- data{"123"}
39     }()
40
41     // Wait for the work to finish. If it takes too long, move on.
42     select {
43         case d := <-ch:
44             fmt.Println("work complete", d)
45
46         case <-ctx.Done():
47             fmt.Println("work cancelled")
48     }
49 }

```

В листинге 7 приведена небольшая программа, которая показывает семантическую природу значения `WithTimeout` функции. В строке 25 вызов `WithTimeout` возвращает новое значение контекста и `cancel` функцию. Поскольку для вызова функции требуется родительский контекст, код использует `Background` функцию для создания пустого контекста верхнего уровня. Для этого и предназначена эта `Background` функция.

Двигаясь вперед, используется значение Context, созданное `WithTimeout` функцией. Если какие-либо будущие функции в цепочке вызовов нуждаются в своем собственном тайм-ауте или крайнем сроке, они также должны использовать соответствующую `With` функцию и это новое значение контекста в качестве родителя.

Крайне важно, чтобы любая `cancel` функция, возвращаемая из `With` функции, выполнялась до возврата из этой функции. Вот почему идиома состоит в том, чтобы использовать `defer` ключевое слово сразу после `With` вызова, как вы видите в строке 26. Невыполнение этого требования приведет к утечке памяти в вашей программе.

### Когда контекст отменяется, все производные от него контексты также отменяются.

Использование семантики значений для API контекста означает, что каждому новому значению контекста дается все, что есть у родительского контекста, плюс любые новые изменения. Это означает, что если родительский контекст отменяется, все дочерние элементы, производные от этого родительского контекста, также отменяются.

**Листинг 8**
[https://play.golang.org/p/PmhTXiCZUP1](https://play.golang.org/p/PmhTXiCZUP1)

```
20 func main() {
21
22     // Create a Context that can be cancelled.
23     ctx, cancel := context.WithCancel(context.Background())
24     defer cancel()
25
26     // Use the Waitgroup for orchestration.
27     var wg sync.WaitGroup
28     wg.Add(10)
29
30     // Create ten goroutines that will derive a Context from
31     // the one created above.
32     for i := 0; i < 10; i++ {
33         go func(id int) {
34             defer wg.Done()
35
36             // Derive a new Context for this goroutine from the Context
37             // owned by the main function.
38             ctx := context.WithValue(ctx, key, id)
39
40             // Wait until the Context is cancelled.
41             <-ctx.Done()
42             fmt.Println("Cancelled:", id)
43         }(i)
44     }
45
46     // Cancel the Context and any derived Context's as well.
47     cancel()
48     wg.Wait()
49 }

```

В листинге 8 программа создает значение Context, которое можно отменить в строке 23. Затем в строках 32–44 создаются десять горутин. Каждая горутина помещает свой уникальный идентификатор в собственное значение контекста в строке 38. Вызову `WithValue` передается `main` значение контекста функции в качестве его родителя. Затем в строке 41 каждая горутина ждет, пока их контекст не будет отменен.

В строке 47 основная горутина отменяет свое значение Context, а затем ожидает в строке 48, пока все десять горутин получат сигнал, прежде чем закрыть программу. Как только `cancel` функция будет вызвана, все десять горутин в строке 41 разблокируются и выведут сообщение об их отмене. Один звонок, `cancel` чтобы отменить их все.

Это также показывает, что один и тот же контекст может быть передан функциям, работающим в разных горутинах. Контекст безопасен для одновременного использования несколькими горутинами.

### Не передавайте nil Context, даже если это разрешено функцией. Передайте контекст TODO, если вы не уверены, какой контекст использовать

Одна из моих любимых частей пакета Context — `TODO` функция. Я твердо верю, что программист всегда пишет код. Это ничем не отличается от писателя, который пишет варианты статьи. Когда вы пишете код, вы никогда не знаете всего, но, надеюсь, вы знаете достаточно, чтобы двигаться вперед. В конце концов, вы постоянно учитесь, проводите рефакторинг и тестирование.

Много раз я знал, что мне нужен Контекст, но не знал, откуда он возьмется. Я знал, что не несу ответственности за создание контекста верхнего уровня, поэтому об использовании этой `Background` функции не могло быть и речи. Мне нужен был временный контекст верхнего уровня, пока я не выясню, откуда берется настоящий контекст. Это когда вы должны использовать `TODO` функцию над `Background` функцией.

### Используйте значения контекста только для данных в области запроса, которые передаются процессам и API, а не для передачи необязательных параметров функциям.

Это может быть самая важная семантика из всех. Не используйте значение Context для передачи данных в функцию, когда эти данные требуются функции для успешного выполнения ее кода. Другими словами, функция должна иметь возможность выполнять свою логику с пустым значением контекста. В тех случаях, когда функция требует, чтобы информация была в контексте, если эта информация отсутствует, программа должна дать сбой и сигнализировать приложению о завершении работы.

Классический пример неправильного использования передачи данных в вызов функции с использованием контекста — подключение к базе данных. Как правило, вы хотите следовать этому порядку при перемещении данных по вашей программе.

*   Передача данных в качестве параметра функции Это самый простой способ перемещать данные по программе, не скрывая их.

*   Передача данных через приемник Если функция, которой нужны данные, не может изменить свою подпись, используйте метод и передайте данные через приемник.

**Краткий пример использования приемника**

Обработчики запросов — классический пример второго правила. Поскольку функция обработчика привязана к определенному объявлению, сигнатура обработчика не может быть изменена.

**Листинг 9**

```
23 // List returns all the existing users in the system.
24 func (u *User) List(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
25     ctx, span := trace.StartSpan(ctx, "handlers.User.List")
26     defer span.End()
27
28     users, err := user.List(ctx, u.db)
29     if err != nil {
30         return err
31     }
32
33     return web.Respond(ctx, w, users, http.StatusOK)
34 }

```

В листинге 9 вы видите `List` метод-обработчик из проекта службы. Сигнатура этих методов привязана к тому, что определено веб-платформой, и их нельзя изменить. Однако для совершения делового звонка по линии 28 требуется подключение к базе данных. Этот код находит пул соединений не из переданного значения контекста, а из получателя.

**Листинг 10**

```
15 // User represents the User API method handler set.
16 type User struct {
17     db            *sqlx.DB
18     authenticator *auth.Authenticator
19
20 // ADD OTHER STATE LIKE THE LOGGER AND CONFIG HERE.
21 }

```

В листинге 10 вы видите объявление типа приемника. Все, что нужно обработчику запросов, определяется как поля. Это позволяет не скрывать информацию и обеспечивать работу бизнес-уровня с пустым значением контекста.

**Листинг 11**

```
14 // API constructs an http.Handler with all application routes defined.
15 func API(shutdown chan os.Signal, log *log.Logger, db *sqlx.DB, authenticator *auth.Authenticator) http.Handler {
16
...
26     // Register user management and authentication endpoints.
27     u := User{
28         db:            db,
29         authenticator: authenticator,
30     }
31
32     app.Handle("GET", "/v1/users", u.List)

```

В листинге 11 вы видите код, который создает `User` значение, а затем привязывает `List` метод к маршруту. Еще раз, поскольку сигнатура функции-обработчика неизменна, использование получателя и методов — это следующий лучший способ передачи данных без их сокрытия.

**Отладка или отслеживание данных безопасно для передачи в контексте.**

Данные, которые могут быть сохранены и получены из значения Context, представляют собой информацию об отладке и отслеживании.

**Листинг 12**

```
23 // Values represent state for each request.
24 type Values struct {
25     TraceID    string
26     Now        time.Time
27     StatusCode int
28 }

```

В листинге 12 вы видите объявление типа, который создается и хранится внутри каждого значения контекста, созданного для нового запроса. Три поля предоставляют информацию для трассировки и отладки запроса. Эта информация собирается по мере выполнения запроса.

**Листинг 13**

```
75 // Handle is our mechanism for mounting Handlers for a given HTTP verb and path
76 // pair, this makes for really easy, convenient routing.
77 func (a *App) Handle(verb, path string, handler Handler, mw ...Middleware) {
78
...
79     // The function to execute for each request.
80     h := func(w http.ResponseWriter, r *http.Request, params map[string]string) {
…
84     // Set the context with the required values to
85     // process the request.
86     v := Values{
87         TraceID: span.SpanContext().TraceID.String(),
88         Now:     time.Now(),
89     }
90     ctx = context.WithValue(ctx, KeyValues, &v)

```

В листинге 13 вы видите, как `Values` тип конструируется в строке 86, а затем сохраняется внутри контекста в строке 90. Большая часть этой информации требуется ПО промежуточного слоя ведения журнала.

**Листинг 14**

```
20 // Create the handler that will be attached in the middleware chain.
21 h := func(ctx context.Context, w http.ResponseWriter, r *http.Request, params map[string]string) error {
...
25     // If the context is missing this value, request the service
26     // to be shutdown gracefully.
27     v, ok := ctx.Value(web.KeyValues).(*web.Values)
28     if !ok {
29         return web.NewShutdownError("web value missing from context")
30     }
...
34     log.Printf("%s : (%d) : %s %s -> %s (%s)",
35         v.TraceID, v.StatusCode,
36         r.Method, r.URL.Path,
37         r.RemoteAddr, time.Since(v.Now),
38     )

```

Последствия передачи информации через контекст показаны в коде в строках 27-30 листинга 14. Код пытается получить `Values` данные из контекста и проверяет, были ли данные там. Если данных нет, значит, существует серьезная проблема с целостностью, и службу необходимо отключить. Это делается в сервисном коде путем отправки обратно через приложение специального значения ошибки.

Если вы передаете соединения с базой данных или информацию о пользователях на свой бизнес-уровень с помощью контекста, у вас возникают две проблемы:

*   Вам нужно проверить целостность, и вам нужен механизм для быстрого отключения службы.

*   Тестирование и отладка становятся намного сложнее и сложнее. Вы уходите от лучшей ясности и читаемости кода.

### Вывод

Пакет Context определяет API, который обеспечивает поддержку крайних сроков, сигналов отмены и значений в области запроса, которые могут передаваться через границы API и между горутинами. Этот API является неотъемлемой частью любого приложения, которое вы будете писать на Go. Понимание семантики имеет решающее значение, если ваша цель — написать надежное и целостное программное обеспечение.

В посте я попытался разбить семантику, определенную командой Go. Надеюсь, теперь вы лучше понимаете, как более эффективно использовать контекст. Все примеры кода доступны для вас. Если у вас есть какие-либо вопросы, пожалуйста, не стесняйтесь, присылайте мне по электронной почте.

### Заключительные примечания

*   Входящие запросы к серверу должны создавать контекст.
*   Исходящие вызовы на серверы должны принимать контекст.
*   Не храните контексты внутри типа структуры; вместо этого явно передайте контекст каждой функции, которая в нем нуждается.
*   Цепочка вызовов функций между ними должна распространять контекст.
*   Замените контекст с помощью WithCancel, WithDeadline, WithTimeout или WithValue.
*   Когда Контекст отменяется, все Контексты, производные от него, также отменяются.
*   Один и тот же контекст может быть передан функциям, работающим в разных горутинах; Контексты безопасны для одновременного использования несколькими горутинами.
*   Не передавайте nil Context, даже если это разрешено функцией. Передайте контекст TODO, если вы не уверены, какой контекст использовать.
*   Используйте значения контекста только для данных в области запроса, которые передаются процессам и API, а не для передачи необязательных параметров функциям.
