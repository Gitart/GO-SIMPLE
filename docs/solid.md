# Go, SOLID, Go!

Posted on 2019, Oct 13 6 мин. чтения

Как мы пишем большие программы? Декомпозируем задачу на более мелкие части, уменьшаем связность. И в этом нам могут помочь SOLID принципы.

В golang в качестве отдельных частей у нас есть \- пакаджи, структуры, методы и интерфейсы. Давайте расссмотрим SOLID в этих терминах.

## S \- Single responsibility principle

> Каждая часть системы, должна иметь одну и только одну причину для изменения.

На самом верхнем уровне мы декомпозируем систему на пакаджи. В соответствии с этим принципом каждый пакадж должен заниматься какой\-то отдельной вещью.

Дальше пакадж мы делим на структуры с набором методов. Каждая структура и связанные с ней методы несут отвественность за какую\-то более специфическую задачу внутри пакаджа.

Каждый метод структуры выполняет какую\-то одну единственную задачу.

## O \- Open\-closed principle

> Система должна быть открыта для расширения и закрыта для модификации.

В какой\-то момент у нас уже есть правильно работающая система и для добавления нового функционала мы не модифицируем тот код, который уже есть, а добавляем новый.

В каких\-то случаях мы можем воспользоваться embedded типами.

У нас есть базовый класс с устоявшейся функциональностью (структура с методами) и мы можем расширить его засчет embedding механизма в наследнике.

```go
type A struct {
}

func (*A) ask() {
	fmt.Println("Скажите, пожалуйста!")
}

type B struct {
	*A
}

func (p *B) tell() {
	fmt.Println("Конечно, конечно!")
}
```

[https://play.golang.org/p/5elgzwYS7ba](https://play.golang.org/p/5elgzwYS7ba)

В каких\-то случаях подойдет переопределение типов:

```go
type N int64

func (i N) print() {
	fmt.Println(i)
}
```

[https://play.golang.org/p/\_750CKcJMYt](https://play.golang.org/p/_750CKcJMYt)

Но с любым наследованием, как мне кажется, лучше обращаться с осторожностью. Если создать цепочку наследования из 15 классов, каждый из которых расширяет последующий, мы вроде бы и следуем OCP принципу, но код от этого не станет понятнее.

Т.е. всегда в качестве проверки \- декомпозиция, связанность модулей. Стала система понятнее или нет?

На мой взгляд интереснее вариант на основе интерфейсов \- есть постоянная часть, которая не изменяется (интерфейс), и различные имплементации (расширения) этого интерфейса, которые мы можем подключать.

Uncle Bob в своей [статье](https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html) указывает, что крайнее проявление такого подхода \- это архитектура на основе плагинов.

Тот же автор [приводит](https://drive.google.com/file/d/0BwhCYaYDn8EgN2M5MTkwM2EtNWFkZC00ZTI3LWFjZTUtNTFhZGZiYmUzODc1/view), в качестве примера OCP, отрисовку фигур:

*   у нас есть метод который отрисовывает набор фигур

```go
func DrawAllShapes(shapes []Shape) {
	for _, sh := range shapes {
		sh.Draw()
	}
}
```

*   интерфейс отрисовки

```go
type Shape interface {
	Draw()
}
```

*   метод и интерфейс фиксированны, а расширять систему мы можем засчет добавления имплементаций этого интерфейса

[https://play.golang.org/p/7pNNfbBNLz2](https://play.golang.org/p/7pNNfbBNLz2)

Декомпозируем мы систему на отдельные модули? Да.
Стала система понятнее? На мой взгляд, да.

Т.е. определяем в системе более постоянные части и отделяем их интерфейсом от более изменчивых.

## L \- Liskov substitution principle

> Части системы вызаимозаменяемы, если для вызывающего кода их поведение не отличается.

Т.е. на языке go \- интерфейс и набор структур, которые его реализуют.

Самый важный момент, что для кода, который использует этот интерфейс, вызывает методы, \- поведение интерфейса должно быть одинаково при любой структуре, которая подставляется в этот интерфейс.

Т.е. интерфейс должен быть хорошо специфицирован.

Мне нравится пример вот из этой [статьи](https://medium.com/hackernoon/liskov-substitution-principle-a982551d584a):

```go
type Account interface {
	// Withdraw money amount from this account
	Withdraw(money Money)
}

type DefaultAccount struct {
	balance Balance
}

func (p *DefaultAccount) Withdraw(money Money) {
	if !p.enoughMoney(money) {
		return
	}

	p.balance.subtract(money)
}
```

[https://play.golang.org/p/pqaBzTaIY\-6](https://play.golang.org/p/pqaBzTaIY-6)

Код выше нарушает LSP принцип, т.к. интерфейс Account не достаточно подробно документирован (специфицирован), сейчас из его спецификации следует, что Account.Withdraw всегда списывает деньги со счета, но очевидно, что могут быть случаи, когда денег на счете не достаточно.

В качестве исправления более подробно документируем поведение интерфейса:

```go
type Account interface {
	// Withdraw money amount from this account if its balance is enough.
	// Otherwise do nothing.
	Withdraw(money Money)
}
```

[https://play.golang.org/p/RlCPIJqiMar](https://play.golang.org/p/RlCPIJqiMar)

Может быть это выглядит, как копание в мелочах, но на реальном проекте внимательность к документированию интерфейсов сэкономит массу нервов.

## I \- Interface segregation principle

> Множество специализированных интерфейсов \- лучше, чем один общий.

Принцип \- явная отсылка к декомпозиции и у меньшению связанности отдельных частей системы.

Допустим у нас один общий интерфейс, который используют несколько клиентов и каждый клиент использует только часть методов. Мы изменям методы, которые нужны одному клиенту и можем случайно изменить поведение других методов, от которых зависит второй клиент. Или ситуация еще хуже и клиенты пересекаются \- часть методов востребована обоими клиентами, часть методов специфична.

Т.е. для разных типов клиентов нам нужны разные интерфейсы.

## D \- Dependency inversion principle

> Модули должны зависить от абстракиций, а не деталей реализации.

Как мы помним, у нас основной императив \- декомпозиция и уменьшение связности. Зависимость от абстракций (читай интерфейсов в go) как раз про уменьшение связности.

Модуль, который зависит только от интерфейсов, мы можем взять отдельно, на каждый интерфейс подать какой\-то тестовый мок, проверить работу модуля в тестовых сценариях.

Почему, кстати, принцип “инверсии зависимостей”?

Представим такую ситуацию:

*   есть модуль с бизнес логикой
*   он использует модуль, который работает с базой данных
*   бизнес логика и база работают не через интефейс, а напрямую \- в метод (или при инициализации) бизнес логики передается структура, которая реализует работу с базой, т.е. в коде бизнес логика “знает” о модуле базы (в исходниках бизес логики есть директива импорта базы)

 G
 BL
Бизнес логика
 BD
База данных
 BL\->BD `digraph G {
fontname = "Roboto"
fontsize = 12

node [
    fontname = "Roboto"
    fontsize = 12
    shape = "record"
    ]

edge [
    fontname = "Roboto"
    fontsize = 8
    ]

BL [label = "{Бизнес логика}"]

BD [label = "{База данных}"]

rankdir = LR;
edge [arrowhead = "vee"]

BL -> BD

}`

В языках, где используется явная реализация интерфейса, например Java. Мы могли бы в пакадже с бизнес логикой добавить интерфейс базы, который далее везде использовался внутри пакаджа (т.е. убрали зависимость от модуля базы).

А класс внури пакаджа базы уже наследовался бы от этого интерфейса из пакаджа логики.

 G
 clusterBL
Бизнес логика
 clusterBD
База данных
 Intf
BD Интерфейс
 Core
Логика
 CL
Класс работы с BD
 CL\->Intf `digraph G {
    fontname = "Roboto"
    fontsize = 12

    node [
        fontname = "Roboto"
        fontsize = 12
        shape = "record"
        ]

    edge [
        fontname = "Roboto"
        fontsize = 8
        ]

    subgraph clusterBL {
    label = "Бизнес логика"

    Intf [label = "BD Интерфейс"]
    Core [label = "Логика"]
    }

    subgraph clusterBD {
    label = "База данных"

    CL [label = "Класс работы с BD"]
    }

rankdir = RL;
    edge [arrowhead = "empty"]
    CL -> Intf
}`

Направление стрелок на схеме теперь в другую сторону, т.е мы инвертировали зависимости, т.е. принцип инверсии зависимостей.

Но в go получается даже интереснее, нам не нужно явно имплементить интерфейс, т.е. модулю с базой не обязательно иметь зависимость от логики.

 G
 clusterBL
Бизнес логика
 clusterBD
База данных
 Intf
BD Интерфейс
 Core
Логика
 Core\->Intf
 CL
Класс работы с BD `digraph G {
    fontname = "Roboto"
    fontsize = 12

    node [
        fontname = "Roboto"
        fontsize = 12
        shape = "record"
        ]

    edge [
        fontname = "Roboto"
        fontsize = 8
        ]

    subgraph clusterBL {
    rankdir = BT
    label = "Бизнес логика"

    Intf [label = "BD Интерфейс"]
    Core [label = "Логика"]

    edge [
        arrowhead = "none"
        ]
    Core -> Intf
    }

    subgraph clusterBD {
    label = "База данных"

    CL [label = "Класс работы с BD"]
    }
}`

`/business-logic/logic.go`

```go
package businessLogic

type BDInterface interface {
	GetOrder(orderID int64) *Order
	CreateOrder(params) *Order
	...
}

func NewLogic(bd DBInterface) *Logic {

}

type Logic struct {
	bd BDInterface
}

func (p *Logic) Purchase() {
	...
	p.bd.CreateOrder()
	...
}
```

`/database/db.go`

```go
package database

func NewDB(params) *DB {
  ...
}

type DB struct {
}

func (p *DB) GetOrder(orderID int64) *Order {
}

func (p *DB) CreateOrder(params) *Order {
}

...
```

`/main.go`

```go
package main

import (
	businessLogic "project/business-logic"
	"project/database"
)

func main() {
	db := database.NewDB(params)
	logic := businessLogic.NewLogic(db)
	logic.Work()
}
```

Пример не очень удачный, т.к. в коде есть `Order`, который возможно, находится в модуле с бизнес логикой и слой с базой в итоге зависит от бизнес логики \- все, как в примере с Java.

Примечание:

> Под зависимостью понимается зависимость в исходниках, т.е. директива import.
