# Основы буфера протокола: Go

*   **On this page**
*   [Why use protocol buffers?](https://developers.google.com/protocol-buffers/docs/gotutorial#why-use-protocol-buffers)
*   [Where to find the example code](https://developers.google.com/protocol-buffers/docs/gotutorial#where-to-find-the-example-code)
*   [Defining your protocol format](https://developers.google.com/protocol-buffers/docs/gotutorial#defining-your-protocol-format)
*   [Compiling your protocol buffers](https://developers.google.com/protocol-buffers/docs/gotutorial#compiling-your-protocol-buffers)
*   [The Protocol Buffer API](https://developers.google.com/protocol-buffers/docs/gotutorial#the_protocol_buffer_api)
*   [Writing a Message](https://developers.google.com/protocol-buffers/docs/gotutorial#writing_a_message)
*   [Reading a Message](https://developers.google.com/protocol-buffers/docs/gotutorial#reading_a_message)
*   [Extending a Protocol Buffer](https://developers.google.com/protocol-buffers/docs/gotutorial#extending-a-protocol-buffer)

Это руководство представляет собой базовое введение программиста Go в работу с буферами протоколов с использованием версии [proto3](https://developers.google.com/protocol-buffers/docs/proto3) языка буферов протоколов. Пройдясь по созданию простого примера приложения, вы увидите, как

*   Определите форматы сообщений в `.proto` файле.
*   Используйте компилятор буфера протокола.
*   Используйте API-интерфейс буфера протокола Go для записи и чтения сообщений.

Это не исчерпывающее руководство по использованию буферов протоколов в Go. Для получения более подробной справочной информации см. Руководство по [языку буфера протокола, Справочник](https://developers.google.com/protocol-buffers/docs/proto3) по [API](https://pkg.go.dev/google.golang.org/protobuf/proto) Go , [Руководство по сгенерированному коду Go](https://developers.google.com/protocol-buffers/docs/reference/go-generated) и Справочник по [кодированию](https://developers.google.com/protocol-buffers/docs/encoding) .

## Зачем использовать буферы протоколов?

Пример, который мы собираемся использовать, — это очень простое приложение «адресная книга», которое может читать и записывать контактные данные людей в файл и из него. У каждого человека в адресной книге есть имя, идентификатор, адрес электронной почты и контактный номер телефона.

Как вы сериализуете и извлекаете такие структурированные данные? Есть несколько способов решить эту проблему:

*   Используйте [gobs](https://golang.org/pkg/encoding/gob/) для сериализации структур данных Go. Это хорошее решение в среде, специфичной для Go, но оно не работает, если вам нужно обмениваться данными с приложениями, написанными для других платформ.
*   Вы можете изобрести специальный способ кодирования элементов данных в одну строку — например, кодирование 4 целых чисел как «12:3:-23:67». Это простой и гибкий подход, хотя он требует написания одноразового кода для кодирования и синтаксического анализа, а синтаксический анализ требует небольших затрат во время выполнения. Это лучше всего работает для кодирования очень простых данных.
*   Сериализация данных в XML. Этот подход может быть очень привлекательным, поскольку XML (вроде как) удобочитаем для человека и существуют библиотеки связывания для множества языков. Это может быть хорошим выбором, если вы хотите обмениваться данными с другими приложениями/проектами. Однако XML, как известно, занимает много места, и его кодирование/декодирование может сильно снизить производительность приложений. Кроме того, навигация по дереву XML DOM значительно сложнее, чем навигация по простым полям в классе.

Буферы протоколов являются гибким, эффективным, автоматизированным решением именно этой проблемы. С помощью буферов протокола вы пишете `.proto` описание структуры данных, которую хотите сохранить. Из этого компилятор буфера протокола создает класс, который реализует автоматическое кодирование и анализ данных буфера протокола в эффективном двоичном формате. Сгенерированный класс предоставляет геттеры и сеттеры для полей, составляющих буфер протокола, и заботится о деталях чтения и записи буфера протокола как единого целого. Важно отметить, что формат буфера протокола поддерживает идею расширения формата с течением времени таким образом, что код все еще может считывать данные, закодированные в старом формате.

## Где найти пример кода

Наш пример представляет собой набор приложений командной строки для управления файлом данных адресной книги, закодированным с использованием буферов протокола. Команда `add_person_go` добавляет новую запись в файл данных. Команда `list_people_go` анализирует файл данных и выводит данные на консоль.

Вы можете найти полный пример в [каталоге примеров](https://github.com/protocolbuffers/protobuf/tree/master/examples) репозитория GitHub.

## Определение формата вашего протокола

Чтобы создать приложение адресной книги, вам нужно начать с `.proto` файла. Определения в `.proto` файле просты: вы добавляете *сообщение* для каждой структуры данных, которую хотите сериализовать, затем указываете имя и тип для каждого поля в сообщении. В нашем примере это `.proto` файл, определяющий сообщения [`addressbook.proto`](https://github.com/protocolbuffers/protobuf/blob/master/examples/addressbook.proto) .

Файл `.proto` начинается с объявления пакета, что помогает предотвратить конфликты имен между разными проектами.

```
syntax \=  "proto3";
package tutorial;
import  "google/protobuf/timestamp.proto";
```

Опция `go_package` определяет путь импорта пакета, который будет содержать весь сгенерированный код для этого файла. Имя пакета Go будет последним компонентом пути импорта. Например, в нашем примере будет использоваться имя пакета «tutorialpb».

option go\_package \=  "github.com/protocolbuffers/protobuf/examples/go/tutorialpb";

Далее у вас есть определения сообщений. Сообщение — это просто агрегат, содержащий набор типизированных полей. Многие стандартные простые типы данных доступны как типы полей, включая `bool` , `int32` , `float` , `double` и `string` . Вы также можете добавить дополнительную структуру к своим сообщениям, используя другие типы сообщений в качестве типов полей.
```
message Person  { string name \=  1;int32 id \=  2; // Unique ID number for this person. string email \=  3; enum  PhoneType  {MOBILE \=  0;HOME \=  1;WORK \=  2; }message PhoneNumber  { string number \=  1; PhoneType type \=  2; }repeated PhoneNumber phones \=  4;

  google.protobuf.Timestamp last\_updated \=  5;
}

// Our address book file is just one of these.message AddressBook  {repeated Person people \=  1;
}
```

В приведенном выше примере `Person` сообщение содержит `PhoneNumber` сообщения, а `AddressBook` сообщение содержит `Person` сообщения. Вы даже можете определить типы сообщений, вложенные в другие сообщения — как видите, `PhoneNumber` тип определен внутри `Person` . Вы также можете определить `enum` типы, если хотите, чтобы одно из ваших полей имело одно из предопределенного списка значений — здесь вы хотите указать, что номер телефона может быть одним из `MOBILE` , `HOME` , или `WORK` .

Маркеры «= 1», «= 2» на каждом элементе определяют уникальный «тег», который поле использует в двоичном кодировании. Теги с номерами 1-15 требуют для кодирования на один байт меньше, чем более высокие числа, поэтому в качестве оптимизации вы можете решить использовать эти теги для часто используемых или повторяющихся элементов, оставив теги 16 и выше для менее часто используемых необязательных элементов. Каждый элемент в повторяющемся поле требует повторного кодирования номера тега, поэтому повторяющиеся поля являются особенно хорошими кандидатами для этой оптимизации.

Если значение поля не задано, [используется значение по умолчанию](https://developers.google.com/protocol-buffers/docs/proto3#default) : ноль для числовых типов, пустая строка для строк, false для логических значений. Для встроенных сообщений значением по умолчанию всегда является «экземпляр по умолчанию» или «прототип» сообщения, для которого не задано ни одно из полей. Вызов метода доступа для получения значения поля, которое не было явно задано, всегда возвращает значение этого поля по умолчанию.

Если поле равно `repeated` , оно может повторяться любое количество раз (включая ноль). Порядок повторяющихся значений будет сохранен в буфере протокола. Думайте о повторяющихся полях как о массивах с динамическим размером.

Вы найдете полное руководство по записи `.proto` файлов, включая все возможные типы полей, в [Руководстве по языку буфера протокола](https://developers.google.com/protocol-buffers/docs/proto3) . Однако не ищите средств, подобных наследованию классов — протокольные буферы этого не делают.

## Компиляция буферов вашего протокола

Теперь, когда у вас есть `.proto` , следующее, что вам нужно сделать, это сгенерировать классы, которые вам понадобятся для чтения и записи `AddressBook` (и, следовательно, `Person` и `PhoneNumber` ) сообщений. Для этого вам нужно запустить компилятор буфера протокола `protoc` на вашем `.proto` :

1.  Если вы не установили компилятор, [загрузите пакет](https://developers.google.com/protocol-buffers/docs/downloads) и следуйте инструкциям в файле README.
2.  Выполните следующую команду, чтобы установить плагин буферов протокола Go:

    go install google.golang.org/protobuf/cmd/protoc\-gen\-go@latest

    Плагин компилятора `protoc-gen-go` будет установлен `$GOBIN` в `$GOPATH/bin` . Он должен быть у вас `$PATH` , чтобы компилятор протокола `protoc` его нашел.
3.  Теперь запустите компилятор, указав исходный каталог (где находится исходный код вашего приложения — текущий каталог используется, если вы не укажете значение), целевой каталог (куда вы хотите отправить сгенерированный код; часто то же самое, что и `$SRC_DIR` ) , и путь к вашему `.proto` . В этом случае вы должны вызвать:
```
    protoc -I=$SRC\_DIR --go\_out=$DST\_DIR $SRC\_DIR/addressbook.proto
```
    Поскольку вам нужен код Go, вы используете эту `--go_out` опцию — аналогичные опции предусмотрены для других поддерживаемых языков.

Это генерируется `github.com/protocolbuffers/protobuf/examples/go/tutorialpb/addressbook.pb.go` в указанном вами каталоге назначения.

## API буфера протокола

Генерация `addressbook.pb.go` дает вам следующие полезные типы:

*   `AddressBook` Структура с полем `People` .
*   Структура `Person` с полями для `Name` , `Id` и `Email` . `Phones`
*   Структура `Person_PhoneNumber` с полями для `Number` и `Type` .
*   Тип `Person_PhoneType` и значение, определенные для каждого значения в `Person.PhoneType` перечислении.

Подробнее о том, что именно генерируется, вы можете прочитать в руководстве [Go Generated Code](https://developers.google.com/protocol-buffers/docs/reference/go-generated) , но по большей части вы можете обращаться с ними как с совершенно обычными типами Go.

Вот пример из [`list_people` модульных тестов](https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people_test.go) команды того, как вы можете создать экземпляр Person:
```
p := pb.Person{ Id: 1234, Name: "John Doe", Email:  "jdoe@example.com", Phones:  \[\]\*pb.Person\_PhoneNumber{ {Number:  "555-4321",  Type: pb.Person\_HOME}, },
}
```

## Написание сообщения

Вся цель использования буферов протоколов состоит в том, чтобы сериализовать ваши данные, чтобы их можно было анализировать в другом месте. В Go вы используете `proto` библиотечную функцию [Marshal](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Marshal) для сериализации данных буфера вашего протокола. Указатель на сообщение буфера протокола `struct` реализует `proto.Message` интерфейс. Вызов `proto.Marshal` возвращает буфер протокола, закодированный в его проводном формате. Например, мы используем эту функцию в [`add_person` команде](https://github.com/protocolbuffers/protobuf/blob/master/examples/add_person.go) :
```
book :=  &pb.AddressBook{}
// ...

// Write the new address book back to disk.
out, err := proto.Marshal(book)
if err !=  nil  {
        log.Fatalln("Failed to encode address book:", err)
}
if err := ioutil.WriteFile(fname,  out,  0644); err !=  nil  {
        log.Fatalln("Failed to write address book:", err)
}
```

## Чтение сообщения

Чтобы разобрать закодированное сообщение, вы используете `proto` библиотечную функцию [Unmarshal](https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Unmarshal) . Вызов этого анализирует данные `in` как буфер протокола и помещает результат в `book` . Итак, чтобы разобрать файл в [`list_people` команде](https://github.com/protocolbuffers/protobuf/blob/master/examples/list_people.go) , мы используем:

```
// Read the existing address book.
in, err := ioutil.ReadFile(fname)
if err !=  nil  {
        log.Fatalln("Error reading file:", err)
}book :=  &pb.AddressBook{}
if err := proto.Unmarshal(in, book); err !=  nil  {
        log.Fatalln("Failed to parse address book:", err)
}
```

## Расширение буфера протокола

Рано или поздно после того, как вы выпустите код, использующий ваш буфер протокола, вы, несомненно, захотите «улучшить» определение буфера протокола. Если вы хотите, чтобы ваши новые буферы были совместимы с предыдущими версиями, а ваши старые буферы — с прямой совместимостью — а вы почти наверняка этого хотите — то вам нужно следовать некоторым правилам. В новой версии буфера протокола:

*   вы *не должны* изменять номера тегов любых существующих полей.
*   вы *можете* удалить поля.
*   вы *можете* добавлять новые поля, но вы должны использовать новые номера тегов (т.е. номера тегов, которые никогда не использовались в этом буфере протокола, даже в удаленных полях).

(Есть [некоторые исключения](https://developers.google.com/protocol-buffers/docs/proto3#updating) из этих правил, но они редко используются.)

Если вы будете следовать этим правилам, старый код с радостью прочитает новые сообщения и просто проигнорирует любые новые поля. В старом коде отдельные поля, которые были удалены, просто будут иметь значение по умолчанию, а удаленные повторяющиеся поля будут пустыми. Новый код также будет прозрачно читать старые сообщения.

Однако имейте в виду, что новые поля не будут присутствовать в старых сообщениях, поэтому вам нужно будет сделать что-то разумное со значением по умолчанию. [Используется значение по умолчанию](https://developers.google.com/protocol-buffers/docs/proto3#default) для конкретного типа : для строк значение по умолчанию — пустая строка. Для логических значений значение по умолчанию равно false. Для числовых типов значение по умолчанию равно нулю.
